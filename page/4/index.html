<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="360-site-verification" content="85f7e8dc96dcd0b1a29c6f1cc30c4a73"><meta name="description" content="爱了">
<meta name="keywords" content="yichangkong 博客 技术 java spring">
<meta property="og:type" content="website">
<meta property="og:title" content="YiChangKong">
<meta property="og:url" content="https://yichangkong.github.io/page/4/index.html">
<meta property="og:site_name" content="YiChangKong">
<meta property="og:description" content="爱了">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YiChangKong">
<meta name="twitter:description" content="爱了"><meta name="keywords" content="Liu Jun, YiChangKong"><meta name="description" content="爱了"><title>YiChangKong</title><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/5.13.0/css/all.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">个人</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/Test/"><span class="header-nav-submenu-item__text">日常</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/About/"><span class="header-nav-submenu-item__icon"><i class="far fa-about"></i></span><span class="header-nav-submenu-item__text">关于</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/Poetry/"><span class="header-nav-submenu-item__text">诗歌</span></a></div></div></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">YiChangKong</div><div class="header-banner-info__subtitle">Coding is my life, But not all!</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/28/2020年02月15日软件设计师每日一练/">2020年02月15日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-28</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">7.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">39分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1开发模型">
          <a href="#1开发模型" class="heading-link"><i class="fas fa-link"></i></a>1.开发模型</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328181826.png" alt></p>

        <h4 id="2解析">
          <a href="#2解析" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<blockquote>
<p><strong>增量模型</strong>又称为<strong>渐增模型</strong>，也称为有计划的产品改进模型，</p>
<p>它从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入更多的需求，依此类推，直到系统完成。每个中间版本都要执行必需的过程、活动和任务。</p>
<ul>
<li>增量模型是瀑布模型和原型进化模型的综合，它对软件过程的考虑是：</li>
<li>在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；</li>
<li>但在软件的实际创建中，则将软件系统按功能分解为许多增量构件，并以构件为单位逐个地创建与交付，</li>
<li>直到全部增量构件创建完毕，并都被集成到系统之中交付用户使用。</li>
<li>比较瀑布模型、原型进化模型，增量模型具有非常显著的优越性。</li>
</ul>
<p>但增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的<strong>开放性与稳定性</strong>，能够顺利地实现构件的集成。增量模型有以下不足之处：如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；如果需要不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力。一开始需求不清晰，会影响开发的进度，D选项错误。</p>
</blockquote>

        <h3 id="2开发模型">
          <a href="#2开发模型" class="heading-link"><i class="fas fa-link"></i></a>2.开发模型</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328182147.png" alt></p>

        <h4 id="2解析-2">
          <a href="#2解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<blockquote>
<ol>
<li><strong>瀑布模型</strong>具有可强迫开发人员采用规范的方法；严格规定了各阶段必须提交的文档；要求每个阶段结束后，都要进行严格的评审等优点。但瀑布模型过于理想化，而且缺乏灵活性，无法在开发过程中逐渐明确用户难以确切表达或一时难以想到的需求。</li>
<li><strong>原型模型</strong>一般是基于需求不容易明确这一事实：并非所有的需求在系统开发之前都能准确地说明和定义。因此，它不追求也不可能要求对需求的严格定义，而是采用了动态定义需求的方法。快速原型法适用于需求不够明确的项目。</li>
<li><strong>V模型</strong>一种典型的测试模型，该模型强调开发过程中测试贯穿始终。</li>
<li><strong>螺旋模型</strong>综合了瀑布模型和演化模型的优点，并在此基础上还增加了风险分析。采用螺旋模型时，软件开发沿着螺旋线自内向外旋转，每转一圈都要对风险进行识别和分析，并采取相应的对策。</li>
<li>本题描述的是一个大型项目，那么对文档的要求应该相应较高，而且具备了相关领域及类似规模系统的开发经验，那么系统的需求应该较明确，综合考虑，应该采用瀑布模型。</li>
</ol>
</blockquote>

        <h3 id="3软件开发人员管理">
          <a href="#3软件开发人员管理" class="heading-link"><i class="fas fa-link"></i></a>3.软件开发人员管理</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328190934.png" alt></p>

        <h4 id="2解析-3">
          <a href="#2解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<blockquote>
<p>本题考查的是项目管理的人力资源方面的问题，在团队组建时，需要考虑企业的事业环境因素对项目的影响。<br><br>
在项目中由于分工不同，</p>
<p>每个团队人员不需要充分参与开发过程的所有阶段，并且在软件项目中，</p>
<p>开发只是其中一个阶段，所有不能仅根据开发人员的能力来组织团队，当进度滞后时，增加开发人员不一定能加快开发速度，并且，由于加入新的团队成员，已经成熟的团队会回到磨合期，可能会造成进度更加滞后。<br><br>
综上，本题只有A选项是正确的。</p>
</blockquote>

        <h3 id="4网络攻击">
          <a href="#4网络攻击" class="heading-link"><i class="fas fa-link"></i></a>4.网络攻击</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328191055.png" alt></p>

        <h4 id="2知识引申">
          <a href="#2知识引申" class="heading-link"><i class="fas fa-link"></i></a>2.知识引申</h4>
      
<blockquote>

        <h2 id="攻击分类">
          <a href="#攻击分类" class="heading-link"><i class="fas fa-link"></i></a>攻击分类</h2>
      

        <h3 id="主动攻击">
          <a href="#主动攻击" class="heading-link"><i class="fas fa-link"></i></a>主动攻击</h3>
      
<p>主动攻击会导致某些数据流的篡改和虚假数据流的产生。这类攻击可分为篡改、伪造消息数据和终端（拒绝服务）。</p>
<p>（1）篡改消息</p>
<p>篡改消息是指一个合法消息的某些部分被改变、删除，消息被延迟或改变顺序，通常用以产生一个未授权的效果。如修改传输消息中的数据，将“允许甲执行操作”改为“允许乙执行操作”。</p>
<p>（2）伪造</p>
<p>伪造指的是某个实体（人或系统）发出含有其他实体身份信息的数据信息，假扮成其他实体，从而以欺骗方式获取一些合法用户的权利和特权。</p>
<p>（3）拒绝服务</p>
<p>拒绝服务即常说的DoS（Deny of Service），会导致对通讯设备正常使用或管理被无条件地中断。通常是对整个网络实施破坏，以达到降低性能、终端服务的目的。这种攻击也可能有一个特定的目标，如到某一特定目的地（如安全审计服务）的所有数据包都被阻止。</p>

        <h3 id="被动攻击">
          <a href="#被动攻击" class="heading-link"><i class="fas fa-link"></i></a>被动攻击</h3>
      
<p>被动攻击中攻击者不对数据信息做任何修改，截取/窃听是指在未经用户同意和认可的情况下攻击者获得了信息或相关数据。通常包括窃听、流量分析、破解弱加密的数据流等攻击方式。</p>
<p>（1）流量分析</p>
<p>流量分析攻击方式适用于一些特殊场合，例如敏感信息都是保密的，攻击者虽然从截获的消息中无法的到消息的真实内容，但攻击者还能通过观察这些数据报的模式，分析确定出通信双方的位置、通信的次数及消息的长度，获知相关的敏感信息，这种攻击方式称为流量分析。</p>
<p>（2）窃听</p>
<p>窃听是最常用的手段。应用最广泛的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91" target="_blank" rel="noopener">局域网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上的数据传送是基于广播方式进行的，这就使一台主机有可能受到本子网上传送的所有信息。而计算机的网卡工作在杂收模式时，它就可以将网络上传送的所有信息传送到上层，以供进一步分析。如果没有采取加密措施，通过协议分析，可以完全掌握通信的全部内容，窃听还可以用无限截获方式得到信息，通过高灵敏接受装置接收网络站点辐射的电磁波或网络连接设备辐射的电磁波，通过对电磁信号的分析恢复原数据信号从而获得网络信息。尽管有时数据信息不能通过电磁信号全部恢复，但可能得到极有价值的情报。</p>
<p>由于被动攻击不会对被攻击的信息做任何修改，留下痕迹很好，或者根本不留下痕迹，因而非常难以检测，所以抗击这类攻击的重点在于预防，具体措施包括虚拟专用网<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/VPN" target="_blank" rel="noopener">VPN</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，采用加密技术保护信息以及使用交换式网络设备等。被动攻击不易被发现，因而常常是主动攻击的前奏。</p>
<p>被动攻击虽然难以检测，但可采取措施有效地预防，而要有效地防止攻击是十分困难的，开销太大，抗击主动攻击的主要技术手段是检测，以及从攻击造成的破坏中及时地恢复。检测同时还具有某种威慑效应，在一定程度上也能起到防止攻击的作用。具体措施包括自动审计、入侵检测和完整性恢复等。</p>

        <h2 id="攻击层次">
          <a href="#攻击层次" class="heading-link"><i class="fas fa-link"></i></a>攻击层次</h2>
      
<p>从浅入深的分为以下几个层次：</p>
<p>（1）简单拒绝服务。</p>
<p>（2）<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7" target="_blank" rel="noopener">本地用户</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>获得非授权读权限。</p>
<p>（3）本地用户获得非授权写权限。</p>
<p>（4）<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E7%94%A8%E6%88%B7" target="_blank" rel="noopener">远程用户</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>获得非授权账号信息。</p>
<p>（5）远程用户获得特权文件的读权限。</p>
<p>（6）远程用户获得特权文件的写权限。</p>
<p>（7）远程用户拥有了<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98" target="_blank" rel="noopener">系统管理员</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>权限。</p>

        <h2 id="攻击方法">
          <a href="#攻击方法" class="heading-link"><i class="fas fa-link"></i></a>攻击方法</h2>
      

        <h3 id="口令入侵">
          <a href="#口令入侵" class="heading-link"><i class="fas fa-link"></i></a>口令入侵</h3>
      
<p>所谓口令入侵是指使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动。这种方法的前提是必须先得到该主机上的某个合法用户的账号，然后再进行合法用户口令的破译。获得普通用户账号的方法非常多，如</p>
<p>利用目标主机的Finger功能：当用Finger命令查询时，<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">主机系统</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>会将保存的用户资料（如用户名、登录时间等）显示在<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF" target="_blank" rel="noopener">终端</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>或计算机上；</p>
<p>利用目标主机的X.500服务：有些主机没有关闭X.500的目录查询服务，也给攻击者提供了获得信息的一条简易途径；</p>
<p>从<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">电子邮件地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中收集：有些用户电子邮件地址常会透露其在目标主机上的账号；</p>
<p>查看主机是否有习惯性的账号：有经验的用户都知道，非常多系统会使用一些习惯性的账号，造成账号的泄露。</p>

        <h3 id="特洛伊木马">
          <a href="#特洛伊木马" class="heading-link"><i class="fas fa-link"></i></a>特洛伊木马</h3>
      
<p>放置特洛伊木马程式能直接侵入用户的计算机并进行破坏，他常被伪装成工具程式或游戏等诱使用户打开带有特洛伊木马程式的邮件附件或从网上直接下载，一旦用户打开了这些邮件的附件或执行了这些程式之后，他们就会像古特洛伊人在敌人城外留下的藏满士兵的木马相同留在自己的计算机中，并在自己的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">计算机系统</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中隐藏一个能在<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/Windows/165458" target="_blank" rel="noopener">Windows</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>启动时悄悄执行的程式。当你连接到因特网上时，这个程式就会通知攻击者，来报告你的IP地址及预先设定的端口。攻击者在收到这些信息后，再利用这个潜伏在其中的程式，就能任意地修改你的计算机的参数设定、复制文件、窥视你整个硬盘中的内容等，从而达到控制你的计算机的目的。</p>

        <h3 id="www欺骗">
          <a href="#www欺骗" class="heading-link"><i class="fas fa-link"></i></a>WWW欺骗</h3>
      
<p>在网上用户能利用IE等<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">浏览器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>进行各种各样的WEB站点的访问，如阅读新闻组、咨询产品价格、订阅报纸、电子商务等。然而一般的用户恐怕不会想到有这些问题存在：正在访问的网页已被<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2" target="_blank" rel="noopener">黑客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>篡改过，网页上的信息是虚假的！例如黑客将用户要浏览的网页的URL改写为指向黑客自己的服务器，当用户浏览目标网页的时候，实际上是向黑客服务器发出请求，那么黑客就能达到欺骗的目的了。</p>
<p>一般Web欺骗使用两种技术手段，即URL地址重写技术和相关信关信息掩盖技术。利用URL地址，使这些地址都指向攻击者的Web服务器，即攻击者能将自己的Web地址加在所有URL地址的前面。这样，当用户和站点进行安全链接时，就会毫不防备地进入攻击者的服务器，于是用记的所有信息便处于攻击者的监视之中。但由于浏览器材一般均设有<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%A0%8F" target="_blank" rel="noopener">地址栏</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和状态栏，当浏览器和某个站点边接时，能在地址栏和状态样中获得连接中的Web站点地址及其相关的传输信息，用户由此能发现问题，所以攻击者往往在URL地址重写的同时，利用相关信息排盖技术，即一般用JavaScript程式来重写地址样和状枋样，以达到其排盖欺骗的目的。</p>

        <h3 id="电子邮件">
          <a href="#电子邮件" class="heading-link"><i class="fas fa-link"></i></a>电子邮件</h3>
      
<p>电子邮件是互联网上运用得十分广泛的一种通讯方式。攻击者能使用一些<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%82%AE%E4%BB%B6%E7%82%B8%E5%BC%B9" target="_blank" rel="noopener">邮件炸弹</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>软件或CGI程式向目的邮箱发送大量内容重复、无用的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6" target="_blank" rel="noopener">垃圾邮件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，从而使目的邮箱被撑爆而无法使用。当垃圾邮件的发送流量特别大时，更有可能造成<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">邮件系统</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>对于正常的工作反映缓慢，甚至瘫痪。相对于其他的攻击手段来说，这种攻击方法具有简单、见效快等好处。</p>

        <h3 id="节点攻击">
          <a href="#节点攻击" class="heading-link"><i class="fas fa-link"></i></a>节点攻击</h3>
      
<p>攻击者在突破一台主机后，往往以此主机作为根据地，攻击其他主机（以隐蔽其入侵路径，避免留下蛛丝马迹）。他们能使用<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%9B%91%E5%90%AC" target="_blank" rel="noopener">网络监听</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>方法，尝试攻破同一网络内的其他主机；也能通过IP欺骗和主机信任关系，攻击其他主机。</p>
<p>这类攻击非常狡猾，但由于某些技术非常难掌控，如TCP/IP欺骗攻击。攻击者通过外部计算机伪装成另一台合法机器来实现。他能磙坏两台机器间通信链路上的数据，其伪装的目的在于哄骗网络中的其他机器误将其攻击者作为合法机器加以接受，诱使其他机器向他发送据或允许他修改数据。TCP/IP欺骗能发生TCP/IP系统的所有层次上，包括<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" target="_blank" rel="noopener">数据链路层</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%B1%82" target="_blank" rel="noopener">网络层</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E8%BE%93%E5%B1%82" target="_blank" rel="noopener">运输层</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>及<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener">应用层</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>均容易受到影响。如果底层受到损害，则应用层的所有协议都将处于危险之中。另外由于用户本身不直接和底层相互相交流，因而对底层的攻击更具有欺骗性。</p>

        <h3 id="网络监听">
          <a href="#网络监听" class="heading-link"><i class="fas fa-link"></i></a>网络监听</h3>
      
<p><span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%9B%91%E5%90%AC" target="_blank" rel="noopener">网络监听</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA" target="_blank" rel="noopener">主机</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的一种工作模式，在这种模式下，主机能接收到本<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5" target="_blank" rel="noopener">网段</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>在同一条物理通道上传输的所有信息，而不管这些信息的发送方和接收方是谁。因为系统在进行密码校验时，用户输入的密码需要从用户端传送到服务器端，而攻击者就能在两端之间进行数据监听。此时若两台主机进行通信的信息没有加密，只要使用某些网络监听工具（如NetXRay for 视窗系统95/98/NT、Sniffit for Linux、Solaries等）就可轻而易举地截取包括口令和账号在内的信息资料。虽然网络监听获得的用户账号和口令具有一定的局限性，但监听者往往能够获得其所在网段的所有用户账号及口令。</p>

        <h3 id="黑客软件">
          <a href="#黑客软件" class="heading-link"><i class="fas fa-link"></i></a>黑客软件</h3>
      
<p>利用黑客软件攻击是互连网上比较多的一种攻击手法。Back Orifice2000、冰河等都是比较著名的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%89%B9%E6%B4%9B%E4%BC%8A%E6%9C%A8%E9%A9%AC" target="_blank" rel="noopener">特洛伊木马</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，他们能非法地取得用户计算机的终极用户级权利，能对其进行完全的控制，除了能进行文件操作外，同时也能进行对方<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%A1%8C%E9%9D%A2" target="_blank" rel="noopener">桌面</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%8A%93%E5%9B%BE" target="_blank" rel="noopener">抓图</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、取得密码等操作。这些黑客软件分为服务器端和用户端，当黑客进行攻击时，会使用用户端程式登陆上已安装好服务器端程式的计算机，这些服务器端程式都比较小，一般会随附带于某些软件上。有可能当用户下载了一个小游戏并运行时，黑客软件的服务器端就安装完成了，而且大部分黑客软件的重生能力比较强，给用户进行清除造成一定的麻烦。特别是一种TXT文件欺骗手法，表面看上去是个TXT文本文件，但实际上却是个附带黑客程式的可执行程式，另外有些程式也会伪装成图片和其他格式的文件。</p>

        <h3 id="安全漏洞">
          <a href="#安全漏洞" class="heading-link"><i class="fas fa-link"></i></a>安全漏洞</h3>
      
<p>许多系统都有这样那样的安全漏洞（Bugs）。其中一些是操作系统或应用软件本身具有的。如<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">缓冲区溢出攻击</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。由于非常多系统在不检查程式和缓冲之间变化的情况，就任意接受任意长度的数据输入，把溢出的数据放在<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>里，系统还照常执行命令。这样攻击者只要发送超出缓冲区所能处理的长度的指令，系统便进入不稳定状态。若攻击者特别设置一串准备用作攻击的字符，他甚至能访问根目录，从而拥有对整个网络的绝对控制权。另一些是利用协议漏洞进行攻击。如攻击者利用POP3一定要在根目录下运行的这一漏洞发动攻击，破坏的根目录，从而获得终极用户的权限。又如，ICMP协议也经常被用于发动<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">拒绝服务攻击</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。他的具体手法就是向目的服务器发送大量的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="noopener">数据包</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，几乎占取该服务器所有的网络宽带，从而使其无法对正常的服务请求进行处理，而导致网站无法进入、网站响应速度大大降低或服务器瘫痪。常见的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%A0%95%E8%99%AB%E7%97%85%E6%AF%92" target="_blank" rel="noopener">蠕虫病毒</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>或和其同类的病毒都能对服务器进行<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">拒绝服务攻击</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的进攻。他们的繁殖能力很强，一般通过Microsoft的Outlook软件向众多邮箱发出带有病毒的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%82%AE%E4%BB%B6" target="_blank" rel="noopener">邮件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，而使<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">邮件服务器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>无法承担如此庞大的数据处理量而瘫痪。对于个人上网用户而言，也有可能遭到大量数据包的攻击使其无法进行正常的网络操作。</p>

        <h3 id="端口扫描">
          <a href="#端口扫描" class="heading-link"><i class="fas fa-link"></i></a>端口扫描</h3>
      
<p>所谓端口扫描，就是利用Socket编程和目标主机的某些端口建立TCP连接、进行<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输协议</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的验证等，从而侦知目标主机的扫描端口是否是处于激活状态、主机提供了哪些服务、提供的服务中是否含有某些缺陷等等。常用的扫描方式有：Connect扫描、Fragmentation扫描。</p>

        <h2 id="攻击位置">
          <a href="#攻击位置" class="heading-link"><i class="fas fa-link"></i></a>攻击位置</h2>
      

        <h3 id="远程攻击">
          <a href="#远程攻击" class="heading-link"><i class="fas fa-link"></i></a>远程攻击</h3>
      
<p>指外部攻击者通过各种手段，从该<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%AD%90%E7%BD%91" target="_blank" rel="noopener">子网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>以外的地方向该子网或者该子网内的系统发动攻击。</p>

        <h3 id="本地攻击">
          <a href="#本地攻击" class="heading-link"><i class="fas fa-link"></i></a>本地攻击</h3>
      
<p>指本单位的内部人员，通过所在的局域网，向本单位的其他系统发动攻击，在本级上进行非法越权访问。</p>

        <h3 id="伪远程攻击">
          <a href="#伪远程攻击" class="heading-link"><i class="fas fa-link"></i></a>伪远程攻击</h3>
      
<p>指内部人员为了掩盖攻击者的身份，从本地获取目标的一些必要信息后，攻击过程从外部远程发起，造成外部入侵的现象。</p>

        <h2 id="攻击工具">
          <a href="#攻击工具" class="heading-link"><i class="fas fa-link"></i></a>攻击工具</h2>
      

        <h3 id="dos攻击">
          <a href="#dos攻击" class="heading-link"><i class="fas fa-link"></i></a>DOS攻击</h3>
      
<p>DOS攻击例如：WinNuke通过发送OOB漏洞导致系统蓝屏；Bonk通过发送大量伪造的UDP数据包导致系统重启；TearDrop通过发送重叠的IP碎片导致系统的TCP/IP栈崩溃；WinArp通过发特别数据包在对方机器上产生大量的窗口；Land通过发送大量伪造源IP的基于SYN的TCP请求导致系统重启动；FluShot通过发送特定IP包导致系统凝固；Bloo通过发送大量的ICMP数据包导致系统变慢甚至凝固；PIMP通过IGMP漏洞导致系统蓝屏甚至重新启动；Jolt通过大量伪造的ICMP和UDP导致系统变得非常慢甚至重新启动。</p>

        <h3 id="木马程式">
          <a href="#木马程式" class="heading-link"><i class="fas fa-link"></i></a>木马程式</h3>
      
<p>（1）BO2000（BackOrifice）：他是功能最全的TCP/IP构架的攻击工具，能搜集信息，执行系统命令，重新设置机器，重新定向网络的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF" target="_blank" rel="noopener">客户端</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>/服务器应用程式。BO2000支持多个<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">网络协议</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，他能利用TCP或UDP来传送，还能用XOR<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">加密算法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>或更高级的3DES加密算法加密。感染BO2000后机器就完全在别人的控制之下，<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2" target="_blank" rel="noopener">黑客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>成了终极用户，你的所有操作都可由BO2000自带的“秘密摄像机”录制成“录像带”。</p>
<p>（2）“冰河”：冰河是个国产木马程式，具有简单的中文使用界面，且只有少数流行的反病毒、<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99" target="_blank" rel="noopener">防火墙</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>才能查出冰河的存在。冰河的功能比起国外的木马程式来一点也不逊色。他能自动跟踪目标机器的屏幕变化，能完全模拟键盘及鼠标输入，即在使被控端屏幕变化和监视端产生同步的同时，被监视端的一切键盘及鼠标操作将反映在控端的屏幕。他能记录各种口令信息，包括开机口令、屏保口令、各种共享资源口令及绝大多数在对话框中出现过的口令信息；他能获取系统信息；他还能进行注册表操作，包括对主键的浏览、增删、复制、<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%87%8D%E5%91%BD%E5%90%8D" target="_blank" rel="noopener">重命名</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和对键值的读写等所有注册表操作。</p>
<p>（3）NetSpy：能运行于视窗系统95/98/NT/2000等多种平台上，他是个基于TCP/IP的简单的文件传送软件，但实际上你能将他看作一个没有权限控制的增强型FTP服务器。通过他，攻击者能神不知鬼不觉地下载和上传目标机器上的任意文件，并能执行一些特别的操作。</p>
<p>（4）Glacier：该程式能自动跟踪目标计算机的屏幕变化、获取目标计算机登录口令及各种密码类信息、获取目标<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">计算机系统</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>信息、限制目标计算机系统功能、任意操作目标<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">计算机文件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>及目录、远程关机、发送信息等多种监视功能。类似于BO2000。</p>
<p>（5）KeyboardGhost：视窗系统是个以<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener">消息循环</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/MessageLoop" target="_blank" rel="noopener">MessageLoop</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）为基础的操作系统。系统的核心区保留了一定的字节作为键盘输入的缓冲区，其数据结构形式是队列。键盘幽灵正是通过直接访问这一队列，使键盘上输入你的电子邮箱、代理的账号、密码Password（显示在<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%B1%8F%E5%B9%95" target="_blank" rel="noopener">屏幕</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上的是星号）得以记录，一切涉及以星号形式显示出来的密码窗口的所有符号都会被记录下来，并在系统根目录下生成一文件名为KG.DAT的隐含文件。</p>
<p>（6）<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/ExeBind" target="_blank" rel="noopener">ExeBind</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：这个程式能将指定的攻击程式捆绑到所有一个广为传播的热门软件上，使宿主程式执行时，寄生程式也在后台被执行，且支持多重捆绑。实际上是通过多次分割文件，多次从<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%88%B6%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">父进程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中调用子进程来实现的。</p>

        <h2 id="应对策略">
          <a href="#应对策略" class="heading-link"><i class="fas fa-link"></i></a>应对策略</h2>
      
<p>在对网络攻击进行上述分析和识别的基础上，我们应当认真制定有针对性的策略。明确安全对象，设置强有力的安全保障体系。有的放矢，在网络中层层设防，发挥网络的每层作用，使每一层都成为一道关卡，从而让攻击者无隙可钻、无计可使。还必须做到未雨绸缪，预防为主，将重要的数据备份并时刻注意系统运行状况。以下是针对众多令人担心的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">网络安全</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>问题，提出的几点建议</p>

        <h3 id="提高安全意识">
          <a href="#提高安全意识" class="heading-link"><i class="fas fa-link"></i></a>提高安全意识</h3>
      
<p>（1）不要随意打开来历不明的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6" target="_blank" rel="noopener">电子邮件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>及文件，不要随便运行不太了解的人给你的程式，比如“特洛伊”类<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2" target="_blank" rel="noopener">黑客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>程式就需要骗你运行。</p>
<p>（2）尽量避免从Internet下载不知名的软件、游戏程式。即使从知名的网站下载的软件也要及时用最新的病毒和木马查杀软件对软件和系统进行扫描。</p>
<p>（3）密码设置尽可能使用字母数字混排，单纯的英文或数字非常容易穷举。将常用的密码设置不同，防止被人查出一个，连带到重要密码。重要密码最佳经常更换。</p>
<p>（4）及时下载安装<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%A1%A5%E4%B8%81" target="_blank" rel="noopener">系统补丁</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>程式。</p>
<p>（5）不随便运行<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2" target="_blank" rel="noopener">黑客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>程式，不少这类程式运行时会发出你的个人信息。</p>
<p>（6）在支持HTML的BBS上，如发现提交警告，先看原始码，非常可能是骗取密码的陷阱。</p>

        <h3 id="防火墙软件">
          <a href="#防火墙软件" class="heading-link"><i class="fas fa-link"></i></a>防火墙软件</h3>
      
<p>使用防毒、防黑等防火墙软件。<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99" target="_blank" rel="noopener">防火墙</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是个用以阻止网络中的黑客访问某个机构网络的屏障，也可称之为控制进/出两个方向通信的门槛。在<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%95%8C" target="_blank" rel="noopener">网络边界</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上通过建立起来的相应<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">网络通信</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>监视系统来隔离内部和外部网络，以阻挡外部网络的侵入。</p>

        <h3 id="代理服务器">
          <a href="#代理服务器" class="heading-link"><i class="fas fa-link"></i></a>代理服务器</h3>
      
<p>设置代理服务器，隐藏自己IP地址。保护自己的IP地址是非常重要的。事实上，即便你的机器上被安装了木马程式，若没有你的IP地址，攻击者也是没有办法的，而保护IP地址的最佳方法就是设置<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">代理服务器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。代理服务器能起到外部网络申请访问内部网络的中间转接作用，其功能类似于一个数据转发器，他主要控制哪些用户能访问哪些服务类型。当外部网络向内部网络申请某种网络服务时，代理服务器接受申请，然后他根据其服务类型、服务内容、被服务的对象、服务者申请的时间、申请者的域名范围等来决定是否接受此项服务，如果接受，他就向内部网络转发这项请求。</p>

        <h3 id="其他策略">
          <a href="#其他策略" class="heading-link"><i class="fas fa-link"></i></a>其他策略</h3>
      
<p>将防毒、防黑当成日常例性工作，定时更新防毒组件，将防毒软件保持在常驻状态，以完全防毒；</p>
<p>由于黑客经常会针对特定的日期发动攻击，计算机用户在此期间应特别提高警戒；</p>
<p>对于重要的个人资料做好严密的保护，并养成资料备份的习惯。</p>
</blockquote>

        <h3 id="5面向对象的基本概念">
          <a href="#5面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>5.面向对象的基本概念</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328191420.png" alt></p>

        <h4 id="2解析-4">
          <a href="#2解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<blockquote>
<p>多态分为两种：<strong>通用的多态和特定的多态</strong>。两者的区别是前者对工作的类型不加限制，允许对不同类型的值执行相同的代码；后者只对有限数量的类型有效，而且对不同类型的值可能要执行不同的代码。</p>
<p>通用的多态又分为参数多态（parametric）和包含多态（inclusion）；特定的多态分为过载多态（overloading）和强制多态（coercion）。</p>
<p>强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。程序设计语言中基本类型的大多数操作符，在发生不同类型的数据进行混合运算时，编译程序一般都会进行强制多态。程序员也可以显示地进行强制多态的操作(Casting)。举个例子，比如，int+double，编译系统一般会把int转换为double，然后执行double+double运算，这个int-》double的转换，就实现了强制多态，即可是隐式的，也可显式转换。</p>
<p>过载（overloading）多态：同一个名（操作符﹑函数名）在不同的上下文中有不同的类型。程序设计语言中基本类型的大多数操作符都是过载多态的。通俗的讲法，就是c++中的函数重载。在此处中“overload”译为“过载”，其实就是所谓的“重载”，也许“overload”就应翻译为“过载，重载”吧，那“override”就只能是“覆盖”了。</p>
<p>参数多态：采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。</p>
<p>包含多态：同样的操作可用于一个类型及其子类型。（注意是子类型，不是子类。）包含多态一般需要进行运行时的类型检查。</p>
</blockquote>

        <h3 id="6cocomo">
          <a href="#6cocomo" class="heading-link"><i class="fas fa-link"></i></a>6.COCOMO ||</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328192347.png" alt></p>

        <h4 id="2解析-5">
          <a href="#2解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<blockquote>
<p>COCOMOII模型也需要使用规模估算信息，在模型层次结构中有3种不同规模估算选择，即：对象点、功能点和代码行。</p>
</blockquote>

        <h3 id="7多种程序语言的特点">
          <a href="#7多种程序语言的特点" class="heading-link"><i class="fas fa-link"></i></a>7.多种程序语言的特点</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328192451.png" alt></p>

        <h4 id="2解析-6">
          <a href="#2解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<blockquote>
<p>变量是内存单元的抽象，用于在程序中表示数据。当变量存储的是内存单元地址时，称为指针变量，或者说指针变量指向了另一个变量。指针变量可以定义在函数或复合语句内，也可以定义在所有的函数之外，即可以是全局变量，也可以是局部变量。需要区分指针变量与指针所指向的变量，无论指针变量指向何种变量，其存储空间大小都是一样的。当指针变量指向数组中的一个元素时，对指针变量进行算术运算可以使其指向同一个数组中的其他元素。</p>
</blockquote>

        <h3 id="8文法">
          <a href="#8文法" class="heading-link"><i class="fas fa-link"></i></a>8.文法</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328192645.png" alt></p>

        <h4 id="2解析-7">
          <a href="#2解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<blockquote>
<p>上下文无关文法：形式语言理论中一种重要的变换文法，用来描述上下文无关语言，在乔姆斯基分层中称为2型文法。由于程序设计语言的语法基本上都是上下文无关文法，因此应用十分广泛。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/27/2020年02月14日软件设计师每日一练/">2020年02月14日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-27</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1拓扑排序">
          <a href="#1拓扑排序" class="heading-link"><i class="fas fa-link"></i></a>1.拓扑排序</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327204350.png" alt></p>
<p>答案：A</p>
<p>我的答案：C</p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查图数据结构。<br>
　　对有向图进行拓扑排序的方法如下：<br>
　　（1）在AOV网中选择一个入度为0（没有前驱）的顶点且输出它。<br>
　　（2）从网中删除该顶点及其与该顶点有关的所有边。<br>
　　（3）重复上述两步，直至网中不存在入度为0的顶点为止。<br>
　　执行的结果会有两种情况：一种是所有顶点己输出，此时整个拓扑排序完成，说明网中不存在回路；另一种是尚有未输出的顶点，剩余的顶点均有前驱顶点，表明网中存在回路，拓扑排序无法进行下去。</p>
</blockquote>

        <h3 id="2容量的计算">
          <a href="#2容量的计算" class="heading-link"><i class="fas fa-link"></i></a>2.容量的计算</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327204644.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查内存容量的计算。<br><br>
给定起、止地址码的内存容量=终止地址-起始地址+1。<br></p>
<p>将终止地址加1等于E000H，再减去起始地址，即E0000H-A0000H=40000H。十六进制的（40000）<sub>16</sub>=2<sup>18</sup><br>
　　组成内存储器的芯片数量=内存储器的容量/单个芯片的容量。 答案：C</p>
</blockquote>

        <h3 id="3数字证书">
          <a href="#3数字证书" class="heading-link"><i class="fas fa-link"></i></a>3.数字证书</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205318.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><code>数字证书</code>就是互联网通讯中标志通讯各方身份信息的一系列数据，就好比日常生活中个人身份证一样。</p>
<p>数字证书是由一个权威机构证书授权中心（CA）发行的。</p>
<p>最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。</p>
<p>其中证书授权中心的数字签名是用它自己的私钥完成的，而它的公钥也是公开的，大家可以通过它的公钥来验证该证书是否是某证书授权中心发行的，以达到验证数字证书的真实性。因此本题答案选C。</p>
</blockquote>

        <h3 id="4程序语言">
          <a href="#4程序语言" class="heading-link"><i class="fas fa-link"></i></a>4.程序语言</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205423.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>程序设计语言的基本成分包括</p>
<p>数据、运算、控制和传输等。</p>
<p>程序设计语言的控制成分包括<strong>顺序、选择和循环3种结构</strong>。<br>
所以本题选择A选项。</p>
</blockquote>

        <h3 id="5软件测试">
          <a href="#5软件测试" class="heading-link"><i class="fas fa-link"></i></a>5.软件测试</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205555.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查系统测试中的确认测试。</p>
<p>确认测试首先要进行有效性测试以及软件配置审查，然后进行验收测试和安装测试。</p>
<p>其中有效性测试，就是在模拟环境下，通过黑盒测试检验所开发的软件是否与需求规格说明书一致。</p>
</blockquote>

        <h3 id="6数据表示">
          <a href="#6数据表示" class="heading-link"><i class="fas fa-link"></i></a>6.数据表示</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205704.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查计算机系统<strong>数据编码基础知识</strong>。<br><br>
　　设机器字长为n（即采用n个二进制位表示数据），最高位是符号位，0表示正号，1表示负号。<br><br>
　　原码表示方式下，除符号位外，n-1位表示数值的绝对值。因此，n为8时，[+0]原=0 0000000，[-0]原=1 0000000。<br><br>
　　正数的反码与原码相同，负数的反码则是其绝对值按位求反。n为8时，数值0的反码表示有两种形式：[+0]反=0 0000000，[-0]反=11111111。<br><br>
　　正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。在补码表示中，0有唯一的编码：[+0]补=0 0000000，[-0]补=00000000。<br><br>
　　移码表示法是在数X上增加一个偏移量来定义的，常用于表示浮点数中的阶码。机器字长为n时，在偏移量为2<sup>n-1</sup>的情况下，只要将补码的符号位取反便可获得相应的移码表示。</p>
</blockquote>

        <h3 id="7传址与传值">
          <a href="#7传址与传值" class="heading-link"><i class="fas fa-link"></i></a>7.传址与传值</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205856.png" alt></p>
<p>答案：D</p>
<p>我的：A</p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>传值调用中，形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变；而引用（传址）调用中，形参取的是实参的地址，即相当于实参存储单元的地址引用，因此其值的改变同时就改变了实参的值。<br><br>
x = 2*10-1=19；<br><br>
a是引用传递，所以a=a+x=10+19=29，结果为29。</p>
</blockquote>

        <h3 id="8运算器和控制器">
          <a href="#8运算器和控制器" class="heading-link"><i class="fas fa-link"></i></a>8.运算器和控制器</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327210006.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>CPU是一台计算机的<strong>运算核心</strong>和<strong>控制核心</strong>，</p>
<p>其由<strong>运算器、控制器、寄存器</strong>及实现它们之间联系的数据、控制及状态的总线构成。其中</p>
<ul>
<li>运算器负责相关的逻辑、算术运算，</li>
<li>寄存器用来存放一些相关的数据，而</li>
<li>内部总线负责各部件间信息的传递，而</li>
<li>控制器不仅要保证指令的正确执行，还要能够处理异常事件。</li>
</ul>
</blockquote>

        <h3 id="9面向对象的基本概念">
          <a href="#9面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>9.面向对象的基本概念</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327210157.png" alt></p>

        <h4 id="2题目解析-9">
          <a href="#2题目解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><code>多态</code>：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。也就是说客户类其实在调用方法时，并不需要知道特定子类的实现，都会用统一的方式来调用。</p>
</blockquote>
<h4 id><a class="markdownIt-Anchor" href="#"></a> </h4>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/26/2020年02月13日软件设计师每日一练/">2020年02月13日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-26</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1编译与解释">
          <a href="#1编译与解释" class="heading-link"><i class="fas fa-link"></i></a>1.编译与解释</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326182818.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>​    死循环错误属于典型的<strong>语义错误</strong>，但静态的语义错误可被编译器发现，到程序真正陷入死循环说明编译器并未发现，所以属于动态语义错误。</p>
</blockquote>

        <h3 id="2软件维护类型">
          <a href="#2软件维护类型" class="heading-link"><i class="fas fa-link"></i></a>2.软件维护类型</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326182938.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>软件维护的内容一般包括</p>
<p>准确性维护》适应性维护》完善性维护》预防性维护。</p>
<ul>
<li>正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</li>
<li>适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。</li>
<li>完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</li>
<li>预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。</li>
</ul>
</blockquote>

        <h3 id="3软件测试">
          <a href="#3软件测试" class="heading-link"><i class="fas fa-link"></i></a>3.软件测试</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183158.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>软件测试方法分为静态测试和动态测试。</p>
<ul>
<li>静态测试是被测试程序不在机器上运行而采用人工检测和计算机辅助静态分析手段对程序进行检测。</li>
<li>动态测试是通过运行程序发现错误，对软件产品进行动态测试时可以采用黑盒测试和白盒测试法。</li>
</ul>
<p>黑盒测试法在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。对于无法获得源代码的第三方组件，可采用黑盒对组件进行测试。基本路径覆盖、分支覆盖和环路覆盖需要根据程序的内部结构和逻辑进行测试。</p>
</blockquote>

        <h3 id="4银行家算法">
          <a href="#4银行家算法" class="heading-link"><i class="fas fa-link"></i></a>4.银行家算法</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183617.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183719.png" alt></p>
</blockquote>

        <h3 id="5uml">
          <a href="#5uml" class="heading-link"><i class="fas fa-link"></i></a>5.UML</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183749.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><strong>部署图</strong>展现了运行处理节点以及其中的构件的配置。</p>
<p>部署图给出了体系结构的静态实施视图。它与构件视图相关，通常一个结点包含一个或多个构件。部署图一般描述的是代码或系统在实施中的物理节点分布，组件之间的依赖关系类似于包依赖。</p>
</blockquote>

        <h3 id="6总线系统">
          <a href="#6总线系统" class="heading-link"><i class="fas fa-link"></i></a>6.总线系统</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183909.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>​	总线是在计算机中连接两个或多个功能部件的一组共享的<strong>信息传输线</strong>，它的主要特征就是多个部件共享传输介质。它是构成计算机系统的骨架，是各个功能部件之间进行信息传输的公共通道，借助总线的连接，计算机各个部件之间可以传送地址、数据和各种控制信息。</p>
<p>在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以有效减少信息传输线的数量。</p>
</blockquote>

        <h3 id="7树与二叉树">
          <a href="#7树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>7.树与二叉树</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184026.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<ol>
<li>先序遍历即先根后左子树再右子树，</li>
<li>中序遍历为先左子树后跟再右子树。</li>
</ol>
<p>先序遍历的最开始结点A即为整棵树的根，结合中序遍历，A结点左侧B即为根节点A的左子树，右侧DCFE则为A的右子树，同理可以得出C为A的右子树的根节点,D为C的左子树，EF为C的右子树，F为E的左子树。可以得到如下图，所以该二颗树的高度为4。</p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184114.png" alt></p>
</blockquote>

        <h3 id="8正规式">
          <a href="#8正规式" class="heading-link"><i class="fas fa-link"></i></a>8.正规式</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184210.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>根据图中展示，其正规式应以a开头，a结尾，b可以出现0次或多次，所以是 ab*a，基本上可以排除BCD三项，答案为A。</p>
</blockquote>

        <h3 id="9操作系统">
          <a href="#9操作系统" class="heading-link"><i class="fas fa-link"></i></a>9.操作系统</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184259.png" alt></p>

        <h4 id="2题目解析-9">
          <a href="#2题目解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查的是操作系统中文件管理的基本知识。<br></p>
<p>在使用已经存在的文件之前，要通过“打开(open )”文件操作建立起文件和用户之间的联系，目的是把文件的<strong>控制管理信息从辅存读到内存</strong>。打开文件应完成如下功能：<br></p>
<ul>
<li>在内存的管理表中申请一个空表目，用来存放该文件的文件目录信息。<br></li>
<li>根据文件名在磁盘上查找目录文件。将找到的文件目录信息复制到内存的管理表中。如果打开的是共享文件，则应进行相关处理，如共享用户数加t。<br></li>
<li>文件定位，卷标处理。<br></li>
<li>文件一旦打开，可被反复使用直至文件关闭。这样做的优点是减少查找目录的时间，加快文件存取速度，提高系统的运行效率。因此，本题的正确答案为B。</li>
</ul>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/25/2020年02月12日软件设计师每日一练/">2020年02月12日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1软件保护期限">
          <a href="#1软件保护期限" class="heading-link"><i class="fas fa-link"></i></a>1.软件保护期限</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213244.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>我国《著作权法》对著作权的保护期限作了如下规定: (1)著作权中的署名权、修改权、保护作品完整权的保护期不受限制。</p>
</blockquote>

        <h3 id="2专业英语">
          <a href="#2专业英语" class="heading-link"><i class="fas fa-link"></i></a>2.专业英语</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213355.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>不变只是愿望，变化才是永恒。—SWIFT<br></p>
<p>​		一个接一个的软件项目都是一开始设计算法，然后将算法应用到待发布的软件中，接着根据时间进度把第一次开发的产品发布给客户。<br></p>
<p>​		对于大多数项目，第一个开发的系统并不适用。它可能太慢、太大、难以使用，或者三者兼有。要解决所有的问题，除了重新开始以外，没有其他的办法—即开发一个更灵巧或者更好的系统。系统的丢弃和重新设计可以一步完成，也可以一块块地实现。所有大型系统的经验都显示，这是必须完成的步骤。而且，新的系统概念或新技术会不断出现，因此开发的系统必须被抛弃，但即使是最优秀的项目计划也不能无所不知地在最开始就解决这些问题。<br></p>
<p>​		因此，管理上的问题不再是“是否构建一个实验性的系统，然后抛弃它”，你必须这样做。现在的问题是“是否预先计划抛弃原型的开发，或者是否将该原型发布给用户”。从这个角度看待问题，答案更加清晰。将原型发布给用户，虽然可以获得时间，但是其代价高昂—对于用户，使用极其痛苦；对于重新开发的人员，分散了精力；对于产品，影响了声誉，即使是最好的再设计也难以挽回名声。<br><br>
因此，为舍弃而计划，无论如何，你一定要这样做。<br><br>
​</p>
</blockquote>

        <h3 id="3颜色深度">
          <a href="#3颜色深度" class="heading-link"><i class="fas fa-link"></i></a>3.颜色深度</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213520.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><code>颜色深度</code>是表示位图图像中单个像素的颜色或灰度所占的位数，8位的颜色深度，表示每个像素有8位颜色位，可表示256种不同的颜色。存储位图图像的数据量与图像大小有关。而位图图像的大小与分辨率、颜色深度有关。本题图像的垂直方向分辨率为640像素，水平方向分辨率为480，颜色深度为8位，则该图像所需存储空间为（640×480× 8 ）/8 （Byte） = 307200（Byte）。经5：1压缩后，该图像所需存储空间为307200/5 =61440（Byte）。</p>
</blockquote>

        <h3 id="4gant-和pert图">
          <a href="#4gant-和pert图" class="heading-link"><i class="fas fa-link"></i></a>4.Gant 和Pert图</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214024.png" alt></p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214105.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214129.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214153.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>在软件项目的活动图中，从开始结点到结束结点，<strong>耗时最长的一条路径称为关键路径</strong>。在本题中，关键路径为：A-C-G-J-K。所以备选答案中的C是属于关键路径上的里程碑。</p>
<p>题目中提到“活动AD在活动AC开始3天后才开始，而完成活动DG过程中，由于有临时事件发生，实际需要15天才能完成”，所以可以将AD活动由原来的10天延长至13天，而DG活动由原来的10天延长至15天，此时计算出来的关键路径比原来长了3天，所以整个项目的最短工期会延长3天。</p>
</blockquote>

        <h3 id="5广义表">
          <a href="#5广义表" class="heading-link"><i class="fas fa-link"></i></a>5.广义表</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214314.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查数据结构基础知识。</p>
<p>链表是<strong>最灵活的存储结构</strong>，它允许同一个表中的结点类型可以不一致。静态数组是固定长度的数组，动态数组允许扩容，但是数组中的元素必须是相同类型的，这不适用于广义表。散列表的特点是元素的存储位置与其关键字值相关。</p>
</blockquote>

        <h3 id="6面向对象的基本概念">
          <a href="#6面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>6.面向对象的基本概念</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214504.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查面向对象基本概念中对象类之间的关系。泛化概化关系表示把几类对象类的公共属性和行为抽象成超类，然后其属性和方法被那些子类继承；聚合关系表示一个较大的“整体”类包含一个或多个较小的“部分”类；合成关系则表示关系中“整体”负责其“部分”的创建和销毁，如果“整体”不存在了，“部分”也将不存在。</p>
</blockquote>

        <h3 id="7程序设计思维">
          <a href="#7程序设计思维" class="heading-link"><i class="fas fa-link"></i></a>7.程序设计思维</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214610.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>一个模块的独立度通常使用聚合和祸合程度来度量。聚合衡量模块内部各元素结合的紧密程度：祸合度量不同模块间互相依赖的程度。提高聚合程度，降低模块之间的祸合程度是模块设计应该遵循的最重要的两个原则。聚合与祸合是相辅相成的两个设计原则，模块内的高聚合往往意味着模块之间的松祸合。而要想提高模块内部的聚合性，必须减少模块之间的联系。</p>
</blockquote>

        <h3 id="8文法重点">
          <a href="#8文法重点" class="heading-link"><i class="fas fa-link"></i></a>8.文法（重点）</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214707.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>
 &nbsp;&nbsp;&nbsp; 本题考查语言结构的文法表示。<br>
 &nbsp;&nbsp;&nbsp; 推导就是用产生式的右部替换产生式左部符号。从文法的开始符号出发，不能推导出“（（a，f）） ”、“（abc）”、 “（c，（da））”，产生符号串“（（fac，bb），g）”的最左推导过程如下：<br>
 　　S=&gt;（S，M）=&gt;（（S，M），M）=&gt;（（M，M），M）=&gt;（（MP，M）， M）=&gt;（（MPP， M），M ）<br>
 　　&nbsp;=&gt; （（PPP， M）， M）=&gt;（（fPP， M）， M）=&gt;（（faP， M）， M）”（（fac， M， M）=&gt;（（fac， MP），M）<br>
 　　&nbsp;=&gt; （（faa， PP）， M） =&gt; （（fac， bP）， M）=&gt;（（fac， bb）， M）=&gt;（（fac，bb），g））</p>
</blockquote>

        <h3 id="9侵权判断">
          <a href="#9侵权判断" class="heading-link"><i class="fas fa-link"></i></a>9.侵权判断</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214818.png" alt></p>

        <h4 id="2题目解析-9">
          <a href="#2题目解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查知识产权中关于软件著作权方面的知识。<br><br>
&nbsp;&nbsp;&nbsp; 著作权因作品的完成而自动产生，不必履行任何形式的登记或注册手续，也不论其是否已经发表，所以甲对该软件作品享有著作权。乙未经甲的许可擅自使用甲的软件作品的行为，侵犯了甲的软件著作权。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/24/2020年02月11日软件设计师每日一练/">2020年02月11日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">3.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">18分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1媒体的种类">
          <a href="#1媒体的种类" class="heading-link"><i class="fas fa-link"></i></a>1.媒体的种类</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214951.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<ul>
<li>
<p>感觉媒体：指人们接触信息的感觉形式。如：视觉、听觉、触觉、嗅觉和味觉等。</p>
</li>
<li>
<p>表示媒体：指信息的表示形式。如：文字、图形、图像、动画、音频和视频等。</p>
</li>
<li>
<p>显示媒体（表现媒体）：表现和获取信息的物理设备。如：输入显示媒体键盘、鼠标和麦克风等；输出显示媒体显示器、打印机和音箱等。</p>
</li>
<li>
<p>存储媒体：存储数据的物理设备，如磁盘、光盘和内存等。</p>
</li>
<li>
<p>传输媒体：传输数据的物理载体，如电缆、光缆和交换设备等。</p>
</li>
</ul>
</blockquote>

        <h3 id="2数据库设计">
          <a href="#2数据库设计" class="heading-link"><i class="fas fa-link"></i></a>2.数据库设计</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215311.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215340.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>答案 BADC</p>
<p>试题（53）的正确选项为B。根据题意，零件P关系的主键为（零件号，供应商）。<br></p>
<p>试题（54）的正确选项为A，试题（55）的正确选项为D。试题要求查询各种零件的平均单价、最高单价与最低单价之间差距，因此，首先需要在结果列中的空（54）填写“零件名称，AVG（单价），MAX（单价）-MIN（单价）”。其次必须用分组语句按零件号分组，</p>
<p>故空（55）应填写“GROUP BY零件号”。完整的SQL语句为：<br><br>
　　　　　SELECT 零件号，零件名称，AVG（单价），MAX（单价）-MIN（单价）<br><br>
&nbsp;　　　　 FROM P<br><br>
&nbsp; 　　　　GROUP BY零件号；<br></p>
<p>试题（56）的正确选项为C。为了解决关系P存在冗余以及插入异常和删除异常等问题，需要将零件关系P分解。选项A、选项B和选项D是有损连接的，且不保持函数依赖故分解是错误的，例如，分解为选项A、选项B和选项D后，用户无法查询某零件由哪些供应商供应，原因是分解是有损连接的，且不保持函数依赖。</p><p></p>
</blockquote>

        <h3 id="3编译与解释">
          <a href="#3编译与解释" class="heading-link"><i class="fas fa-link"></i></a>3.编译与解释</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215559.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>答案 A</p>
<p><strong>词法分析阶段</strong>，其任务是从左到右逐个字符地读入源程序，对构成源程序的<strong>字符流</strong>进行扫描和分解，从而识别出一个个单词（也称单词符号或符号）。这里所谓的单词是指逻辑上紧密相连的一组字符，这些字符组合在一起才表示某一含义。</p>
<p>词法分析过程依据的是语言的<strong>词法规则</strong>，即描述“单词” 分析构成程序的字符及由字符按照构造规则构成的符号是否符合程序语言的规定 ”是对单词的检查。</p>
<p><strong>语法分析的任务</strong>是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如“表达式”“语句”和“程序”等。语法规则就是各类语法单位的构成规则。</p>
<p><strong>语义分析阶段</strong>分析各语法结构的含义，检查源程序是否包含静态语言错误，并收集类型信息供后面的代码生成阶段使用。</p>
</blockquote>

        <h3 id="4uml">
          <a href="#4uml" class="heading-link"><i class="fas fa-link"></i></a>4.UML</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220031.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>在UML中，关联的多重度是指一个类的实例能够与另一个类的多少个实例<strong>相关联</strong>。它又称为<strong>重复度</strong>。多重度表示为一个整数范围n…m，整数n定义所连接的最少对象的数目，而m则为最多对象数（当不知道确切的最大数时，最大数用<em>号表示）。最常见的多重性有0…1、0…</em>、1…1和1…*。</p>
</blockquote>

        <h3 id="5mccabe度量法">
          <a href="#5mccabe度量法" class="heading-link"><i class="fas fa-link"></i></a>5.McCabe度量法</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220151.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>​	本题考查McCabe度量法。McCabe度量法是通过定义<strong>环路复杂度</strong>，建立程序复杂性的度量，它基于一个程序模块的程序图中环路的个数。</p>
<p>画图法 》 E 、G 自环  （C D E F  环） （ B C E F 环） 添一条起点 终点环  》环数 5</p>
<p>计算有向图G的环路复杂性的公式为V(G)=m-n+2，</p>
<p>其中V(G)是有向图G中的环路个数，m是G中的<strong>有向弧数</strong>（两节点之间的连线），n是G中的节点数。要采用McCabe度量法度量程序复杂度，需要先画出程序图，识别有向图中节点数n=7和有向弧数m=10，然后利用环路复杂性计算公式V(G)=m-n+2进行计算，得到图中程序图的程序复杂度是5。</p>
</blockquote>

        <h3 id="6软件过程改进">
          <a href="#6软件过程改进" class="heading-link"><i class="fas fa-link"></i></a>6.软件过程改进</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220740.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>《软件设计师教程（第5版）》P247页：</p>
<ul>
<li>CL0（未完成的）：过程域未执行或未得到CL1中定义的所有目标。<br></li>
<li>CL1（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。<br></li>
<li>CL2（已管理的）：其共性目标是集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制、和评审。<br></li>
<li>CL3（已定义级的）：其共性目标集中于已定义的过程的制度化。过程是按照组织的裁剪指南从组织的标准过程中裁剪得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。<br></li>
<li>CL4（定量管理的）：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的质量目标作为管理准则。<br></li>
<li>CL5（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户的改变和持续改进计划中的过程域的功效。<br></li>
</ul>
</blockquote>

        <h4 id="3cmmi-知识引申">
          <a href="#3cmmi-知识引申" class="heading-link"><i class="fas fa-link"></i></a>3.CMMI 知识引申</h4>
      
<blockquote>
<p>CMMI的全称为Capability Maturity Model Integration，即能力成熟度模型集成。CMMI是CMM模型的最新版本。早期的CMMI（CMMI-SE/SW/IPPD），SEI在部分国家和地区开始推广和试用。随着应用的推广与模型本身的发展，演绎成为一种被广泛应用的综合性模型。 [1]</p>
<p><strong>级别</strong></p>
<ul>
<li>CMMI共有5个级别，代表软件团队能力成熟度的5个等级，数字越大，成熟度越高，高成熟度等级表示有比较强的软件综合开发能力。</li>
<li>CMMI一级，执行级。在执行级水平上，软件组织对项目的目标与要做的努力很清晰，项目的目标可以实现。但是由于任务的完成带有很大的偶然性，软件组织无法保证在实施同类项目时仍然能够完成任务。项目实施能否成功主要取决于实施人员。</li>
<li>CMMI二级，管理级。在管理级水平上，所有第一级的要求都已经达到，另外，软件组织在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对项目相关的实施人员进行了相应的培训，对整个流程进行监测与控制，并联合上级单位对项目与流程进行审查。二级水平的软件组织对项目有一系列管理程序，避免了软件组织完成任务的随机性，保证了软件组织实施项目的成功率。</li>
<li>CMMl三级，明确级。在明确级水平上，所有第二级的要求都已经达到，另外，软件组织能够根据自身的特殊情况及自己的标准流程，将这套管理体系与流程予以制度化。这样，软件组织不仅能够在同类项目上成功，也可以在其他项目上成功。科学管理成为软件组织的一种文化，成为软件组织的财富。</li>
<li>CMMI四级，量化级。在量化管理级水平上，所有第三级的要求都已经达到，另外，软件组织的项目管理实现了数字化。通过数字化技术来实现流程的稳定性，实现管理的精度，降低项目实施在质量上的波动。</li>
<li>CMMI五级，优化级。在优化级水平上，所有第四级的要求都已经达到，另外，软件组织能够充分利用信息资料，对软件组织在项目实施的过程中可能出现的次品予以预防。能够主动地改善流程，运用新技术，实现流程的优化。</li>
</ul>
<p>由上述的5个级别可以看出，每一个级别都是更高一级的基石。要上高层台阶必须首先踏上所有下层的台阶</p>
<p><strong>作用</strong></p>
<p>很多软件企业纷纷实施CMMI管理模式，不少企业如：东软、托普、华为等企业通过了三级或四级评估。这一方面反映了我国企业在进入WTO后的危机意识，以及与世界接轨的迫切愿望。另一方面则反映出我国软件企业在改进管理方法上所作的努力。但是CM-MI到底能够为我们做什么呢？实际上这个问题对不同的人有不同的答案。对采购部门的人员来说，掌握了CMMI技术可以有目的地考察项目实施人员或公司的实施能力，从而保证所采购的项目能够顺利完成。对于项目经理来说，掌握CMMl技术能够提高自己的项目管理能力，从而能够使项目高质量、低成本、按期限地完成。对于企业领导人来说，CMMI技术不仅能够提升企业的管理水平，还能够引入科学的管理理念，提升企业的整体管理水平。</p>
<p>在美国，很多企业通过CMMI评估一方面为了满足承包国防工程或一些大企业的工程的要求，另一方面也是为了提高企业自身的管理能力。美国政府的工程项目，绝大多数都要求承包商具有一定的CMMI级别作为参加投标的资格。越来越多的大型企业业开始要求其工程承包商具有一定的CMMl级别。级别高的企业在赢得项目的竞标中具有一定的优势。因此，如果没有CMMI的等级评估，企业就会失去很多商机</p>
<p><strong>应用</strong></p>
<p>CMMI是一个庞大的过程元模型，自发布以来在世界软件界产生了巨大的影响。CMMI等级评估已经成为业界公认的标准，CMMI的证书成了一个企业或组织能力和形象的标志，没有这个证书不仅难以获得国外项目，甚至也难以在国内一些项目的竞标中获胜。CMMI适合企业操作，避免了某些管理体系只重理论而忽视实践的缺陷。在我国，随着媒体的宣传和政府的支持，许多企业引入了CMMI咨询和认证，对于整个软件行业的管理提升及研发效率提高起到了很大的帮助作用。但也有一些企业引入CMMI体系后，只留下一些形式上的开发流程和文档模板，在管理上并无实质性改进。对于CMMI，业界一直存在着两种声音，有人认为CMMI执行过度，得不偿失；也有人说它过于通用，实用价值不大；但多数人还是认同它，并根据需要加以应用。 [3]</p>
</blockquote>

        <h3 id="7后缀表达式">
          <a href="#7后缀表达式" class="heading-link"><i class="fas fa-link"></i></a>7.后缀表达式</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325221240.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>后缀表示也称为表达式的逆波兰表示。在这种表示方法中，将运算符号写在运算对象的后面，表达式中的运算符号按照计算次序书写。</p>
<p>对于表达式x-(y+c)<em>8，先计算y与c的和，再乘以8，最后用x减去这个这个计算，因此其后缀式为xyc+8</em>-。</p>
</blockquote>

        <h3 id="8编译与解析">
          <a href="#8编译与解析" class="heading-link"><i class="fas fa-link"></i></a>8.编译与解析</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325221347.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>对C源程序进行编译时，</p>
<ol>
<li>需建立符号表，其作用是记录源程序中各个符号（变量等）的必要信息，</li>
<li>以辅助语义的正确性检查和代码生成，</li>
<li>在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。</li>
<li>符号表的建立可以始于<strong>词法分析阶段</strong>，也可以放到<strong>语法分析和语义分析阶段</strong>，但符号表的使用有时会延续到目标代码的运行阶段。</li>
</ol>
</blockquote>
<h4 id><a class="markdownIt-Anchor" href="#"></a> </h4>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/23/后缀表达式算法/">后缀表达式算法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1概念解析">
          <a href="#1概念解析" class="heading-link"><i class="fas fa-link"></i></a>1.概念解析</h3>
      
<p>​	实现逆波兰式的算法，难度并不大，但为什么要将看似简单的中序<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>转换为复杂的逆波兰式？原因就在于这个简单是相对人类的思维结构来说的，对计算机而言中序表达式是非常复杂的结构。相对的，逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的内存结构是栈式结构，它执行先进后出的顺序。</p>

        <h3 id="2实现算法">
          <a href="#2实现算法" class="heading-link"><i class="fas fa-link"></i></a>2.实现算法</h3>
      
<p>1.算法一</p>
<blockquote>
<ol>
<li>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</li>
<li>从左至右扫描中缀表达式；</li>
<li>遇到操作数时，将其压s2；</li>
<li>遇到运算符时，比较其与s1栈顶运算符的优先级：<br>
1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；<br>
2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；<br>
3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</li>
<li>遇到括号时：(1) 如果是左括号“(”，则直接压入s1(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
<li>重复步骤2至5，直到表达式的最右边</li>
<li>将s1中剩余的运算符依次弹出并压入s2</li>
<li>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</li>
</ol>
</blockquote>
<p>2.算法2</p>
<blockquote>
<p>将一个普通的中序<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>转换为<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">逆波兰表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的一般算法是：</p>
<p>首先需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：</p>
<p>（1）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0" target="_blank" rel="noopener">操作数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则分析出完整的运算数，该操作数直接送入S2栈</p>
<p>（2）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener">运算符</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则将该运算符与S1栈栈顶元素比较，如果该<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noopener">运算符优先级</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>(不包括括号运算符)大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，最后将该运算符送入S1栈。</p>
<p>（3）若取出的字符是“（”，则直接送入S1栈顶。</p>
<p>（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88" target="_blank" rel="noopener">出栈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，依次送入S2栈，此时抛弃“（”。</p>
<p>（5）重复上面的1~4步，直至处理完所有的输入字符</p>
<p>（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。</p>
<p>完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算了！</p>
</blockquote>

        <h3 id="3java-代码实现">
          <a href="#3java-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.Java 代码实现</h3>
      
<pre><code>	package DataStructures.Stack;

    import java.util.Stack;

    /**
     * @author yichangkong
     * @create 2020-03-21-22:47
     * 中缀表达式转后缀表达式
     */
    public class PolandNotaion {

        public static void main(String[] args) {

            //初始化两栈 S1 S2
            Stack&lt;String&gt; operatStack = new Stack();//；零时存取运算符
            Stack&lt;String&gt; polanStack = new Stack();//逆波兰表达式


            //测试案例
            String expersstion = "1 + ( ( 2 + 3 ) * 4 ) - 5";

            String[] arrayStr = expersstion.split(" ");//转换为字符串数组进行从左至右遍历扫描

            int size = arrayStr.length;//11

            System.out.println(size);

            boolean flag = true;


            for (int index = 0; index &lt; size; index++) {

                String str = arrayStr[index];

                //遇到操作数
                if (isNum(str)) {

                    polanStack.push(str);

                } else {//如果是操作符
                    if (operatorLevel(str) == 1) {
                        //(1) 如果是左括号“(”，则直接压入s1
                        if (str.equals("(")) {
                            operatStack.push(str);
                        } else {
                            //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                            boolean f1 = true;
                            while (f1) {

                                String s = operatStack.peek();
                                if (s.equals("(")) {
                                    operatStack.pop();
                                    f1 = false;
                                } else {
                                    polanStack.push(operatStack.pop());
                                }
                            }
                        }
                    } else {
                        flag = true;
                        while (flag) {
                            if (operatStack.size() == 0 || operatStack.peek().equals("(")) {//如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈
                                //直接入S1
                                operatStack.push(str);
                                flag = false;
                            } else {
                                int L1 = operatorLevel(str);
                                int L2 = operatorLevel(operatStack.peek());
                                //2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；
                                if (L1 &lt; L2) {
                                    operatStack.push(str);

                                    System.out.println("L!");
                                    flag = false;
                                } else { //3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较
                                    polanStack.push(operatStack.pop());
                                }
                            }
                        }
                    }
                }
            }

            while (operatStack.size() != 0) {
                polanStack.push(operatStack.pop());
            }
            System.out.println(polanStack);
        }


        //判断方法 检验输入的符号是否为数
        static public boolean isNum(String string) {

            if (operatorLevel(string) &gt; 4) {

                int num = Integer.parseInt(string);

                if (num &lt;= 9 || num &gt;= 0) {
                    return true;//是数字
                }
            }
            return false;//符号

        }


        //优先级 运算符 1 &gt; 2 &gt; 3 &gt;4
        static public int operatorLevel(String string) {

            switch (string) {
                case "(":
                    return 1;
                case ")":
                    return 1;

                case "+":
                    return 3;
                case "-":
                    return 3;
                case "*":
                    return 2;
                case "/":
                    return 2;
                case "#":
                    return 4;
                default:
                    return 5;
            }

        }
    }
</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/23/2020年02月10日软件设计师每日一练/">2020年02月10日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">17分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1软件的可维护性">
          <a href="#1软件的可维护性" class="heading-link"><i class="fas fa-link"></i></a>1.软件的可维护性</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210023.png" alt></p>
<p>2.题目解析</p>
<p>本题考查系统的可维护性评价指标。系统的可维护性可以定性地定义为:维护人员理解、改正、改动和改进这个软件的难易程度，其评价指标包括可<code>理解性</code>、<code>可测试性</code>和<code>可修改性</code>。</p>

        <h3 id="2数据的表示">
          <a href="#2数据的表示" class="heading-link"><i class="fas fa-link"></i></a>2…数据的表示</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210127.png" alt></p>
<p>2.题目解析</p>
<p>答案 D</p>
<p>在计算机中，n位补码（表示数据位），表示范围是-2<sup>n-1</sup>~+2<sup>n-1</sup>-1，其中最小值为人为定义，以n=8为例，其中-128的补码是人为定义的1000 0000。<br></p>

        <h3 id="3常用命令">
          <a href="#3常用命令" class="heading-link"><i class="fas fa-link"></i></a>3.常用命令</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210258.png" alt></p>
<p>2.题目解析</p>
<p>ipconfig/all能为DNS和WINS服务器显示它已配置且所要使用的附加信息（如IP地址等），并且显示内置于本地网卡中的物理地址。<br><br>
ipconfig/release也只能在向DHCP服务器租用其IP地址的计算机上起作用。如果你输入ipconfig /release，那么所有接口的租用IP地址便重新交付给DHCP服务器。<br><br>
/reset和/reload为干扰项，ipconfig不支持这两个参数。<br></p>

        <h3 id="4保护范围和对象">
          <a href="#4保护范围和对象" class="heading-link"><i class="fas fa-link"></i></a>4.保护范围和对象</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210448.png" alt></p>
<p>2.题目解析</p>
<p>根据我国《著作权法》的规定，有三种类型的作品不受法律保护。 第一种是依法禁止出版、传播的作品。 第二种是不适用于《著作权法》的作品。它们包括下列作品：</p>
<div>
	（1）法律、法规，国家的决议、决定、命令和其他具有立法、行政、司法性质的文件，极其官方正式译文；</div>
<div>
	（2）时事新闻；</div>
<div>
	（3）历法、通用数表、通用表格和公式。</div>
<div>
	国务院颁布的《计算机软件保护条例》属于法律法规，所以不受著作权法保护。</div>

        <h3 id="5软件测试">
          <a href="#5软件测试" class="heading-link"><i class="fas fa-link"></i></a>5.软件测试</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210546.png" alt></p>
<p>2.题目解析</p>
<p>&nbsp;在单元测试开始时，应该对通过所有被测模块的数据流进行测试。<br><br>
①输入参数是否与形式参数是否一致。<br><br>
②调用模块的实参与被调用模块形参是否一致。<br><br>
③全局变量在各模块中的定义和用法是否一致<br><br>
④外部输入、输出等等。</p>

        <h3 id="6软件测试">
          <a href="#6软件测试" class="heading-link"><i class="fas fa-link"></i></a>6.软件测试</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210637.png" alt></p>
<p>2.题目解析</p>
<p>根据等价类划分的原则，如果规定了输入数据的范围，则可划分为1个有效等价类和2个无效等价类。学生年龄的输入范围为16~40，则有效等价类为16≤年龄≤40，两个无效等价类为年龄&gt;40或年龄&lt;16。</p>

        <h3 id="7面向对象的基本概念">
          <a href="#7面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>7.面向对象的基本概念</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210922.png" alt></p>
<p>2.题目解析</p>
<p>面向对象系统中的封装单位是对象，对象之间只能通过接口进行信息交流，对象外部不能对对象中的数据随意地进行访问。封装是一种信息隐藏技术，目的是使对象的定义和实现分离，这样，就能减少耦合，类内部的实现可以自由改变而不会影响其他的类或对象。</p>

        <h3 id="8校验码">
          <a href="#8校验码" class="heading-link"><i class="fas fa-link"></i></a>8.校验码</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211037.png" alt></p>
<p>2.题目解析</p>
<p>采用模二除法运算的只有循环冗余检验CRC。</p>

        <h4 id="3校验方法">
          <a href="#3校验方法" class="heading-link"><i class="fas fa-link"></i></a>3.校验方法</h4>
      
<blockquote>
<p>常用的几种数据校验方式有奇偶校验、CRC校验、LRC校验、格雷码校验、和校验、异或校验等</p>
<p>一、奇偶校验</p>
<ol>
<li>定义</li>
</ol>
<p>根据被传输的一组二进制代码中“1”的个数是奇数或偶数来进行校验。</p>
<p>使用：通常专门设置一个奇偶校验位，存放代码中“1”的个数为奇数还是偶数。若用奇校验，则奇偶校验位为奇数，表示数据正确。若用偶校验，则奇偶校验位为偶数，表示数据正确。</p>
<ol start="2">
<li>应用</li>
</ol>
<p>eg.  数据位为 10001100 （1）  -&gt; 最后一位为校验位</p>
<p>此时若约定好为奇校验，那么数据表示为正确的，若为偶校验，那么数据传输出错了。</p>
<p>二、CRC校验（循环冗余校验码）</p>
<ol>
<li>定义</li>
</ol>
<p>CRC校验是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p>
<ol start="2">
<li>计算过程：<br>
a&gt; 设置CRC寄存器，并给其赋值FFFF(hex)。<br>
b&gt; 将数据的第一个8-bit字符与16位CRC寄存器的低8位进行异或，并把结果存入CRC寄存器。<br>
c&gt; CRC寄存器向右移一位，MSB补零，移出并检查LSB。<br>
d&gt; 如果LSB为0，重复第三步；若LSB为1，CRC寄存器与多项式码相异或。</li>
</ol>
<p>e&gt; 重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。</p>
<p>f&gt; 重复第2至第5步直到所有数据全部处理完成。</p>
<p>g&gt; 最终CRC寄存器的内容即为CRC值。</p>
<p>常用的CRC循环冗余校验标准多项式如下：   CRC(16位) = X16+X15+X2+1   CRC(CCITT) = X16+X12 +X5+1<br>
CRC(32位) = X32+X26+X23+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1<br>
以CRC(16位)多项式为例，其对应校验二进制位列为1 1000 0000 0000 0101。</p>
<ol start="3">
<li>应用：在发送端根据要传送的k位二进制码序列，以一定的规则产生一个校验用的r位监督码(CRC码)，附在原始信息后边，构成一个新的二进制码序列数共k+r位，然后发送出去。在接收端，根据信息码和CRC码之间所遵循的规则进行检验，以确定传送中是否出错。</li>
</ol>
<p>三、LRC校验</p>
<ol>
<li>
<p>定义：LRC校验用于ModBus协定的ASCII模式，这各校验比较简单，通讯速率较慢，它在ASCII协议中使用，检测了消息域中除开始的冒号及结束的回车换行号外的内容。它仅仅是把每一个需要传输的数据字节迭加后取反加1即可。</p>
</li>
<li>
<p>应用</p>
</li>
</ol>
<p>eg. 5个字节：01H+03H+21H+02H+00H+02H = 29H，然后取2的补码=D7H。</p>
<p>四、格雷码校验</p>
<ol>
<li>定义</li>
</ol>
<p>格雷码是一种无权码，也是一种循环码。是指任意两组相邻的代码之间只有一位不同，其余为都相同。</p>
<p>如：5的二进制为0101    6的二进制为0110</p>
<pre><code>    5的格雷码为0111    6的二进制为0101
</code></pre>
<p>五、校验和</p>
<ol>
<li>定义</li>
</ol>
<p>校验一组数据项的和是否正确。通常是以十六进制为数制表示的形式。如果校验和的数值超过十六进制的FF，也就是255。</p>
<ol start="2">
<li>应用</li>
</ol>
<p>eg. 数据01020304的校验和为a。</p>
<p>六、异或校验</p>
<ol>
<li>定义</li>
</ol>
<p>BCC校验其实是奇偶校验的一种，但也是经常使用并且效率较高的一种。所谓BCC校验法，就是在发送前和发送后分别把BCC以前包括ETX字符的所有字符按位异或后，按要求变换(增加或去除一个固定的值)后所得到的字符进行比较。相等即认为通信无错误，不相等则认为通信出错。</p>
<p>七、MD5校验</p>
<ol>
<li>定义</li>
</ol>
<p>MD5的实际应用是对一段Message(字节串)产生fingerprint(指纹)，可以防止被篡改。</p>
</blockquote>

        <h3 id="9网络攻击">
          <a href="#9网络攻击" class="heading-link"><i class="fas fa-link"></i></a>9.网络攻击</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211614.png" alt></p>
<p>2.题目解析</p>
<ol>
<li>
<p>DoS是<code>Denial of Service</code>的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</p>
</li>
<li>
<p>作个形象的比喻来理解DoS。街头的餐馆是为大众提供餐饮服务，如果一群地痞流氓要DoS餐馆的话，手段会很多，比如霸占着餐桌不结账，堵住餐馆的大门不让路，骚扰餐馆的服务员或厨子不能干活，甚至更恶劣……</p>
</li>
<li>
<p>SYN Flooding攻击便是Dos攻击的典型代表，该攻击以多个随机的源主机地址向目的路由器发送SYN包，而在收到目的路由器的SYN ACK后并不回应，这样，目的路由器就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致路由器崩溃。服务器要等待超时（Time Out）才能断开已分配的资源。</p>
</li>
</ol>

        <h3 id="10死锁">
          <a href="#10死锁" class="heading-link"><i class="fas fa-link"></i></a>10.死锁</h3>
      

        <h4 id="1题目-10">
          <a href="#1题目-10" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211851.png" alt></p>
<p>2.题目解析</p>
<p>本题考查对操作系统死锁方面基本知识掌握的程度。系统中同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m&lt;nw时，可能会引起死锁。<br></p>
<ul>
<li>情况a：m=2，n= 1，w=2，系统中有2个资源，1个进程使用，该进程最多要求2个资源，所以不会发生死锁。</li>
<li>情况b：m=2，n=2，w=1，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，所以不会发生死锁。</li>
<li>情况c：m=2，n=2，w=2，系统中有2个资源，2个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁，这时进程资源图如下图所示。<p></p></li>
</ul>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323212021.png" alt></p>
<p>情况d：m=4，n=3，w=2，系统中有4个资源，3个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个资源，此时，系统中还剩1个资源，可以使其中的一个进程得到所需资源运行完毕，所以不会发生死锁。<br>
　　情况e：m=4，n=3，w=3，系统中有4个资源，3个进程使用，每个进程最多要求3个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，第二轮系统先为一个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生列锁，这时进程资源图如下图所示。</p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323212044.png" alt></p>
<p>因此，情况c和e可能会发生死锁。</p>
<p>第二空发分析如下：</p>
<p>对于c情况，若将m加1，则情况c：m=3，n=2，w=2，系统中有3个资源，2个进程使用，每个进程最多要求2个资源，系统先为每个进程分配1个，此时，系统中还剩1个可供分配的资源，使得其中的一个进程能得到所需资源执行完，并释放所有资源使另一个进程运行完；若将w减1，则情况c：m=2，n=2，w=1，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，系统为每个进程分配1个，此时进程都能够运行完成，并释放所有资源，不会发生死锁。对于情况e与c分析同理。</p>
<p>因此，当m加1或w减1时，c和e不会发生死锁。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/22/2020年02月09日软件设计师每日一练/">2020年02月09日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-22</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">8分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1逻辑网络设计">
          <a href="#1逻辑网络设计" class="heading-link"><i class="fas fa-link"></i></a>1.逻辑网络设计</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322205126.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查的是网络系统设计原则，其中答案A不符合其中的实用性原则，</p>
<p>网络方案设计中应把握“<code>够用</code>”和“<code>实用</code>”原则。网络系统应采用成熟可靠的技术和设备，达到实用、经济和有效的目的。答案B不符合可扩展性原则，网络总体设计不仅要考虑到近期目标，也要为网络的进一步发展留有扩展的余地。</p>
<p><code>答案C说法正确</code>，符合开放性原则。答案D不正确，网络需求分析必须依赖于应用系统的需求分析。故答案选C.</p>

        <h3 id="2传值与传址">
          <a href="#2传值与传址" class="heading-link"><i class="fas fa-link"></i></a>2.传值与传址</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322205328.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>答案 C</p>
<p>传值调用最显著的特征就是被调用的函数内部对形参的修改不影响实参的值。引用调用是将实参的地址传递给形参，使得形参的地址就是实参的地址，函数中对形参的修改会导致原实参值的改变，因此可以实现实参与形参之间数据的双向传递。 在传值调用中，实参可以是变量，也可以是常量和表达式，而在传址调用中，实参不能是常量。</p>

        <h3 id="3树与二叉树">
          <a href="#3树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>3.树与二叉树</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210043.png" alt></p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210137.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210225.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210251.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210354.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>&nbsp;&nbsp;&nbsp; 本题考查哈夫曼树。<br><br>
&nbsp;&nbsp;&nbsp; 构造最优二叉树的哈夫曼算法如下。<br><br>
&nbsp;&nbsp;&nbsp; ① 根据给定的n个权值｛w1， w2，…，Wn｝构成n棵二叉树的集合F= {T1.T2，…，Tn}，其中每棵树T;中只有一个带权为w;的根结点，其左右子树均空。<br><br>
&nbsp;&nbsp;&nbsp; ② 在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，置新构造二叉树的根结点的权值为其左、右子树根结点的权值之和。<br><br>
&nbsp;&nbsp;&nbsp; ③从F中删除这两棵树，同时将新得到的二叉树加入到F中。<br><br>
&nbsp;&nbsp;&nbsp; 重复②、③，直到F中只含一棵树时为止。这棵树便是最优二叉树（哈夫曼树）。从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度是从树根到每一个结点的路径长度之和。树的带权路径长度为树中所有叶子结点的带权路径长度之和。<br><br>
&nbsp;&nbsp;&nbsp; 因此，C为最优二叉树，其带权路径长度（12+6）<em>3+15</em>2+23<em>2+29</em>2=188。<br><br>
<img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210849.png" alt></p>

        <h3 id="4多媒体技术概念">
          <a href="#4多媒体技术概念" class="heading-link"><i class="fas fa-link"></i></a>4.多媒体技术概念</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210925.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>通过话筒传入计算机的是我们人类的声音，而这种声音信号是一种连续的<code>模拟信号</code>，而非离散的数字信号，在接收到模拟信号以后，经过采样、量化等工作将模拟信号转换为数字信号在计算机中处理。</p>

        <h3 id="5有限自动机">
          <a href="#5有限自动机" class="heading-link"><i class="fas fa-link"></i></a>5.有限自动机</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211103.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查程序语言方面的基础知识。	　　对于题中自动机的状态图，先忽略状态q0的自环（识别若干个0），从初态q0到终态q1，该自动机可识别的字符串为1、101、10101、…，显然，该自动机识别的0、1串中1不能连续出现。</p>

        <h4 id="3技术引申">
          <a href="#3技术引申" class="heading-link"><i class="fas fa-link"></i></a>3.技术引申</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/lk1822791193/article/details/83343226?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">网址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="6多媒体技术">
          <a href="#6多媒体技术" class="heading-link"><i class="fas fa-link"></i></a>6.多媒体技术</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211258.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查计算机音乐信息处理技术的相关知识。WAV格式记录的是对于音乐信号的波形采样数据，它可以使用反映自然声音的信号采样序列来记录和回放声音信息。MIDI格式记录的是采用音乐信息序列交换的标准格式MIDI （ Musical Instrument Digital interface）标准来存贮和表达音乐的演奏信息，这些演奏信息包含每个音符演奏的时间信息、音量信息、长度信息、乐器或音色信息等，MID工消息序列可以间接反映出音乐的曲谱演奏信息。</p>

        <h3 id="7er模型">
          <a href="#7er模型" class="heading-link"><i class="fas fa-link"></i></a>7.ER模型</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211352.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>
	本题考查的是应试者对数据库系统中E-R模型方面的基础知识。<br>
	根据题意，学生S关系中一个学生属于一个院系，一个院系有多个学生，因此学生S和部门院系D之间是一个一对多的联系，故(a)应为1&nbsp; * ；又因为一个学生可以选择多门课程，一门课程可由多名学生选择，所以学生S和课程C关系之间是一个多对多的联系，故(b)应为* &nbsp;* 。<br>
	假设一对多联系(a)不转换为一个独立的关系模式，那么按照E-R模型向关系模型转换的规则，应当将一端的主键并入多端。所以，生成的关系模式学生S中应加入关系模式D的主键。</p>

        <h3 id="8规范化理论">
          <a href="#8规范化理论" class="heading-link"><i class="fas fa-link"></i></a>8.规范化理论</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211524.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>答案 D B</p>
<p>1、函数依赖关系为的函数依赖集 F={培训科目→→培训师，（学生，培训科目）→成绩，（时间，教室）→培训科目，（时间，培训师）→教室，（时间，学生）→教室}。可以得出，（时间，学生）→教室 →培训科目 →成绩 ，（时间，学生）→教室 →培训科目 →培训师时间和学生共同组合，可以推导出所有的属性，描述出所有的函数依赖关系。 所以主键是时间和学生的组合键。</p>
<p>2、存在传递函数依赖，时间和教室—&gt;培训科目； 培训科目→培训师。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/21/简单算法优化/">简单算法优化</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">52</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/21/2020年02月08日软件设计师每日一练/">2020年02月08日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">2.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">17分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1数据结构">
          <a href="#1数据结构" class="heading-link"><i class="fas fa-link"></i></a>1…数据结构</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321220324.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>在<code>不考虑字对齐规则</code>的情况下，C语言中一个结构体变量的存储区大小就是其所有成员所需存储区大小之和，一个联合体变量的存储区大小就是其各成员所需存储区大小中的<code>最大者</code>。因此题目中给定的联合体union T变量需要的存储区大小就是存储一个double类型变量的大小（即8字节），struct T类型变量的存储区最小应为int类型成员w存储区大小（4字节）与union T类型成员U的存储区大小之和，即12字节。</p>

        <h3 id="2uml">
          <a href="#2uml" class="heading-link"><i class="fas fa-link"></i></a>2.uml</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321220620.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>
	活动图可以更好地描述出行为的细节，阐明了业务用例实现的工作流程。活动图主要由以下一些元素组成：<br>
	（1）初始节点和活动终点。在活动图中有两个特殊的节点，一个用来表示活动的初始节点，它用一个实心圆表示，在一张不包括子图的活动图中有且只有一个初始节点。而另一个则是表示活动处理完成的活动终点，它用一个圆圈内加一个实心圆来表示，在活动图中可能包含多个活动终点。<br>
	（2）活动状态。是活动图中最主要的元素之一，它用来表示一个活动，如图中的a11等。<br>
	（3）转换。当一个活动结束时，控制流就会马上传递给下一个活动状态，在活动图中称之为转换，用一条带箭头的直线来表示，转移表示各种活动状态的先后顺序。<br>
	（4）分支与监护条件。对于任何一个控制流而言，都一定会存在分支、循环等形式的控制流。在活动图中，分支用一个菱形表示，它有一个进入转换（箭头从外指向分支符号），一个或多个离开转换（箭头从分支符号指向外）。而每个离开转换上都会有一个监护条件，用来表示满足什么条件的时候执行该转换。但要注意，在多个离开转换上的监护条件不能有矛盾，否则就会使得流程产生混乱。<br>
	（5）分岔与汇合。在实际的控制流中，除了顺序结构、分支结构和循环结构之外，还可能存在并发的事件流。在UML中，可以采用一个同步线来说明这些并行控制流的分岔和汇合。<br>
	在本题中，要求出那些活动是可以同时执行的，这就要求他们没有先后关系，显然选项A和C不正确，而对于D选项，a66和a77分别是判定条件连个不同结果下要执行的活动，也不是可以同时执行的活动，因此答案选B。</p>

        <h3 id="3软件开发过程基础知识">
          <a href="#3软件开发过程基础知识" class="heading-link"><i class="fas fa-link"></i></a>3.软件开发过程基础知识</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221047.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<ul>
<li>本题考查软件开发过程中的风险分析基础知识。<br>
风险分析包括风险识别、风险预测、风险评估和风险控制等4个不同活动，</li>
<li>​    在风险识别过程中，要识别潜在的预算、进度、个体、资源、用户和需求等方面的问题以及对整个项目的影响，并建立风险条目检查表，列出所有可能的风险事项。</li>
<li>​    在风险预测过程中，需要建立一个表示风险可能性的参考标准，描述风险条目的结果，估计风险对项目的影响等。</li>
</ul>

        <h4 id="3知识引申">
          <a href="#3知识引申" class="heading-link"><i class="fas fa-link"></i></a>3.知识引申</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/zhouzuoluo/article/details/102751168" target="_blank" rel="noopener">软件风险基础知识</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="4进程的状态">
          <a href="#4进程的状态" class="heading-link"><i class="fas fa-link"></i></a>4进程的状态.</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221454.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>​               在多线程运行环境中，每个线程自己独有资源很少，只有：程序计数器，寄存器和栈，其它的资源均是共享进程的，所以也只有这些独有资源是不共享的。答案 C</p>

        <h3 id="5ip地址与子网划分">
          <a href="#5ip地址与子网划分" class="heading-link"><i class="fas fa-link"></i></a>5.IP地址与子网划分</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221646.png" alt></p>

        <h4 id="2题目">
          <a href="#2题目" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>变长子网的可用主机数计算公式为2<sup>n</sup>-2（n为表示主机的位数）/26即主机位为32-26=6，所以可用主机地址为64-2=62。</p>
<p>用IP地址155.32.80.192与子网掩码进行逻辑与运算得出该IP地址所在的网络号为：155.32.80.192；所在网段的广播地址为：155.32.80.255；所以与该IP地址不在同一网段的是选项D</p>

        <h3 id="6文法">
          <a href="#6文法" class="heading-link"><i class="fas fa-link"></i></a>6.文法</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222023.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查程序语言基础知识。<br><br>
　　推导就是从文法的开始符号S出发，反复使用产生式，将产生式左部的非终结符替换为右部的文法符号序列〔展开产生式用功表示），直到产生一个终结符的序列时为止.从文法G的开始符号出发，能推导出的终结符号序列（句子）的全体称为文法G产生的语言。<br><br>
　　对于上下文无关文法S→11 | 1001|S0|SS，从S出发可推导出11，1001， 110， 1111，11110和10010等，将这些二进制序列转换成对应的十进制数可知，它们都能被3整除。</p><p></p>

        <h4 id="3知识引申编译原理文法">
          <a href="#3知识引申编译原理文法" class="heading-link"><i class="fas fa-link"></i></a>3.知识引申(编译原理——文法)</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/Helloyongwei/article/details/79638785" target="_blank" rel="noopener">知识博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="7软件质量保证">
          <a href="#7软件质量保证" class="heading-link"><i class="fas fa-link"></i></a>7.软件质量保证</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222412.png" alt></p>

        <h4 id="2题目-2">
          <a href="#2题目-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>ISO/IEC 9126软件质量模型，该模型的质量特性和质量子特性如下：<br></p>
<ol>
<li>功能性（适合性、准确性、互用性、依从性、安全性）；</li>
<li>可靠性（成熟性、容错性、易恢复性）；</li>
<li>易使用性（易理解性、易学性、易操作性）；</li>
<li>效率（时间特性、资源特性）；</li>
<li>可维护性（易分析性、易改变性、稳定性、易测试性）；</li>
<li>可移植性（适应性、易安装性、一致性、易替换性）。</li>
<li>安全性是功能特性的子特性。</li>
</ol>

        <h3 id="8后缀表达式">
          <a href="#8后缀表达式" class="heading-link"><i class="fas fa-link"></i></a>8.后缀表达式</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222904.png" alt></p>

        <h4 id="2题目-3">
          <a href="#2题目-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>参考答案 D 我是 C</p>
<p>本题考查逻辑表达式的计算及程序语言处理基础知识。<br><br>
&nbsp; “逻辑与运算”的优先级高于“逻辑或运算”。<br><br>
&nbsp; “逻辑与运算”表达式“x∧Y”的短路求值逻辑是：若x为假，则可知“x∧Y”的值为假，无需&nbsp;&nbsp;&nbsp; 再对y求值，因此只有在x为真时继续对y求值。<br><br>
&nbsp; “逻辑或运算”表达式“x∨y”的短路求值逻辑是：若x为真，则可知“x∨y”的值为真，无需再对y求值，因此只有在x为假时继续对y求值。<br><br>
&nbsp;&nbsp;&nbsp; 对于逻辑表达式“a∧b∨c∧（b ∨ x&gt;0）”，从运算符的优先级方面考虑需先对“a∧b”求值，然后对“c∧（b∨ x&gt;0）”求值，最后进行“∨”运算，因此后缀式为“ab∧cbx0&gt;∨∧∨”。</p><p></p>

        <h4 id="3算法实现">
          <a href="#3算法实现" class="heading-link"><i class="fas fa-link"></i></a>3.算法实现</h4>
      
<blockquote>
<p>将一个普通的中序<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>转换为<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">逆波兰表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的一般算法是：</p>
<p>首先需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：</p>
<p>（1）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0" target="_blank" rel="noopener">操作数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则分析出完整的运算数，该操作数直接送入S2栈</p>
<p>（2）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener">运算符</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则将该运算符与S1栈栈顶元素比较，如果该<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noopener">运算符优先级</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>(不包括括号运算符)大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，最后将该运算符送入S1栈。</p>
<p>（3）若取出的字符是“（”，则直接送入S1栈顶。</p>
<p>（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88" target="_blank" rel="noopener">出栈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，依次送入S2栈，此时抛弃“（”。</p>
<p>（5）重复上面的1~4步，直至处理完所有的输入字符</p>
<p>（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。</p>
<p>完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算了！</p>
</blockquote>

        <h3 id="9专业英语">
          <a href="#9专业英语" class="heading-link"><i class="fas fa-link"></i></a>9.专业英语</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p>​	&nbsp; &nbsp; &nbsp; &nbsp;Observe that for the programmer， as for the chef， the urgency of the patron（顾客）may govern the scheduled completion of the task， but it cannot govern the actual completion. An omelette（煎鸡蛋）， promised in two minutes， may appear to be progressing nicely.But when it has not set in two minutes， the customer has two choices—waits or eats it raw.Software customers have had（ &nbsp;）choices.<br></p>
<p>​	　　Now I do not think software（ &nbsp;）have less inherent courage and firmness than chefs， nor than other engineering managers. But false（ &nbsp;）to match the patron’s desired date is much more common in our discipline than elsewhere in engineering. It is very（ &nbsp;）to make a vigorous， plausible， and job risking defense of an estimate that is derived by no quantitative method， supported by little data， and certified chiefly by the hunches of the managers.</p>
<p>​			Clearly two solutions are needed.We need to develop and publicize productivity figures， bug-incidence figures， estimating rules， and so on. The whole profession can only profit from（ &nbsp;）such data.Until estimating is on a sounder basis， individual managers will need to stiffen their backbones and defend their estimates with the assurance that their poor hunches are better than wish derived estimates.</p>

        <h4 id="2题目翻译">
          <a href="#2题目翻译" class="heading-link"><i class="fas fa-link"></i></a>2.题目翻译</h4>
      
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;观察一下编程人员，你可能会发现，同厨师一样，某项任务的计划进度，可能受限于顾客要求的紧迫程度，但紧迫程度无法控制实际的完成情况。就像约好在两分钟内完成一个煎蛋，看上去可能进行得非常好。但当它无法在两分钟内完成时，顾客只能选择等待或者生吃煎蛋。软件顾客的情况类似。<br>
	　　我现在并不认为软件经理内在的勇气和坚持不如厨师，或者不如其他工程经理。但为了满足顾客期望的日期而造成的不合理进度安排，在软件领域中却比其他的任何工程领域要普遍得多。而且，非量化方法的采用，少得可怜的数据支特，加上完全借助软件经理的直觉，这样的方式很难生产出健壮可靠和规避风险的估计。<br>
	　　显然我们需要两种解决方案。开发并推行生产率图表、缺陷率、估算规则等，整个组织最终会从这些数据的共享上获益。或者在基于可靠基础的估算出现之前，项目经理需要挺直腰杆并坚持他们的估计，确信自己的经验和直觉总比从期望得出的估计要强得多。</p>

        <h3 id="10编译与解析">
          <a href="#10编译与解析" class="heading-link"><i class="fas fa-link"></i></a>10.编译与解析</h3>
      

        <h4 id="1题目-10">
          <a href="#1题目-10" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321223914.png" alt></p>

        <h4 id="2题目-4">
          <a href="#2题目-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<ol>
<li>目标代码生成阶段应考虑直接影响到目标代码速度的三个问题：</li>
<li>一是如何生成较短的目标代码；</li>
<li>二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；</li>
<li>三是如何充分利用计算机指令系统的特点，以提高目标代码的质量。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/3/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417183933.png" alt="avatar"></div><p class="sidebar-ov-author__text">繁华落尽一场空：风往尘香花已尽</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YichangKong" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/yichangkong" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-git"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/yichangkong" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">71</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">21</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Liu Jun</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v3.9.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zindex="-1"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script></body></html>