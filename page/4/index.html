<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="360-site-verification" content="85f7e8dc96dcd0b1a29c6f1cc30c4a73"><meta name="description" content="爱了">
<meta name="keywords" content="yichangkong 博客 技术 java spring">
<meta property="og:type" content="website">
<meta property="og:title" content="YiChangKong">
<meta property="og:url" content="https://yichangkong.github.io/page/4/index.html">
<meta property="og:site_name" content="YiChangKong">
<meta property="og:description" content="爱了">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YiChangKong">
<meta name="twitter:description" content="爱了"><meta name="keywords" content="Liu Jun, YiChangKong"><meta name="description" content="爱了"><title>YiChangKong</title><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/5.13.0/css/all.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">个人</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/Test/"><span class="header-nav-submenu-item__text">日常</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/About/"><span class="header-nav-submenu-item__icon"><i class="far fa-about"></i></span><span class="header-nav-submenu-item__text">关于</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/Poetry/"><span class="header-nav-submenu-item__text">诗歌</span></a></div></div></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">YiChangKong</div><div class="header-banner-info__subtitle">Coding is my life, But not all!</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/23/2020年02月10日软件设计师每日一练/">2020年02月10日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">17分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/23/2020年02月10日软件设计师每日一练/" data-flag-title="2020年02月10日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1软件的可维护性">
          <a href="#1软件的可维护性" class="heading-link"><i class="fas fa-link"></i></a>1.软件的可维护性</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210023.png" alt></p>
<p>2.题目解析</p>
<p>本题考查系统的可维护性评价指标。系统的可维护性可以定性地定义为:维护人员理解、改正、改动和改进这个软件的难易程度，其评价指标包括可<code>理解性</code>、<code>可测试性</code>和<code>可修改性</code>。</p>

        <h3 id="2数据的表示">
          <a href="#2数据的表示" class="heading-link"><i class="fas fa-link"></i></a>2…数据的表示</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210127.png" alt></p>
<p>2.题目解析</p>
<p>答案 D</p>
<p>在计算机中，n位补码（表示数据位），表示范围是-2<sup>n-1</sup>~+2<sup>n-1</sup>-1，其中最小值为人为定义，以n=8为例，其中-128的补码是人为定义的1000 0000。<br></p>

        <h3 id="3常用命令">
          <a href="#3常用命令" class="heading-link"><i class="fas fa-link"></i></a>3.常用命令</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210258.png" alt></p>
<p>2.题目解析</p>
<p>ipconfig/all能为DNS和WINS服务器显示它已配置且所要使用的附加信息（如IP地址等），并且显示内置于本地网卡中的物理地址。<br><br>
ipconfig/release也只能在向DHCP服务器租用其IP地址的计算机上起作用。如果你输入ipconfig /release，那么所有接口的租用IP地址便重新交付给DHCP服务器。<br><br>
/reset和/reload为干扰项，ipconfig不支持这两个参数。<br></p>

        <h3 id="4保护范围和对象">
          <a href="#4保护范围和对象" class="heading-link"><i class="fas fa-link"></i></a>4.保护范围和对象</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210448.png" alt></p>
<p>2.题目解析</p>
<p>根据我国《著作权法》的规定，有三种类型的作品不受法律保护。 第一种是依法禁止出版、传播的作品。 第二种是不适用于《著作权法》的作品。它们包括下列作品：</p>
<div>
	（1）法律、法规，国家的决议、决定、命令和其他具有立法、行政、司法性质的文件，极其官方正式译文；</div>
<div>
	（2）时事新闻；</div>
<div>
	（3）历法、通用数表、通用表格和公式。</div>
<div>
	国务院颁布的《计算机软件保护条例》属于法律法规，所以不受著作权法保护。</div>

        <h3 id="5软件测试">
          <a href="#5软件测试" class="heading-link"><i class="fas fa-link"></i></a>5.软件测试</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210546.png" alt></p>
<p>2.题目解析</p>
<p>&nbsp;在单元测试开始时，应该对通过所有被测模块的数据流进行测试。<br><br>
①输入参数是否与形式参数是否一致。<br><br>
②调用模块的实参与被调用模块形参是否一致。<br><br>
③全局变量在各模块中的定义和用法是否一致<br><br>
④外部输入、输出等等。</p>

        <h3 id="6软件测试">
          <a href="#6软件测试" class="heading-link"><i class="fas fa-link"></i></a>6.软件测试</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210637.png" alt></p>
<p>2.题目解析</p>
<p>根据等价类划分的原则，如果规定了输入数据的范围，则可划分为1个有效等价类和2个无效等价类。学生年龄的输入范围为16~40，则有效等价类为16≤年龄≤40，两个无效等价类为年龄&gt;40或年龄&lt;16。</p>

        <h3 id="7面向对象的基本概念">
          <a href="#7面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>7.面向对象的基本概念</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210922.png" alt></p>
<p>2.题目解析</p>
<p>面向对象系统中的封装单位是对象，对象之间只能通过接口进行信息交流，对象外部不能对对象中的数据随意地进行访问。封装是一种信息隐藏技术，目的是使对象的定义和实现分离，这样，就能减少耦合，类内部的实现可以自由改变而不会影响其他的类或对象。</p>

        <h3 id="8校验码">
          <a href="#8校验码" class="heading-link"><i class="fas fa-link"></i></a>8.校验码</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211037.png" alt></p>
<p>2.题目解析</p>
<p>采用模二除法运算的只有循环冗余检验CRC。</p>

        <h4 id="3校验方法">
          <a href="#3校验方法" class="heading-link"><i class="fas fa-link"></i></a>3.校验方法</h4>
      
<blockquote>
<p>常用的几种数据校验方式有奇偶校验、CRC校验、LRC校验、格雷码校验、和校验、异或校验等</p>
<p>一、奇偶校验</p>
<ol>
<li>定义</li>
</ol>
<p>根据被传输的一组二进制代码中“1”的个数是奇数或偶数来进行校验。</p>
<p>使用：通常专门设置一个奇偶校验位，存放代码中“1”的个数为奇数还是偶数。若用奇校验，则奇偶校验位为奇数，表示数据正确。若用偶校验，则奇偶校验位为偶数，表示数据正确。</p>
<ol start="2">
<li>应用</li>
</ol>
<p>eg.  数据位为 10001100 （1）  -&gt; 最后一位为校验位</p>
<p>此时若约定好为奇校验，那么数据表示为正确的，若为偶校验，那么数据传输出错了。</p>
<p>二、CRC校验（循环冗余校验码）</p>
<ol>
<li>定义</li>
</ol>
<p>CRC校验是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p>
<ol start="2">
<li>计算过程：<br>
a&gt; 设置CRC寄存器，并给其赋值FFFF(hex)。<br>
b&gt; 将数据的第一个8-bit字符与16位CRC寄存器的低8位进行异或，并把结果存入CRC寄存器。<br>
c&gt; CRC寄存器向右移一位，MSB补零，移出并检查LSB。<br>
d&gt; 如果LSB为0，重复第三步；若LSB为1，CRC寄存器与多项式码相异或。</li>
</ol>
<p>e&gt; 重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。</p>
<p>f&gt; 重复第2至第5步直到所有数据全部处理完成。</p>
<p>g&gt; 最终CRC寄存器的内容即为CRC值。</p>
<p>常用的CRC循环冗余校验标准多项式如下：   CRC(16位) = X16+X15+X2+1   CRC(CCITT) = X16+X12 +X5+1<br>
CRC(32位) = X32+X26+X23+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1<br>
以CRC(16位)多项式为例，其对应校验二进制位列为1 1000 0000 0000 0101。</p>
<ol start="3">
<li>应用：在发送端根据要传送的k位二进制码序列，以一定的规则产生一个校验用的r位监督码(CRC码)，附在原始信息后边，构成一个新的二进制码序列数共k+r位，然后发送出去。在接收端，根据信息码和CRC码之间所遵循的规则进行检验，以确定传送中是否出错。</li>
</ol>
<p>三、LRC校验</p>
<ol>
<li>
<p>定义：LRC校验用于ModBus协定的ASCII模式，这各校验比较简单，通讯速率较慢，它在ASCII协议中使用，检测了消息域中除开始的冒号及结束的回车换行号外的内容。它仅仅是把每一个需要传输的数据字节迭加后取反加1即可。</p>
</li>
<li>
<p>应用</p>
</li>
</ol>
<p>eg. 5个字节：01H+03H+21H+02H+00H+02H = 29H，然后取2的补码=D7H。</p>
<p>四、格雷码校验</p>
<ol>
<li>定义</li>
</ol>
<p>格雷码是一种无权码，也是一种循环码。是指任意两组相邻的代码之间只有一位不同，其余为都相同。</p>
<p>如：5的二进制为0101    6的二进制为0110</p>
<pre><code>    5的格雷码为0111    6的二进制为0101
</code></pre>
<p>五、校验和</p>
<ol>
<li>定义</li>
</ol>
<p>校验一组数据项的和是否正确。通常是以十六进制为数制表示的形式。如果校验和的数值超过十六进制的FF，也就是255。</p>
<ol start="2">
<li>应用</li>
</ol>
<p>eg. 数据01020304的校验和为a。</p>
<p>六、异或校验</p>
<ol>
<li>定义</li>
</ol>
<p>BCC校验其实是奇偶校验的一种，但也是经常使用并且效率较高的一种。所谓BCC校验法，就是在发送前和发送后分别把BCC以前包括ETX字符的所有字符按位异或后，按要求变换(增加或去除一个固定的值)后所得到的字符进行比较。相等即认为通信无错误，不相等则认为通信出错。</p>
<p>七、MD5校验</p>
<ol>
<li>定义</li>
</ol>
<p>MD5的实际应用是对一段Message(字节串)产生fingerprint(指纹)，可以防止被篡改。</p>
</blockquote>

        <h3 id="9网络攻击">
          <a href="#9网络攻击" class="heading-link"><i class="fas fa-link"></i></a>9.网络攻击</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211614.png" alt></p>
<p>2.题目解析</p>
<ol>
<li>
<p>DoS是<code>Denial of Service</code>的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</p>
</li>
<li>
<p>作个形象的比喻来理解DoS。街头的餐馆是为大众提供餐饮服务，如果一群地痞流氓要DoS餐馆的话，手段会很多，比如霸占着餐桌不结账，堵住餐馆的大门不让路，骚扰餐馆的服务员或厨子不能干活，甚至更恶劣……</p>
</li>
<li>
<p>SYN Flooding攻击便是Dos攻击的典型代表，该攻击以多个随机的源主机地址向目的路由器发送SYN包，而在收到目的路由器的SYN ACK后并不回应，这样，目的路由器就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致路由器崩溃。服务器要等待超时（Time Out）才能断开已分配的资源。</p>
</li>
</ol>

        <h3 id="10死锁">
          <a href="#10死锁" class="heading-link"><i class="fas fa-link"></i></a>10.死锁</h3>
      

        <h4 id="1题目-10">
          <a href="#1题目-10" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211851.png" alt></p>
<p>2.题目解析</p>
<p>本题考查对操作系统死锁方面基本知识掌握的程度。系统中同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m&lt;nw时，可能会引起死锁。<br></p>
<ul>
<li>情况a：m=2，n= 1，w=2，系统中有2个资源，1个进程使用，该进程最多要求2个资源，所以不会发生死锁。</li>
<li>情况b：m=2，n=2，w=1，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，所以不会发生死锁。</li>
<li>情况c：m=2，n=2，w=2，系统中有2个资源，2个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁，这时进程资源图如下图所示。<p></p></li>
</ul>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323212021.png" alt></p>
<p>情况d：m=4，n=3，w=2，系统中有4个资源，3个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个资源，此时，系统中还剩1个资源，可以使其中的一个进程得到所需资源运行完毕，所以不会发生死锁。<br>
　　情况e：m=4，n=3，w=3，系统中有4个资源，3个进程使用，每个进程最多要求3个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，第二轮系统先为一个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生列锁，这时进程资源图如下图所示。</p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323212044.png" alt></p>
<p>因此，情况c和e可能会发生死锁。</p>
<p>第二空发分析如下：</p>
<p>对于c情况，若将m加1，则情况c：m=3，n=2，w=2，系统中有3个资源，2个进程使用，每个进程最多要求2个资源，系统先为每个进程分配1个，此时，系统中还剩1个可供分配的资源，使得其中的一个进程能得到所需资源执行完，并释放所有资源使另一个进程运行完；若将w减1，则情况c：m=2，n=2，w=1，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，系统为每个进程分配1个，此时进程都能够运行完成，并释放所有资源，不会发生死锁。对于情况e与c分析同理。</p>
<p>因此，当m加1或w减1时，c和e不会发生死锁。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/22/2020年02月09日软件设计师每日一练/">2020年02月09日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-22</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">8分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/22/2020年02月09日软件设计师每日一练/" data-flag-title="2020年02月09日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1逻辑网络设计">
          <a href="#1逻辑网络设计" class="heading-link"><i class="fas fa-link"></i></a>1.逻辑网络设计</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322205126.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查的是网络系统设计原则，其中答案A不符合其中的实用性原则，</p>
<p>网络方案设计中应把握“<code>够用</code>”和“<code>实用</code>”原则。网络系统应采用成熟可靠的技术和设备，达到实用、经济和有效的目的。答案B不符合可扩展性原则，网络总体设计不仅要考虑到近期目标，也要为网络的进一步发展留有扩展的余地。</p>
<p><code>答案C说法正确</code>，符合开放性原则。答案D不正确，网络需求分析必须依赖于应用系统的需求分析。故答案选C.</p>

        <h3 id="2传值与传址">
          <a href="#2传值与传址" class="heading-link"><i class="fas fa-link"></i></a>2.传值与传址</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322205328.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>答案 C</p>
<p>传值调用最显著的特征就是被调用的函数内部对形参的修改不影响实参的值。引用调用是将实参的地址传递给形参，使得形参的地址就是实参的地址，函数中对形参的修改会导致原实参值的改变，因此可以实现实参与形参之间数据的双向传递。 在传值调用中，实参可以是变量，也可以是常量和表达式，而在传址调用中，实参不能是常量。</p>

        <h3 id="3树与二叉树">
          <a href="#3树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>3.树与二叉树</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210043.png" alt></p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210137.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210225.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210251.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210354.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>&nbsp;&nbsp;&nbsp; 本题考查哈夫曼树。<br><br>
&nbsp;&nbsp;&nbsp; 构造最优二叉树的哈夫曼算法如下。<br><br>
&nbsp;&nbsp;&nbsp; ① 根据给定的n个权值｛w1， w2，…，Wn｝构成n棵二叉树的集合F= {T1.T2，…，Tn}，其中每棵树T;中只有一个带权为w;的根结点，其左右子树均空。<br><br>
&nbsp;&nbsp;&nbsp; ② 在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，置新构造二叉树的根结点的权值为其左、右子树根结点的权值之和。<br><br>
&nbsp;&nbsp;&nbsp; ③从F中删除这两棵树，同时将新得到的二叉树加入到F中。<br><br>
&nbsp;&nbsp;&nbsp; 重复②、③，直到F中只含一棵树时为止。这棵树便是最优二叉树（哈夫曼树）。从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度是从树根到每一个结点的路径长度之和。树的带权路径长度为树中所有叶子结点的带权路径长度之和。<br><br>
&nbsp;&nbsp;&nbsp; 因此，C为最优二叉树，其带权路径长度（12+6）<em>3+15</em>2+23<em>2+29</em>2=188。<br><br>
<img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210849.png" alt></p>

        <h3 id="4多媒体技术概念">
          <a href="#4多媒体技术概念" class="heading-link"><i class="fas fa-link"></i></a>4.多媒体技术概念</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210925.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>通过话筒传入计算机的是我们人类的声音，而这种声音信号是一种连续的<code>模拟信号</code>，而非离散的数字信号，在接收到模拟信号以后，经过采样、量化等工作将模拟信号转换为数字信号在计算机中处理。</p>

        <h3 id="5有限自动机">
          <a href="#5有限自动机" class="heading-link"><i class="fas fa-link"></i></a>5.有限自动机</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211103.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查程序语言方面的基础知识。	　　对于题中自动机的状态图，先忽略状态q0的自环（识别若干个0），从初态q0到终态q1，该自动机可识别的字符串为1、101、10101、…，显然，该自动机识别的0、1串中1不能连续出现。</p>

        <h4 id="3技术引申">
          <a href="#3技术引申" class="heading-link"><i class="fas fa-link"></i></a>3.技术引申</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/lk1822791193/article/details/83343226?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">网址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="6多媒体技术">
          <a href="#6多媒体技术" class="heading-link"><i class="fas fa-link"></i></a>6.多媒体技术</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211258.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查计算机音乐信息处理技术的相关知识。WAV格式记录的是对于音乐信号的波形采样数据，它可以使用反映自然声音的信号采样序列来记录和回放声音信息。MIDI格式记录的是采用音乐信息序列交换的标准格式MIDI （ Musical Instrument Digital interface）标准来存贮和表达音乐的演奏信息，这些演奏信息包含每个音符演奏的时间信息、音量信息、长度信息、乐器或音色信息等，MID工消息序列可以间接反映出音乐的曲谱演奏信息。</p>

        <h3 id="7er模型">
          <a href="#7er模型" class="heading-link"><i class="fas fa-link"></i></a>7.ER模型</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211352.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>
	本题考查的是应试者对数据库系统中E-R模型方面的基础知识。<br>
	根据题意，学生S关系中一个学生属于一个院系，一个院系有多个学生，因此学生S和部门院系D之间是一个一对多的联系，故(a)应为1&nbsp; * ；又因为一个学生可以选择多门课程，一门课程可由多名学生选择，所以学生S和课程C关系之间是一个多对多的联系，故(b)应为* &nbsp;* 。<br>
	假设一对多联系(a)不转换为一个独立的关系模式，那么按照E-R模型向关系模型转换的规则，应当将一端的主键并入多端。所以，生成的关系模式学生S中应加入关系模式D的主键。</p>

        <h3 id="8规范化理论">
          <a href="#8规范化理论" class="heading-link"><i class="fas fa-link"></i></a>8.规范化理论</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211524.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>答案 D B</p>
<p>1、函数依赖关系为的函数依赖集 F={培训科目→→培训师，（学生，培训科目）→成绩，（时间，教室）→培训科目，（时间，培训师）→教室，（时间，学生）→教室}。可以得出，（时间，学生）→教室 →培训科目 →成绩 ，（时间，学生）→教室 →培训科目 →培训师时间和学生共同组合，可以推导出所有的属性，描述出所有的函数依赖关系。 所以主键是时间和学生的组合键。</p>
<p>2、存在传递函数依赖，时间和教室—&gt;培训科目； 培训科目→培训师。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/21/简单算法优化/">简单算法优化</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">52</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">1分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/21/简单算法优化/" data-flag-title="简单算法优化"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/21/2020年02月08日软件设计师每日一练/">2020年02月08日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">2.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">17分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/21/2020年02月08日软件设计师每日一练/" data-flag-title="2020年02月08日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1数据结构">
          <a href="#1数据结构" class="heading-link"><i class="fas fa-link"></i></a>1…数据结构</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321220324.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>在<code>不考虑字对齐规则</code>的情况下，C语言中一个结构体变量的存储区大小就是其所有成员所需存储区大小之和，一个联合体变量的存储区大小就是其各成员所需存储区大小中的<code>最大者</code>。因此题目中给定的联合体union T变量需要的存储区大小就是存储一个double类型变量的大小（即8字节），struct T类型变量的存储区最小应为int类型成员w存储区大小（4字节）与union T类型成员U的存储区大小之和，即12字节。</p>

        <h3 id="2uml">
          <a href="#2uml" class="heading-link"><i class="fas fa-link"></i></a>2.uml</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321220620.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>
	活动图可以更好地描述出行为的细节，阐明了业务用例实现的工作流程。活动图主要由以下一些元素组成：<br>
	（1）初始节点和活动终点。在活动图中有两个特殊的节点，一个用来表示活动的初始节点，它用一个实心圆表示，在一张不包括子图的活动图中有且只有一个初始节点。而另一个则是表示活动处理完成的活动终点，它用一个圆圈内加一个实心圆来表示，在活动图中可能包含多个活动终点。<br>
	（2）活动状态。是活动图中最主要的元素之一，它用来表示一个活动，如图中的a11等。<br>
	（3）转换。当一个活动结束时，控制流就会马上传递给下一个活动状态，在活动图中称之为转换，用一条带箭头的直线来表示，转移表示各种活动状态的先后顺序。<br>
	（4）分支与监护条件。对于任何一个控制流而言，都一定会存在分支、循环等形式的控制流。在活动图中，分支用一个菱形表示，它有一个进入转换（箭头从外指向分支符号），一个或多个离开转换（箭头从分支符号指向外）。而每个离开转换上都会有一个监护条件，用来表示满足什么条件的时候执行该转换。但要注意，在多个离开转换上的监护条件不能有矛盾，否则就会使得流程产生混乱。<br>
	（5）分岔与汇合。在实际的控制流中，除了顺序结构、分支结构和循环结构之外，还可能存在并发的事件流。在UML中，可以采用一个同步线来说明这些并行控制流的分岔和汇合。<br>
	在本题中，要求出那些活动是可以同时执行的，这就要求他们没有先后关系，显然选项A和C不正确，而对于D选项，a66和a77分别是判定条件连个不同结果下要执行的活动，也不是可以同时执行的活动，因此答案选B。</p>

        <h3 id="3软件开发过程基础知识">
          <a href="#3软件开发过程基础知识" class="heading-link"><i class="fas fa-link"></i></a>3.软件开发过程基础知识</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221047.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<ul>
<li>本题考查软件开发过程中的风险分析基础知识。<br>
风险分析包括风险识别、风险预测、风险评估和风险控制等4个不同活动，</li>
<li>​    在风险识别过程中，要识别潜在的预算、进度、个体、资源、用户和需求等方面的问题以及对整个项目的影响，并建立风险条目检查表，列出所有可能的风险事项。</li>
<li>​    在风险预测过程中，需要建立一个表示风险可能性的参考标准，描述风险条目的结果，估计风险对项目的影响等。</li>
</ul>

        <h4 id="3知识引申">
          <a href="#3知识引申" class="heading-link"><i class="fas fa-link"></i></a>3.知识引申</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/zhouzuoluo/article/details/102751168" target="_blank" rel="noopener">软件风险基础知识</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="4进程的状态">
          <a href="#4进程的状态" class="heading-link"><i class="fas fa-link"></i></a>4进程的状态.</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221454.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>​               在多线程运行环境中，每个线程自己独有资源很少，只有：程序计数器，寄存器和栈，其它的资源均是共享进程的，所以也只有这些独有资源是不共享的。答案 C</p>

        <h3 id="5ip地址与子网划分">
          <a href="#5ip地址与子网划分" class="heading-link"><i class="fas fa-link"></i></a>5.IP地址与子网划分</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221646.png" alt></p>

        <h4 id="2题目">
          <a href="#2题目" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>变长子网的可用主机数计算公式为2<sup>n</sup>-2（n为表示主机的位数）/26即主机位为32-26=6，所以可用主机地址为64-2=62。</p>
<p>用IP地址155.32.80.192与子网掩码进行逻辑与运算得出该IP地址所在的网络号为：155.32.80.192；所在网段的广播地址为：155.32.80.255；所以与该IP地址不在同一网段的是选项D</p>

        <h3 id="6文法">
          <a href="#6文法" class="heading-link"><i class="fas fa-link"></i></a>6.文法</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222023.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查程序语言基础知识。<br><br>
　　推导就是从文法的开始符号S出发，反复使用产生式，将产生式左部的非终结符替换为右部的文法符号序列〔展开产生式用功表示），直到产生一个终结符的序列时为止.从文法G的开始符号出发，能推导出的终结符号序列（句子）的全体称为文法G产生的语言。<br><br>
　　对于上下文无关文法S→11 | 1001|S0|SS，从S出发可推导出11，1001， 110， 1111，11110和10010等，将这些二进制序列转换成对应的十进制数可知，它们都能被3整除。</p><p></p>

        <h4 id="3知识引申编译原理文法">
          <a href="#3知识引申编译原理文法" class="heading-link"><i class="fas fa-link"></i></a>3.知识引申(编译原理——文法)</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/Helloyongwei/article/details/79638785" target="_blank" rel="noopener">知识博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="7软件质量保证">
          <a href="#7软件质量保证" class="heading-link"><i class="fas fa-link"></i></a>7.软件质量保证</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222412.png" alt></p>

        <h4 id="2题目-2">
          <a href="#2题目-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>ISO/IEC 9126软件质量模型，该模型的质量特性和质量子特性如下：<br></p>
<ol>
<li>功能性（适合性、准确性、互用性、依从性、安全性）；</li>
<li>可靠性（成熟性、容错性、易恢复性）；</li>
<li>易使用性（易理解性、易学性、易操作性）；</li>
<li>效率（时间特性、资源特性）；</li>
<li>可维护性（易分析性、易改变性、稳定性、易测试性）；</li>
<li>可移植性（适应性、易安装性、一致性、易替换性）。</li>
<li>安全性是功能特性的子特性。</li>
</ol>

        <h3 id="8后缀表达式">
          <a href="#8后缀表达式" class="heading-link"><i class="fas fa-link"></i></a>8.后缀表达式</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222904.png" alt></p>

        <h4 id="2题目-3">
          <a href="#2题目-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>参考答案 D 我是 C</p>
<p>本题考查逻辑表达式的计算及程序语言处理基础知识。<br><br>
&nbsp; “逻辑与运算”的优先级高于“逻辑或运算”。<br><br>
&nbsp; “逻辑与运算”表达式“x∧Y”的短路求值逻辑是：若x为假，则可知“x∧Y”的值为假，无需&nbsp;&nbsp;&nbsp; 再对y求值，因此只有在x为真时继续对y求值。<br><br>
&nbsp; “逻辑或运算”表达式“x∨y”的短路求值逻辑是：若x为真，则可知“x∨y”的值为真，无需再对y求值，因此只有在x为假时继续对y求值。<br><br>
&nbsp;&nbsp;&nbsp; 对于逻辑表达式“a∧b∨c∧（b ∨ x&gt;0）”，从运算符的优先级方面考虑需先对“a∧b”求值，然后对“c∧（b∨ x&gt;0）”求值，最后进行“∨”运算，因此后缀式为“ab∧cbx0&gt;∨∧∨”。</p><p></p>

        <h4 id="3算法实现">
          <a href="#3算法实现" class="heading-link"><i class="fas fa-link"></i></a>3.算法实现</h4>
      
<blockquote>
<p>将一个普通的中序<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>转换为<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">逆波兰表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的一般算法是：</p>
<p>首先需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：</p>
<p>（1）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0" target="_blank" rel="noopener">操作数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则分析出完整的运算数，该操作数直接送入S2栈</p>
<p>（2）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener">运算符</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则将该运算符与S1栈栈顶元素比较，如果该<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noopener">运算符优先级</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>(不包括括号运算符)大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，最后将该运算符送入S1栈。</p>
<p>（3）若取出的字符是“（”，则直接送入S1栈顶。</p>
<p>（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88" target="_blank" rel="noopener">出栈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，依次送入S2栈，此时抛弃“（”。</p>
<p>（5）重复上面的1~4步，直至处理完所有的输入字符</p>
<p>（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。</p>
<p>完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算了！</p>
</blockquote>

        <h3 id="9专业英语">
          <a href="#9专业英语" class="heading-link"><i class="fas fa-link"></i></a>9.专业英语</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p>​	&nbsp; &nbsp; &nbsp; &nbsp;Observe that for the programmer， as for the chef， the urgency of the patron（顾客）may govern the scheduled completion of the task， but it cannot govern the actual completion. An omelette（煎鸡蛋）， promised in two minutes， may appear to be progressing nicely.But when it has not set in two minutes， the customer has two choices—waits or eats it raw.Software customers have had（ &nbsp;）choices.<br></p>
<p>​	　　Now I do not think software（ &nbsp;）have less inherent courage and firmness than chefs， nor than other engineering managers. But false（ &nbsp;）to match the patron’s desired date is much more common in our discipline than elsewhere in engineering. It is very（ &nbsp;）to make a vigorous， plausible， and job risking defense of an estimate that is derived by no quantitative method， supported by little data， and certified chiefly by the hunches of the managers.</p>
<p>​			Clearly two solutions are needed.We need to develop and publicize productivity figures， bug-incidence figures， estimating rules， and so on. The whole profession can only profit from（ &nbsp;）such data.Until estimating is on a sounder basis， individual managers will need to stiffen their backbones and defend their estimates with the assurance that their poor hunches are better than wish derived estimates.</p>

        <h4 id="2题目翻译">
          <a href="#2题目翻译" class="heading-link"><i class="fas fa-link"></i></a>2.题目翻译</h4>
      
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;观察一下编程人员，你可能会发现，同厨师一样，某项任务的计划进度，可能受限于顾客要求的紧迫程度，但紧迫程度无法控制实际的完成情况。就像约好在两分钟内完成一个煎蛋，看上去可能进行得非常好。但当它无法在两分钟内完成时，顾客只能选择等待或者生吃煎蛋。软件顾客的情况类似。<br>
	　　我现在并不认为软件经理内在的勇气和坚持不如厨师，或者不如其他工程经理。但为了满足顾客期望的日期而造成的不合理进度安排，在软件领域中却比其他的任何工程领域要普遍得多。而且，非量化方法的采用，少得可怜的数据支特，加上完全借助软件经理的直觉，这样的方式很难生产出健壮可靠和规避风险的估计。<br>
	　　显然我们需要两种解决方案。开发并推行生产率图表、缺陷率、估算规则等，整个组织最终会从这些数据的共享上获益。或者在基于可靠基础的估算出现之前，项目经理需要挺直腰杆并坚持他们的估计，确信自己的经验和直觉总比从期望得出的估计要强得多。</p>

        <h3 id="10编译与解析">
          <a href="#10编译与解析" class="heading-link"><i class="fas fa-link"></i></a>10.编译与解析</h3>
      

        <h4 id="1题目-10">
          <a href="#1题目-10" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321223914.png" alt></p>

        <h4 id="2题目-4">
          <a href="#2题目-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<ol>
<li>目标代码生成阶段应考虑直接影响到目标代码速度的三个问题：</li>
<li>一是如何生成较短的目标代码；</li>
<li>二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；</li>
<li>三是如何充分利用计算机指令系统的特点，以提高目标代码的质量。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/20/2020年02月07日软件设计师每日一练/">2020年02月07日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">7分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/20/2020年02月07日软件设计师每日一练/" data-flag-title="2020年02月07日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1面向对象的基本概念">
          <a href="#1面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1.面向对象的基本概念</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232539.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232729.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232750.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232817.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232842.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232906.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232925.png" alt></p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232948.png" alt></p>

        <h4 id="2解析">
          <a href="#2解析" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ul>
<li>
<p><code>开-闭原则</code>要求一个软件实体应当对扩展开放，对修改关闭。也就是说，我们在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，换句话说就是，应当可以在不必修改源代码的情况下改变这个模块的行为。<br></p>
</li>
<li>
<p><code>里氏代换原则</code>要求子类型必须能够替换它们的基类型，所以在里氏代换原则中，任何可基类对象可以出现的地方，子类对象也一定可以出现。</p>
</li>
<li>
<p><code>依赖倒转原则</code>是：要依赖于抽象，不要依赖于具体。也就是常说的要针对接口编程，不要针对实现编程。</p>
</li>
</ul>

        <h3 id="2排序与查找">
          <a href="#2排序与查找" class="heading-link"><i class="fas fa-link"></i></a>2.排序与查找</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233237.png" alt></p>

        <h4 id="2解析-2">
          <a href="#2解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233252.png" alt></p>

        <h3 id="3树与二叉树">
          <a href="#3树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>3.树与二叉树</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235547.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233412.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235039.png" alt></p>

        <h4 id="2解析-3">
          <a href="#2解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233454.png" alt></p>

        <h3 id="4数据库的设计过程">
          <a href="#4数据库的设计过程" class="heading-link"><i class="fas fa-link"></i></a>4.数据库的设计过程.</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233649.png" alt></p>

        <h4 id="2解析-4">
          <a href="#2解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>软件设计必须依据对软件的需求来进行，结构化分析的结果为结构化设计提供了最基本的输入信息。从分析到设计往往经历以下流程：<br></p>
<p>（1）研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口。<br><br>
（2）根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型。针对两种不同的类型分别进行分析处理。<br><br>
（3）由数据流图推导出系统的初始结构图。<br><br>
（4）利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止。<br><br>
（5）根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计或数据文件的设计。<br><br>
（6）在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。<br><br>
所以接口设计的主要依据是数据流图，接口设计的任务主要是描述软件与外部环境之间的交互关系，软件内模块之间的调用关系。<br></p>

        <h3 id="5设计模式">
          <a href="#5设计模式" class="heading-link"><i class="fas fa-link"></i></a>5.设计模式</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233939.png" alt></p>

        <h4 id="2解析-5">
          <a href="#2解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ul>
<li>
<p>享元模式提供支持大量细粒度对象共享的有效方法。</p>
</li>
<li>
<p>组合模式（Composite）：将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</li>
<li>
<p>迭代器模式（Iterator）：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。<br></p>
</li>
<li>
<p>备忘录模式（Memento）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。</p>
</li>
</ul>

        <h3 id="6面向对象的基本概念">
          <a href="#6面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>6.面向对象的基本概念</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234103.png" alt></p>

        <h4 id="2解析-6">
          <a href="#2解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查面向对象分析与设计的基本概念。<br><br>
&nbsp;&nbsp;&nbsp; 面向对象分析主要强调理解问题是什么，不考虑问题的解决方案，因此答案A、C是正确的。面向对象设计侧重问题的解决方案，并且需要考虑实现细节问题，因此选项D的说法是不正确的。</p>

        <h3 id="7专业英语">
          <a href="#7专业英语" class="heading-link"><i class="fas fa-link"></i></a>7.专业英语</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234247.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234330.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234406.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235147.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235227.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235256.png" alt></p>

        <h4 id="2解析-7">
          <a href="#2解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>软件实体的尺寸比任何其他人类构造更复杂，因为没有两个部分相同（至少在语句级上）。如果是，我们将两个相似的部分分成一个，一个（71），开放或关闭。在这方面，软件系统与计算机，建筑物或汽车有着深刻的区别，其中重复的元素很多。<br></p>
<p>数字电脑本身比大多数人理解的很多情况都要更复杂。这使得构思，描述和测试他们非常复杂。软件系统比计算机更多（72）数量级。<br><br>
同样地，软件实体的放大不仅仅是较大尺寸的相同元素的重复;必然增加不同要素的数量。在大多数情况下，这些元素以（73）的方式彼此相互作用，并且整体的复杂性比线性增加更多。<br><br>
软件的复杂性是（74）的属性，而不是偶然的。因此，消除其复杂性的软件实体的描述往往会抽象出其本质。数学和物理科学通过构建复杂现象的简化模型，从模型中导出属性，并通过实验验证这些属性，在三个世纪以来取得了长足的进步。这是因为模型中被忽略的复杂性（75）不是现象的基本属性。当复杂性是本质时，它不起作用。<br><br>
开发软件产品的许多经典问题源于这一重要的复杂性，其非线性随着尺寸而增加。不仅技术问题，管理问题也来自于复杂性。<br></p>

        <h3 id="7计算机指令">
          <a href="#7计算机指令" class="heading-link"><i class="fas fa-link"></i></a>7.计算机指令</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234631.png" alt></p>

        <h4 id="2解析-8">
          <a href="#2解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>指令平均时钟数约为<br><br>
　　　（160000×1+30000×2 +24000×4+16000×8）/（160000+30000+24000+16000）<br><br>
&nbsp;&nbsp;&nbsp; =444000/230000≈1.93<br><br>
　　该计算机的运算速度约为</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/19/2020年02月06日软件设计师每日一练/">2020年02月06日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-19</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">10分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/19/2020年02月06日软件设计师每日一练/" data-flag-title="2020年02月06日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1面向对象的基本概念">
          <a href="#1面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1.面向对象的基本概念</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319195633.png" alt></p>

        <h4 id="2解析">
          <a href="#2解析" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ul>
<li>本题考查面向对象的基本知识。 面向对象的4个核心概念是对象、类、继承和消息传递。</li>
<li>其中，对象是基本的运行时的实体，它既包括数据（属性），也包括作用于数据的操作（行为）。所以，一个对象把属性和行为封装为一个整体。类定义了一组大体上相似的对象。</li>
<li>一个类所包含的方法和数据描述一组对象的共同行为和属性。在进行类设计时，有些类之间存在一般和特殊关系，即一些类是某个类的特殊情况，某个类是一些类的一般情况，这就是继承关系。</li>
<li>消息是对象之间进行通信的一种构造，包含要求接收对象去执行某些活动的信息。</li>
</ul>

        <h3 id="2程序语言">
          <a href="#2程序语言" class="heading-link"><i class="fas fa-link"></i></a>2…程序语言</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319212332.png" alt></p>

        <h4 id="2解析-2">
          <a href="#2解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查程序语言的基础知识。B答案<br><br>
　　一个文法定义的语言是终结符号串的集合，这些终结符号串应能从文法的起始符号出发推导出来。</p>

        <h3 id="3设计模式">
          <a href="#3设计模式" class="heading-link"><i class="fas fa-link"></i></a>3.设计模式</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319212559.png" alt></p>

        <h4 id="2解析-3">
          <a href="#2解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ul>
<li>观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。本题选择D选项。</li>
<li>A选项描述的是迭代器（Iterator）模式：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。</li>
<li>B选项描述的是中介者（Mediator）模式：用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互。</li>
<li>C选项描述的是备忘录（Memento）模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。</li>
</ul>

        <h3 id="4软件测试">
          <a href="#4软件测试" class="heading-link"><i class="fas fa-link"></i></a>4.软件测试</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319212949.png" alt></p>

        <h4 id="2解析-4">
          <a href="#2解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p><code>所谓等价类</code>就是某个输入域的集合，对于一个等价类中的输入值来说，它们揭示程序中错误的作用是等效的。也就是说，如果等价类中的一个输入数据能检测出一个错误，那么等价类中的其他输入数据也能检测出同一个错误。</p>
<p>在本题中一个<code>设计用例</code>包含两个输入条件，一个是班委，另一个是年龄，从四个选项来看，D选项中的两个输入都不是有效数据，如果用这个用例检测出了一个错误，那么也不能确定是由哪个输入条件引起的，因此其不是一个好的测试用例。</p>

        <h3 id="5正规式">
          <a href="#5正规式" class="heading-link"><i class="fas fa-link"></i></a>5.正规式</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319213158.png" alt></p>

        <h4 id="2解析-5">
          <a href="#2解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查程序语言基础知识。 　　闭包运算符“<em>”将其运算对象进行若干次连接，因此0</em>表示若干个0构成的串，而（10*1）*则表示偶数个1构成的串。</p>

        <h3 id="6排序与查找">
          <a href="#6排序与查找" class="heading-link"><i class="fas fa-link"></i></a>6.排序与查找</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      

        <h4 id="2解析-6">
          <a href="#2解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查数据结构基础知识。<br>
设查找表的元素存储在一维数组r[1…n]二中，那么在表中的元素己经按关键字递增（或递减）的方式排序的情况下，进行折半查找的方法是:首先将待查元素的关键字（key）值与表r中间位置上（下标为mid ）的记录的关键字进行比较，若相等，则查找成功。若key&gt;r[mid].key，则说明待查记录只可能在后半个子表r[mid+1…n]中，下一步应在后半个子表中再进行折半查找;若key&lt;r[mid].key，说明待查记录只可能在前半个子表r[ 1.mid-1」中，下一步应在r的前半个子表中进行折半查找，这样通过逐步缩小范围，直到查找成功或子表为空时失败为止。<br>
在题中，以中间元素41为界将数组元素分为12， 23， 30， 38和52， 54，76， 85两部分，显然54在后半部分，该部分的中间元素为54（向下取整）或76（向上取整），在52，54构成的子查找表中，向上取整的中间元素为54，因此查找元素54所经历“比较”运算的数据元素依次为41，76，54。</p>

        <h3 id="7开发模型">
          <a href="#7开发模型" class="heading-link"><i class="fas fa-link"></i></a>7.开发模型</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319215737.png" alt></p>

        <h4 id="2解析-7">
          <a href="#2解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ul>
<li>
<p>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。<br></p>
</li>
<li>
<p>极限编程是一种轻量级的开发方法，它提出了四大价值观：沟通、简单、反馈、勇气。五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作。<br></p>
</li>
<li>
<p>水晶法强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。<br></p>
</li>
<li>
<p>并列争球法的核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件。<br></p>
</li>
<li>
<p>自适应软件开发的核心是三个非线性的，重迭的开发阶段：猜测、合作、学习。</p><p></p>
</li>
</ul>

        <h3 id="8编程语言基础">
          <a href="#8编程语言基础" class="heading-link"><i class="fas fa-link"></i></a>8.编程语言基础</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319222704.png" alt></p>

        <h4 id="2解析-8">
          <a href="#2解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查的是面向对象程序设计中的静态成员。在C十十中使用静态成员来解决同一个类的不同对象之间的数据共享问题</p>
<p>静态成员作为类的一种成员，它被类的所有对象共享，而不是属于某个对象的。静态成员分为静态成员变量和静态方法</p>
<p>静态成员变量的值可以被更新。只要对静态成员变量的值更新一次，所有对象的该静态成员变量的值都会被更新<br>
静态成员函数可以直接访问静态成员，但不能直接访问非静态成员。</p>

        <h3 id="9系统问题">
          <a href="#9系统问题" class="heading-link"><i class="fas fa-link"></i></a>9.系统问题</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319224011.png" alt></p>

        <h4 id="2解析-9">
          <a href="#2解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<pre><code>	本题考查系统的可维护性评价指标。系统的可维护性可以定性地定义为:维护人员理解、改正、改动和改进这个软件的难易程度，其评价指标包括可理解性、可测试性和可修改性。
</code></pre>

        <h3 id="10uml">
          <a href="#10uml" class="heading-link"><i class="fas fa-link"></i></a>10.UML</h3>
      

        <h4 id="1题目-10">
          <a href="#1题目-10" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319224139.png" alt></p>

        <h4 id="2解析-10">
          <a href="#2解析-10" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>​	顺序图（sequence diagram，序列图）。顺序图是一种交互图（interaction diagram），交互图展现了一种交互，它由一组对象或参与者以及它们之间可能发送的消息构成。交互图专注于系统的动态视图。顺序图是强调消息的时间次序的交互图。</p>
<p>​	本题图示为序列图。序列图展示了1个用例和多个对象的行为</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/18/2020年02月05日软件设计师每日一练/">2020年02月05日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-19</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">8分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/18/2020年02月05日软件设计师每日一练/" data-flag-title="2020年02月05日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1其他">
          <a href="#1其他" class="heading-link"><i class="fas fa-link"></i></a>1.其他</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225035.png" alt></p>

        <h4 id="2解析">
          <a href="#2解析" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>在对软件系统进行评价时，从系统评价对象出发，用户方所关心的是用户需求和运行质量平。</p>

        <h3 id="2软件开发">
          <a href="#2软件开发" class="heading-link"><i class="fas fa-link"></i></a>2.软件开发</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225133.png" alt></p>

        <h4 id="2解析-2">
          <a href="#2解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ol>
<li><code>甘特图</code>、<code>PERT</code>（计划评审技术）图及<code>CPM</code>（关键路径法）图是<strong>软件项目管理中常用的管理开发进度的工具</strong>，</li>
<li>鱼骨图是常用来发现问题根源并提出解决问题的有效办法的工具。在这三种开发进度管理工具图中，</li>
<li>甘特图能够消晰描述每个任务的开始/结束时间及各任务之间的并行性，也可以动态地反映项目的开发进展情况，但难以反映多个任务之间存在的逻辑关系；</li>
<li>PERT利用项目的网络图和各活动所需时间的估计值（通过加权平均得到的）去计算项目总时间，强调任务之间的先后关系，但不能反映任务之间的并行性，以及项目的当前进展情况；</li>
<li>CPM借助网络图和各活动所需时间，计算每一活动的最早或最迟开始和结束时间。CPM的关键是计算总时差，这样可决定哪一活动有最小时间弹性。PERT利用项目的网络图和各活动所需时间的估计值（通过加权平均得到）去计算项目总时间。</li>
<li>PERT不同于CPM的主要点在于PERT利用期望值而不是最可能的活动所需时间估计（在CPM法中用的）。</li>
</ol>

        <h3 id="3有限自动机">
          <a href="#3有限自动机" class="heading-link"><i class="fas fa-link"></i></a>3.有限自动机</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225310.png" alt></p>

        <h4 id="2解析-3">
          <a href="#2解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>对于该有限自动机，A为初态，C为终态，因此能识别的串一定是a开始b结束的串，可以排除C、D选项。</p>
<p>并且，对于该自动机能识别的串，经过初始a到达B状态后，只能识别b字符，因此A选项也错误。 本题只能选择D选项abab，是识别顺序如下图所示：       <img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225457.png" alt></p>

        <h3 id="4软件维护类型">
          <a href="#4软件维护类型" class="heading-link"><i class="fas fa-link"></i></a>4.软件维护类型</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225536.png" alt></p>

        <h4 id="2解析-4">
          <a href="#2解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ol>
<li>软件维护的内容一般包括准确性维护、适应性维护、完善性维护和预防性维护。</li>
<li>正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</li>
<li>适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。</li>
<li>完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</li>
<li>预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。</li>
</ol>

        <h3 id="5排序与查找">
          <a href="#5排序与查找" class="heading-link"><i class="fas fa-link"></i></a>5排序与查找.</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225645.png" alt></p>

        <h4 id="2解析-5">
          <a href="#2解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ol>
<li>本题考查算法分析的基础知识。</li>
<li>排序和查找是基本的计算问题。存在很多相关的算法，不同的算法适用于不同的场合。不同的数据输入特点相同的算法也有不同的计算时间。</li>
<li>若数据基本有序，对插入排序算法而言，则可以在近似线性时间内完成排序。即 O(n)；</li>
<li>而对于快速排序而言，则是其最坏情况，需要二次时间才能完成排序，即O(n<sup>2</sup>)。两个算法在排序时仅需要一个额外的存储空间，即空间复杂度为常数O(1)。</li>
</ol>

        <h3 id="6树与二叉树">
          <a href="#6树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>6.树与二叉树</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319232605.png" alt></p>

        <h4 id="2解析-6">
          <a href="#2解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查平衡查找树。<br>
由于平衡二叉树中任一结点的左右子树高度之差不超过1，因此，若在CR中插入一个结点并使得CR的高度增加1，则结点C的左右子树高度之差为-1，同时以C为根的子树高度增加了1，所以结点B的左右子树高度之差变为-1。如此一来，A的左子树的高度为h+2、右子树的高度为h，根据定义，以A为根的子二叉树变为不平衡。</p>

        <h3 id="7gant图与pert图">
          <a href="#7gant图与pert图" class="heading-link"><i class="fas fa-link"></i></a>7.Gant图与Pert图</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319231615.png" alt></p>

        <h4 id="2解析-7">
          <a href="#2解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>甘特图是一种能清晰描述每个任务的开始和截止时间，能有效获得任务并行进行的信息的项目进度管理工具。</p>

        <h3 id="8开发模型">
          <a href="#8开发模型" class="heading-link"><i class="fas fa-link"></i></a>8.开发模型</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319232640.png" alt></p>

        <h4 id="2解析-8">
          <a href="#2解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>增量模型是一种非整体开发的模型，该模型具有较大的灵活性，适合于软件需求不明确的一种模型。使用该模型开发产品，一般是尽快构造出可运行的产品，然后在该产品的基础上再增加需要的新的构建，使产品更趋于完善。</p>

        <h3 id="9磁盘存取">
          <a href="#9磁盘存取" class="heading-link"><i class="fas fa-link"></i></a>9.磁盘存取</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319231848.png" alt></p>

        <h4 id="2解析-9">
          <a href="#2解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ol>
<li>
<p>本题考查对磁盘调度方面基本知识掌握的程度。</p>
</li>
<li>
<p>因为先来先服务是谁先请求先满足谁的请求，而最短寻找时间优先是根据当前磁臂到要请求访问磁道的距离，谁短满足谁的请求，故先来先服务和最短寻找时间优先算法可能会随时改变移动臂的运动方向。</p>
</li>
</ol>

        <h3 id="10多媒体相关技术">
          <a href="#10多媒体相关技术" class="heading-link"><i class="fas fa-link"></i></a>10.多媒体相关技术</h3>
      

        <h4 id="1题目-10">
          <a href="#1题目-10" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319232041.png" alt></p>

        <h4 id="2解析-10">
          <a href="#2解析-10" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>DPI即每英寸的点数，根据题目的描述，我们不难知道（300×600）/（2×4）=150 * 150 。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/17/2020年02月04日软件设计师每日一练/">2020年02月04日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">2.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">13分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/17/2020年02月04日软件设计师每日一练/" data-flag-title="2020年02月04日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1数据库设计过程">
          <a href="#1数据库设计过程" class="heading-link"><i class="fas fa-link"></i></a>1.数据库设计过程</h3>
      

        <h4 id="1题型">
          <a href="#1题型" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317180424.png" alt></p>

        <h4 id="2解析">
          <a href="#2解析" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>​    	本题的正确选项为A。<br>
<code>需求分析阶段的任务是：</code>对现实世界要处理的对象（组织、部门、企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理方法。</p>
<p><code>逻辑设计阶段的</code>任务之一是对关系模式进一步的规范化处理。因为生成的初始关系模式并不能完全符合要求，会有数据冗余、更新异常存在，这就需要根据规范化理论对关系模式进行分解，以消除冗余和更新异常。不过有时根据处理要求，可能还需要增加部分冗余以满足处理要求。逻辑设计阶段的任务就需要作部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。</p>

        <h3 id="2段页式存储">
          <a href="#2段页式存储" class="heading-link"><i class="fas fa-link"></i></a>2.段页式存储</h3>
      

        <h4 id="1题型-2">
          <a href="#1题型-2" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317180958.png" alt></p>

        <h4 id="2解析-2">
          <a href="#2解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ol>
<li>根据公式 ，可以分别计算段号，页号以及页内地址最大的寻址空间。</li>
<li>存储管理系统中的地址长度均表示为最大的寻址空间。及页内地址最大的寻址空间。存储管理系统中的地址长度均表示为最大的寻址空间。</li>
<li>页内地址为13位，即页大小为2<sup>13</sup>=8K；页号地址为11位，即页数最多为2<sup>11</sup>=2048；段号地址为8位，即段数最多为2<sup>8</sup>=256。</li>
</ol>

        <h4 id="3段页式存储">
          <a href="#3段页式存储" class="heading-link"><i class="fas fa-link"></i></a>3.段页式存储</h4>
      
<ol>
<li>
<p><strong>段页式存储管理方式</strong>即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。右图示出了一个作业的地址空间和地址结构。</p>
</li>
<li>
<p>（<strong>基本原理</strong>） 该作业有三个段，页面大小为4 KB。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成，如下图所示。<img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317181718.png" alt></p>
</li>
<li>
<p>（<strong>地址变换过程</strong>）在段页式系统中，为了便于实现地址变换，须配置一个段表<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">寄存器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，其中存放段表始址和段表长TL。进行地址变换时，首先利用段号S，将它与段表长TL进行比较。若S&lt;TL，表示未越界，于是利用段表始址</p>
<p>和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%A1%B5%E8%A1%A8" target="_blank" rel="noopener">页表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>始址，并利用<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">逻辑地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的段内页号P来获得对应页的页表项位置，从中读出该页所在的<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9D%97/12728827" target="_blank" rel="noopener">物理块</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>号b，再利用块号b和页内地址来构成<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">物理地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。右图示出了段页式系统中的地址变换机构。</p>
<p>在段页式系统中，为了获得一条指令或数据，须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正从第二次访问所得的地址中，取出指令或数据。</p>
<p>显然，这使访问<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614" target="_blank" rel="noopener">内存</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的次数增加了近两倍。为了提高执行速度，在地址变换机构中增设一个高速缓冲<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">寄存器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。每次访问它时，都须同时利用段号和页号去检索<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">高速缓存</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，若找到匹配的表项，便可从中得到相应页的物理块号，用来与页内地址一起形成<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">物理地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>；若未找到匹配表项，则仍须再三次访问内存。<img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317181913.png" alt></p>
</li>
</ol>

        <h3 id="3面向对象">
          <a href="#3面向对象" class="heading-link"><i class="fas fa-link"></i></a>3.面向对象</h3>
      

        <h4 id="1题型-3">
          <a href="#1题型-3" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317182155.png" alt></p>

        <h4 id="2解析-3">
          <a href="#2解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>​			 面向对象的分析（OOA）是一种面向对象范型的半形式化描述技术。面向对象的分析包括3个步骤:第1步是用例建模，它决定了如何由产品得到各项计算结果。并以用例图和相关场景的方式展现出来；第2步是类建模，它决定了类及其属性，然后确定类之间的关系和交互；第3步是动态建模，它决定了类或每个子类的行为，并以状态图的形式进行表示。</p>
<pre><code>		Object-oriented analysis （OOA） is a semiformal specification technique for the object-oriented paradigm.Object-oriented analysis consists of three steps.The first step is （）.It determines how the various results are computed by the product and presents this information in the form of a （） and associated scenarios.The second is  （） ， which determines the classes and their attributes， then determines the interrelationships and interaction among the classes.The last step is  （） ， which determines the actions performed by or to each class or subclass and presents this information in the form of 　（）.
</code></pre>

        <h3 id="4对称加密与非对称加密">
          <a href="#4对称加密与非对称加密" class="heading-link"><i class="fas fa-link"></i></a>4.对称加密与非对称加密</h3>
      

        <h4 id="1题型-4">
          <a href="#1题型-4" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317182942.png" alt></p>

        <h4 id="2解析-4">
          <a href="#2解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查的是信息安全中的加密算法。</p>
<p>​			其中：对大量明文进行加密，考虑效率问题，一般采用<code>对称加密</code>。<br>
<code>RSA</code>是非对称加密算法；<code>SHA-1</code>与<code>MD5</code>属于信息摘要算法；<code>RC-5</code>属于对称加密算法。这些算法中SHA-1与MD5是不能用来加密数据的，而RSA由于效率问题，一般不直接用于大量的明文加密，适合明文加密的，也就只有RC-5了。</p>

        <h3 id="5图">
          <a href="#5图" class="heading-link"><i class="fas fa-link"></i></a>5.图</h3>
      

        <h4 id="1题型-5">
          <a href="#1题型-5" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317183258.png" alt></p>

        <h4 id="2解析-5">
          <a href="#2解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>在无向图中，一条边连接两个顶点，即如果存在一条边，那么与这条边相关的两个顶点的度都为加1，那么总的度就应该加2，因此，如果图中有n条边，那么所有顶点的度数之和就应该为2e。</p>

        <h4 id="3无向图">
          <a href="#3无向图" class="heading-link"><i class="fas fa-link"></i></a>3.无向图</h4>
      
<p>​	无向图的边是没方向的，<strong>即两个相连的顶点可以互相抵达。</strong></p>
<p>​	而有向图的边是有方向的，即两个相连的顶点，根据边的方向，<strong>只能由一个顶点通向另一个顶点</strong>。</p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317190812.png" alt></p>

        <h4 id="4图表算法网址有关无向图">
          <a href="#4图表算法网址有关无向图" class="heading-link"><i class="fas fa-link"></i></a>4.图表算法网址（有关无向图）</h4>
      

        <h3 id="6侵权判断">
          <a href="#6侵权判断" class="heading-link"><i class="fas fa-link"></i></a>6.侵权判断</h3>
      

        <h4 id="1题型-6">
          <a href="#1题型-6" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317183913.png" alt></p>

        <h4 id="2解析-6">
          <a href="#2解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>​	第一空涉及到向客户提供工具软件的复制品，这里侵犯了工具软件的软著权；</p>
<p>​	第二空，甲公司没有注册商标，并且没有描述商业秘密相关内容，所以不涉及商标权保护和不正当竞争法保护，而著作权是自作品完成之时就开始保护，所以甲公司当软件产品完成之后，该作品就已经受到著作权保护了，乙公司的行为侵犯了著作权。</p>

        <h3 id="7操作系统存储">
          <a href="#7操作系统存储" class="heading-link"><i class="fas fa-link"></i></a>7.操作系统存储</h3>
      

        <h4 id="1题型-7">
          <a href="#1题型-7" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317191213.png" alt></p>

        <h4 id="2解析-7">
          <a href="#2解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查操作系统内存管理方面的基本概念。操作系统内存管理方案有许多种，其中，</p>
<p>分页存储管理系统中的每一页只是存放信息的物理单位，其本身没有完整的意义，因而不便于实现信息的共享，</p>
<p>而段却是信息的逻辑单位，各段程序的修改互不影响，无内碎片，有利于信息的共享。</p>

        <h3 id="8时间复杂度和空间复杂度">
          <a href="#8时间复杂度和空间复杂度" class="heading-link"><i class="fas fa-link"></i></a>8.时间复杂度和空间复杂度？？？</h3>
      

        <h4 id="1题型-8">
          <a href="#1题型-8" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317184637.png" alt></p>

        <h4 id="2解析-8">
          <a href="#2解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ol>
<li>X、Y的所有子序列都检查过后即可求出X、Y的最长公共子序列。X的一个子序列相应于下标序列1,2，…，n的一个子序列。因此，X共有2<sup>n</sup>个子序列。当然，Y也有2<sup>m</sup>个子序列。判断一个子序列是否也是Y的子序列的时间是n，因此时间复杂度为O(n2<sup>n</sup>)</li>
<li>动态规划的一个计算最长公共子序列的方法如下，两个序列 X、Y ：<br><br>
设有二维数组 c[i][j] 表示 X 的 i 位和 Y 的 j 位之前的最长公共子序列的长度，则有题干给定的函数表现形式<br><br>
其中，c(i,j)当 X 的第i位与 Y 的第 j 位完全相同时为“1”，否则为“0”。<br><br>
此时，c[i][j]中最大的数便是 X 和 Y 的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。该算法的空间、时间复杂度均为O(n<sup>2</sup>)。</li>
</ol>

        <h3 id="9多种程序语言特点">
          <a href="#9多种程序语言特点" class="heading-link"><i class="fas fa-link"></i></a>9.多种程序语言特点</h3>
      

        <h4 id="1题型-9">
          <a href="#1题型-9" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317185400.png" alt></p>

        <h4 id="2解析-9">
          <a href="#2解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p><code>可视化程序设计</code>主要是让程序设计入员利用软件本身所提供的各种控件，像搭积木式地构造应用程序的各种界面。可视化程序设计最大的优点是设计入员可以不用编写或只需编写很少的程序代码，就能完成应用程序的设计，这样就能极大地提高设计入员的工作效率。<strong>在可视化程序设计中，可随时查看程序的运行效果。</strong></p>

        <h3 id="10gant图pert图">
          <a href="#10gant图pert图" class="heading-link"><i class="fas fa-link"></i></a>10.Gant图Pert图</h3>
      

        <h4 id="1题型-10">
          <a href="#1题型-10" class="heading-link"><i class="fas fa-link"></i></a>1.题型</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317185922.png" alt></p>

        <h4 id="2解析-10">
          <a href="#2解析-10" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>由于在一个项目中时间最长的活动序列，决定着项目最短工期。而时间最长的是ABDIJL&nbsp; ，需要时间20，所以答案是D。</p>
<ol>
<li>BD活动在AB活动结束之后便可以开始，同时AB是第1天开始，而非第0天开始，所以最早开始时间为4。</li>
<li>HK活动需要在AEGH与ACFH两条路径上的活动均完成之后，才能开始，所以最早开始时间为11。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/16/2020年02月03日软件设计师每日一练/">2020年02月03日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-16</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">8分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/16/2020年02月03日软件设计师每日一练/" data-flag-title="2020年02月03日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1-计算机系统">
          <a href="#1-计算机系统" class="heading-link"><i class="fas fa-link"></i></a>1. 计算机系统</h3>
      

        <h4 id="1基础知识">
          <a href="#1基础知识" class="heading-link"><i class="fas fa-link"></i></a>1.基础知识</h4>
      
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本题考查的是计算机系统方面的基础知识。</span><br><span class="line">*系统响应时间*是指用户发出完整请求到系统完成任务给出响应的时间间隔。</span><br><span class="line">*作业吞吐量*是指单位时间内系统完成的任务量。若一个给定系统持续地收到用户提交的任务请求</span><br><span class="line">，则系统的响应时间将对作业吞吐量造成一定影响。若每个任务的响应时间越短，则系统的空闲资源较多，</span><br><span class="line">整个系统在单位时间内完成的任务量将越大；反之，若响应时间越长，则系统的空闲资源较少，整个系统在单位时间内完成的任务量将越小。</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="2树与二叉树">
          <a href="#2树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>2.树与二叉树</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316170445.png" alt></p>

        <h4 id="2解析">
          <a href="#2解析" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316171306.png" alt></p>

        <h3 id="3系统部件可靠性">
          <a href="#3系统部件可靠性" class="heading-link"><i class="fas fa-link"></i></a>3.系统部件可靠性</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316171439.png" alt></p>

        <h4 id="2解析-2">
          <a href="#2解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查多部件系统可靠性衡量方法。本题中，两个数据处理部件采用</p>
<p><code>并联结构A，算法1- （1- #）×（1- # ）</code></p>
<p><code>串联算法 A × B =？</code></p>
<p>该部分的可靠性为1- （1-0.6）×（1-0.6） =0.84。设数据存储部件可靠性为R，则整个系统的可靠性为0.84×R≥0.66，所以R≥0.66/0.84≈0.79。</p>

        <h3 id="4软件工程质量">
          <a href="#4软件工程质量" class="heading-link"><i class="fas fa-link"></i></a>4.软件工程质量</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316171837.png" alt></p>

        <h4 id="2解析-3">
          <a href="#2解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查软件的质量度量指标。<br><br>
&nbsp;&nbsp;&nbsp; 软件维护的工作量比开发阶段的工作量大，通常的估计是，开发阶段的工作量占软件生命期整个工作量的40%，而维护阶段的工作量则占60%，甚至更多。软件的正确性是指软件完成所需功能的程度，尽管这种程度与每千行代码的故障数有关，但不完全等同。软件完整性是指软件在安全方面抗攻击的能力。软件可用性用来度量软件的“用户友好性”，可以从4个方面来测量可用性：</p>
<ol>
<li>学会操作软件所需的体力/智力</li>
<li>对系统的使用达到中等效率所需的时间</li>
<li>当系统由一个中等效率的人使用时测量到的生产率增长值</li>
<li>用户对系统的主观评价</li>
</ol>

        <h3 id="5正规式">
          <a href="#5正规式" class="heading-link"><i class="fas fa-link"></i></a>5.正规式</h3>
      

        <h4 id="1题目解析">
          <a href="#1题目解析" class="heading-link"><i class="fas fa-link"></i></a>1.题目/解析</h4>
      
<h4 id><a class="markdownIt-Anchor" href="#"></a> <img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316172502.png" alt></h4>

        <h3 id="6设计模式">
          <a href="#6设计模式" class="heading-link"><i class="fas fa-link"></i></a>6.设计模式</h3>
      

        <h4 id="1题目解析-2">
          <a href="#1题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目/解析</h4>
      
<p>
 &nbsp;&nbsp;&nbsp; 本题考查设计模式的基本概念。<br>
 &nbsp;&nbsp;&nbsp; 设计模式最根本的目的在于复用相似问题的相同解决方案，从而提高软件在设计层次的复用度和设计的水平与质量。</p>

        <h3 id="7综合知识">
          <a href="#7综合知识" class="heading-link"><i class="fas fa-link"></i></a>7.综合知识</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316173203.png" alt></p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316173250.png" alt></p>

        <h4 id="2解析-4">
          <a href="#2解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316173535.png" alt></p>

        <h3 id="8数据的表示">
          <a href="#8数据的表示" class="heading-link"><i class="fas fa-link"></i></a>8.数据的表示</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316173726.png" alt></p>

        <h4 id="2解析-5">
          <a href="#2解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>
	&nbsp;&nbsp;&nbsp; 本题考查数据表示基础知识。<br>
	&nbsp;&nbsp;&nbsp; 根据补码定义，数值X的补码记作[X]<sub>补</sub>，如果机器字长为n，则最高位为符号位，0表示正号，1表示负号，正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。<br>
	&nbsp;&nbsp;&nbsp; 16位补码能表示的数据范围为[-2<sup>15 </sup>，2<sup>15</sup> -1] 。对于整数( 2<sup>16</sup> -1)和(-2<sup>16</sup> +1 )，数据表示需要16位，再加一个符号位，共17位，因此不在16位补码能表示的数据范围之内。<br>
	&nbsp;&nbsp;&nbsp; 在补码表示中，0有唯一的编码：[+0]<sub>补</sub>0000000000000000，[-0]<sub>补</sub>0000000000000000，即0000<sub>H</sub>。<br>
	&nbsp;&nbsp;&nbsp; [-1]<sub>原</sub>＝1000000000000001，[-1]<sub>反</sub>＝1111111111111110，因此-1的补码为[-1]<sub>补 </sub>=1111111111111111=FFFF。</p>

        <h4 id="3引申数据表示">
          <a href="#3引申数据表示" class="heading-link"><i class="fas fa-link"></i></a>3.引申数据表示</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/fuhaots2009/p/3476502.html" target="_blank" rel="noopener">详解网址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>二进制中的原码、反码、补码</p>
<p>对于有符号数而言：</p>
<ol>
<li>(1)二进制的最高位是符号位：0表示正数，1表示负数</li>
<li>(2)正数的原码、反码、补码都一样；</li>
<li>(3)负数的反码 = 它的原码符号位不变，其他位取反（0 -&gt;1 ; 1-&gt;0 ）；</li>
<li>(4)负数的补码 = 它的反码 +1；</li>
<li>(5)0的反码、补码都是0；</li>
<li>(6)在计算机运算的时候，都是以补码的方式来运算的；</li>
</ol>

        <h3 id="9网络安全">
          <a href="#9网络安全" class="heading-link"><i class="fas fa-link"></i></a>9.网络安全</h3>
      

        <h4 id="1基础知识-2">
          <a href="#1基础知识-2" class="heading-link"><i class="fas fa-link"></i></a>1.基础知识</h4>
      
<p>​                HTTPS以保密为目标研发，简单讲是HTTP的安全版。其安全基础是SSL协议，全称<code>Hypertext Transfer Protocol over Secure Socket Layer。</code> 它是一个URI scheme，句法类同http:体系。它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个协议的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于互联网上安全敏感的通讯，例如交易支付方面。 SSL极难窃听，对中间人攻击提供一定的合理保护。严格学术表述HTTPS是两个协议的结合，即传输层SSL＋应用层HTTP。</p>

        <h3 id="10设计模式">
          <a href="#10设计模式" class="heading-link"><i class="fas fa-link"></i></a>10.设计模式</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316175401.png" alt></p>

        <h4 id="2解析-6">
          <a href="#2解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>图中所示模式为<em>生成器模式</em>，该模式适用于当创建复杂对象的算法应该独立于该对象的组成部分及其装配方式时。<br>
<code>抽象工厂模式（Abstract Factory）:</code>提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类 .<br>
工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟。<br>
原型模式（Prototype）：用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/15/2020年02月02日软件设计师每日一练/">2020年02月02日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">10分</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/03/15/2020年02月02日软件设计师每日一练/" data-flag-title="2020年02月02日软件设计师每日一练"><span class="post-meta-item__icon" data-popover="阅读次数" data-popover-pos="up"><i class="fas fa-eye"></i></span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1传值与传址">
          <a href="#1传值与传址" class="heading-link"><i class="fas fa-link"></i></a>1.传值与传址</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p>调用引用方式下进行函数调用，是将（）</p>

        <h4 id="2解析">
          <a href="#2解析" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>在函数调用时，系统为形参准备空间，并把实参的值赋值到形参空间中，在调用结束后，形参空间将被释放，而实参的值保持不变，这就是传值传递方式。传值传递方式中实参与形参之间的数据传递是单向的，只能由实参传递给形参，因而即使形参的值在函数执行过程中发生了变化，也不会影响到实参值。在C语言中，当参数类型是非指针类型和非数组类型时，均采用传值方式。</p>
<p>传地址方式把实参的地址赋值给形参，这样形参就可以根据地址值访问和更改实参的内容，从而实现双向传递。当参数类型是指针类型或数组类型时，均采用传地址方式。</p>

        <h3 id="2数据的表示">
          <a href="#2数据的表示" class="heading-link"><i class="fas fa-link"></i></a>2.数据的表示</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p>计算机中的浮点数由三部分组成：符号位S，指数部分E（称为阶码）和尾数部分M。在总长度固定的情况下，增加E的位数、减少M的位数可以（  ）。</p>

        <h4 id="2解析-2">
          <a href="#2解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>浮点数的表述形式如下：N=M×r</p>
<p>其中r是浮点数阶码的底，与尾数的基数相同，通常r=2.E和M都是带符号的定点数，E叫做阶码，M叫做尾数。浮点数的一般格式如图所示，浮点数的底是隐含的，在整个机器数中不出现。阶码的符号位为E<sub>s</sub>，阶码的大小反应了在数N中小数点的实际位置；尾数的符号位为M<sub>s</sub>，它也是整个浮点数的符号位，表示了该浮点数的正、负。</p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315220936.png" alt="浮点数的一般格式"></p>
<p>浮点数的大小由阶码部分决定，而其精度由尾数部分决定，因此增加E的位数、减少M的位数可以扩大可表示的数的范围同时降低精度。</p>

        <h3 id="3编译和解析">
          <a href="#3编译和解析" class="heading-link"><i class="fas fa-link"></i></a>3.编译和解析</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p>以下关于高级程序设计语言翻译的叙述中，正确的是（  ）。</p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315221339.png" alt></p>
<p>2.解析</p>
<p>在对用高级程序设计语言编写的程序进行执行时，首先是将源代码翻译成目标代码，然后在连接成可执行的二进制代码。因此在翻译阶段，目标代码生成阶段的工作与目标机器的体系结构密切相关。</p>

        <h3 id="4协议">
          <a href="#4协议" class="heading-link"><i class="fas fa-link"></i></a>4.协议</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315222005.png" alt></p>

        <h4 id="2解析-3">
          <a href="#2解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查的是电子邮件协议的基本知识。</p>
<p>常见的电子邮件协议包括SMTP（简单邮件传输协议）、POP3（邮局协议）和IMAP（ Internet邮件访问协议）。这几种协议都是由TCP/IP协议族定义的。SMTP &lt; Simple Mail Transfer Protocol ）主要负责底层的邮件系统如何将邮件从一台机器传至另外一台机器。</p>

        <h3 id="5多媒体的基本概念">
          <a href="#5多媒体的基本概念" class="heading-link"><i class="fas fa-link"></i></a>5.多媒体的基本概念</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315222218.png" alt></p>

        <h4 id="2解析-4">
          <a href="#2解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>彩色打印的纸张是不能发射光线的，因而彩色打印机使用能够吸收特定的光波而反射其他光波的油墨或颜料来实现。用油墨或颜料进行混合得到的彩色称为相减混色。之所以称为相减混色，是因为减少（吸收）了人眼识别颜色所需要的反射光。根据三基色原理，油墨或颜料的三基色是青（cyan）、品红（magenta）和黄（yellow ）。可以用这三种颜色的油墨或颜料按不同比例混合成任何一种由油墨或颜料表现的颜色，这种彩色表示方法称为CMY彩色空间。</p>

        <h3 id="6软件设计">
          <a href="#6软件设计" class="heading-link"><i class="fas fa-link"></i></a>6.软件设计</h3>
      

        <h4 id="1解析">
          <a href="#1解析" class="heading-link"><i class="fas fa-link"></i></a>1.解析</h4>
      
<p>​	本题考查软件系统设计知识。系统设计为系统制定蓝图，软件设计模型关注新系统总体结构、代码设计、处理过程、数据结构和界面模型等。对项目范围的关注在软件设计之前。</p>

        <h3 id="7cache">
          <a href="#7cache" class="heading-link"><i class="fas fa-link"></i></a>7.Cache</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315222448.png" alt></p>

        <h4 id="2解析-5">
          <a href="#2解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>在程序的执行过程中，Cache与主存的地址映射是由硬件自动完成的。</p>

        <h4 id="3引申">
          <a href="#3引申" class="heading-link"><i class="fas fa-link"></i></a>3.引申</h4>
      
<p>Cache存储器，<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E7%94%B5%E8%84%91/124859" target="_blank" rel="noopener">电脑</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中为<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/9027270" target="_blank" rel="noopener">高速缓冲存储器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，是位于<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/CPU/120556" target="_blank" rel="noopener">CPU</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/10635399" target="_blank" rel="noopener">主存储器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>DRAM（Dynamic Random Access Memory）之间，规模较小，但速度很高的存储器，通常由<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/SRAM/7705927" target="_blank" rel="noopener">SRAM</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（Static Random Access Memory <span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%99%A8/6797116" target="_blank" rel="noopener">静态存储器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）组成。它是位于CPU与内存间的一种容量较小但速度很高的存储器。CPU的速度远高于内存，当CPU直接从内存中存取数据时要等待一定时间周期，而Cache则可以保存CPU刚用过或循环使用的一部分数据，如果CPU需要再次使用该部分数据时可从Cache中直接调用，这样就避免了重复存取数据，减少了CPU的等待时间，因而提高了系统的效率。Cache又分为L1Cache（一级缓存）和L2Cache（二级缓存），L1Cache主要是集成在CPU内部，而L2Cache集成在主板上或是CPU上。</p>
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/tercel_zhang/article/details/81031476" target="_blank" rel="noopener">详解网址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="8数据结构">
          <a href="#8数据结构" class="heading-link"><i class="fas fa-link"></i></a>8.数据结构</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315223337.png" alt></p>

        <h4 id="2解析-6">
          <a href="#2解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查栈和队列的墓本概念及运算。<br><br>
<code>栈是先进后出的线性表，而队列是先进先出的线性表。</code>若队列的输出元素序列为c、d、b、 a、 e，则进入队列的元素序列也为C， d， b， a， e，这也是从栈中出来的元素序列。<br><br>
若元素以a、 b、c、d、e的次序进入栈S且得到输出序列c、d、 b、 a、e，则操作系列为a入栈、b入栈、C入栈、C出栈、d入栈、d出栈、b出栈、a出栈、e入栈、e出栈。第一个出栈的元素为c，则c出栈时元素a和b尚在栈中，如下图所示。<br><br>
<img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315223523.png" alt><br>
栈S的容量至少为3。</p><p></p>

        <h3 id="9排序与查找">
          <a href="#9排序与查找" class="heading-link"><i class="fas fa-link"></i></a>9.排序与查找</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315223721.png" alt></p>

        <h4 id="2解析-7">
          <a href="#2解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>将有序表放入数组如下：<br>
根据二分法的查找过程： 
</p><p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315223950.png" alt></p>
<p>（1）第一轮比较对象（0+8）/2=4，即与序号为4的关键字26进行比较；<br>（2）第二轮如果选择左侧较小列，则下一个比较对象应该为（0+3）/2=1（向下取整），即与序号为1的关键字15比较，没有对应的选项；<br>（3）第二轮如果选择右侧较大列，则下一个比较对象应该为（5+8）/2=6（向下取整），即与序号为6的关键字40进行比较。<br>所以应该选择C选项。<br></p><p></p>

        <h3 id="10线性表">
          <a href="#10线性表" class="heading-link"><i class="fas fa-link"></i></a>10.线性表</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315224129.png" alt></p>

        <h4 id="2解析-8">
          <a href="#2解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查循环队列长度的求取</p>
<p>根据图示，可以得到长度（Q.rear-Q.front+M），但在此不容忽视的一个问题是，循环队列在进行了多次入队出队操作之后，可能出现超出队列长度溢出的情况，因此需要让其与M进行求模操作，修正位置，故（Q.rear-Q.front+M）%M为队列中的元素个数（即队列长度）</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/3/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417183933.png" alt="avatar"></div><p class="sidebar-ov-author__text">繁华落尽一场空：风往尘香花已尽</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YichangKong" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/yichangkong" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-git"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/yichangkong" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">65</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">22</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Liu Jun</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v3.9.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zindex="-1"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'xuXblFdHlR0fcnQsdkLwkqvG-gzGzoHsz',
    appKey: 'ac3XS1leXcL95PWUhYV6gx0E',
    notify: true,
    verify: true,
    placeholder: 'Just go go',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script></body></html>