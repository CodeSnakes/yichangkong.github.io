<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="360-site-verification" content="85f7e8dc96dcd0b1a29c6f1cc30c4a73"><meta name="description" content="爱了">
<meta name="keywords" content="yichangkong 博客 技术 java spring">
<meta property="og:type" content="website">
<meta property="og:title" content="YiChangKong">
<meta property="og:url" content="https://yichangkong.github.io/page/5/index.html">
<meta property="og:site_name" content="YiChangKong">
<meta property="og:description" content="爱了">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YiChangKong">
<meta name="twitter:description" content="爱了"><meta name="keywords" content="Liu Jun, YiChangKong"><meta name="description" content="爱了"><title>YiChangKong</title><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/5.13.0/css/all.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">个人</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/Test/"><span class="header-nav-submenu-item__text">日常</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/About/"><span class="header-nav-submenu-item__icon"><i class="far fa-about"></i></span><span class="header-nav-submenu-item__text">关于</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/Poetry/"><span class="header-nav-submenu-item__text">诗歌</span></a></div></div></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">YiChangKong</div><div class="header-banner-info__subtitle">Coding is my life, But not all!</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/27/2020年02月14日软件设计师每日一练/">2020年02月14日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-27</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1拓扑排序">
          <a href="#1拓扑排序" class="heading-link"><i class="fas fa-link"></i></a>1.拓扑排序</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327204350.png" alt></p>
<p>答案：A</p>
<p>我的答案：C</p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查图数据结构。<br>
　　对有向图进行拓扑排序的方法如下：<br>
　　（1）在AOV网中选择一个入度为0（没有前驱）的顶点且输出它。<br>
　　（2）从网中删除该顶点及其与该顶点有关的所有边。<br>
　　（3）重复上述两步，直至网中不存在入度为0的顶点为止。<br>
　　执行的结果会有两种情况：一种是所有顶点己输出，此时整个拓扑排序完成，说明网中不存在回路；另一种是尚有未输出的顶点，剩余的顶点均有前驱顶点，表明网中存在回路，拓扑排序无法进行下去。</p>
</blockquote>

        <h3 id="2容量的计算">
          <a href="#2容量的计算" class="heading-link"><i class="fas fa-link"></i></a>2.容量的计算</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327204644.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查内存容量的计算。<br><br>
给定起、止地址码的内存容量=终止地址-起始地址+1。<br></p>
<p>将终止地址加1等于E000H，再减去起始地址，即E0000H-A0000H=40000H。十六进制的（40000）<sub>16</sub>=2<sup>18</sup><br>
　　组成内存储器的芯片数量=内存储器的容量/单个芯片的容量。 答案：C</p>
</blockquote>

        <h3 id="3数字证书">
          <a href="#3数字证书" class="heading-link"><i class="fas fa-link"></i></a>3.数字证书</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205318.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><code>数字证书</code>就是互联网通讯中标志通讯各方身份信息的一系列数据，就好比日常生活中个人身份证一样。</p>
<p>数字证书是由一个权威机构证书授权中心（CA）发行的。</p>
<p>最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。</p>
<p>其中证书授权中心的数字签名是用它自己的私钥完成的，而它的公钥也是公开的，大家可以通过它的公钥来验证该证书是否是某证书授权中心发行的，以达到验证数字证书的真实性。因此本题答案选C。</p>
</blockquote>

        <h3 id="4程序语言">
          <a href="#4程序语言" class="heading-link"><i class="fas fa-link"></i></a>4.程序语言</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205423.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>程序设计语言的基本成分包括</p>
<p>数据、运算、控制和传输等。</p>
<p>程序设计语言的控制成分包括<strong>顺序、选择和循环3种结构</strong>。<br>
所以本题选择A选项。</p>
</blockquote>

        <h3 id="5软件测试">
          <a href="#5软件测试" class="heading-link"><i class="fas fa-link"></i></a>5.软件测试</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205555.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查系统测试中的确认测试。</p>
<p>确认测试首先要进行有效性测试以及软件配置审查，然后进行验收测试和安装测试。</p>
<p>其中有效性测试，就是在模拟环境下，通过黑盒测试检验所开发的软件是否与需求规格说明书一致。</p>
</blockquote>

        <h3 id="6数据表示">
          <a href="#6数据表示" class="heading-link"><i class="fas fa-link"></i></a>6.数据表示</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205704.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查计算机系统<strong>数据编码基础知识</strong>。<br><br>
　　设机器字长为n（即采用n个二进制位表示数据），最高位是符号位，0表示正号，1表示负号。<br><br>
　　原码表示方式下，除符号位外，n-1位表示数值的绝对值。因此，n为8时，[+0]原=0 0000000，[-0]原=1 0000000。<br><br>
　　正数的反码与原码相同，负数的反码则是其绝对值按位求反。n为8时，数值0的反码表示有两种形式：[+0]反=0 0000000，[-0]反=11111111。<br><br>
　　正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。在补码表示中，0有唯一的编码：[+0]补=0 0000000，[-0]补=00000000。<br><br>
　　移码表示法是在数X上增加一个偏移量来定义的，常用于表示浮点数中的阶码。机器字长为n时，在偏移量为2<sup>n-1</sup>的情况下，只要将补码的符号位取反便可获得相应的移码表示。</p>
</blockquote>

        <h3 id="7传址与传值">
          <a href="#7传址与传值" class="heading-link"><i class="fas fa-link"></i></a>7.传址与传值</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205856.png" alt></p>
<p>答案：D</p>
<p>我的：A</p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>传值调用中，形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变；而引用（传址）调用中，形参取的是实参的地址，即相当于实参存储单元的地址引用，因此其值的改变同时就改变了实参的值。<br><br>
x = 2*10-1=19；<br><br>
a是引用传递，所以a=a+x=10+19=29，结果为29。</p>
</blockquote>

        <h3 id="8运算器和控制器">
          <a href="#8运算器和控制器" class="heading-link"><i class="fas fa-link"></i></a>8.运算器和控制器</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327210006.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>CPU是一台计算机的<strong>运算核心</strong>和<strong>控制核心</strong>，</p>
<p>其由<strong>运算器、控制器、寄存器</strong>及实现它们之间联系的数据、控制及状态的总线构成。其中</p>
<ul>
<li>运算器负责相关的逻辑、算术运算，</li>
<li>寄存器用来存放一些相关的数据，而</li>
<li>内部总线负责各部件间信息的传递，而</li>
<li>控制器不仅要保证指令的正确执行，还要能够处理异常事件。</li>
</ul>
</blockquote>

        <h3 id="9面向对象的基本概念">
          <a href="#9面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>9.面向对象的基本概念</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327210157.png" alt></p>

        <h4 id="2题目解析-9">
          <a href="#2题目解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><code>多态</code>：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。也就是说客户类其实在调用方法时，并不需要知道特定子类的实现，都会用统一的方式来调用。</p>
</blockquote>
<h4 id><a class="markdownIt-Anchor" href="#"></a> </h4>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/26/2020年02月13日软件设计师每日一练/">2020年02月13日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-26</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1编译与解释">
          <a href="#1编译与解释" class="heading-link"><i class="fas fa-link"></i></a>1.编译与解释</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326182818.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>​    死循环错误属于典型的<strong>语义错误</strong>，但静态的语义错误可被编译器发现，到程序真正陷入死循环说明编译器并未发现，所以属于动态语义错误。</p>
</blockquote>

        <h3 id="2软件维护类型">
          <a href="#2软件维护类型" class="heading-link"><i class="fas fa-link"></i></a>2.软件维护类型</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326182938.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>软件维护的内容一般包括</p>
<p>准确性维护》适应性维护》完善性维护》预防性维护。</p>
<ul>
<li>正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</li>
<li>适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。</li>
<li>完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</li>
<li>预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。</li>
</ul>
</blockquote>

        <h3 id="3软件测试">
          <a href="#3软件测试" class="heading-link"><i class="fas fa-link"></i></a>3.软件测试</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183158.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>软件测试方法分为静态测试和动态测试。</p>
<ul>
<li>静态测试是被测试程序不在机器上运行而采用人工检测和计算机辅助静态分析手段对程序进行检测。</li>
<li>动态测试是通过运行程序发现错误，对软件产品进行动态测试时可以采用黑盒测试和白盒测试法。</li>
</ul>
<p>黑盒测试法在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。对于无法获得源代码的第三方组件，可采用黑盒对组件进行测试。基本路径覆盖、分支覆盖和环路覆盖需要根据程序的内部结构和逻辑进行测试。</p>
</blockquote>

        <h3 id="4银行家算法">
          <a href="#4银行家算法" class="heading-link"><i class="fas fa-link"></i></a>4.银行家算法</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183617.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183719.png" alt></p>
</blockquote>

        <h3 id="5uml">
          <a href="#5uml" class="heading-link"><i class="fas fa-link"></i></a>5.UML</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183749.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><strong>部署图</strong>展现了运行处理节点以及其中的构件的配置。</p>
<p>部署图给出了体系结构的静态实施视图。它与构件视图相关，通常一个结点包含一个或多个构件。部署图一般描述的是代码或系统在实施中的物理节点分布，组件之间的依赖关系类似于包依赖。</p>
</blockquote>

        <h3 id="6总线系统">
          <a href="#6总线系统" class="heading-link"><i class="fas fa-link"></i></a>6.总线系统</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183909.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>​	总线是在计算机中连接两个或多个功能部件的一组共享的<strong>信息传输线</strong>，它的主要特征就是多个部件共享传输介质。它是构成计算机系统的骨架，是各个功能部件之间进行信息传输的公共通道，借助总线的连接，计算机各个部件之间可以传送地址、数据和各种控制信息。</p>
<p>在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以有效减少信息传输线的数量。</p>
</blockquote>

        <h3 id="7树与二叉树">
          <a href="#7树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>7.树与二叉树</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184026.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<ol>
<li>先序遍历即先根后左子树再右子树，</li>
<li>中序遍历为先左子树后跟再右子树。</li>
</ol>
<p>先序遍历的最开始结点A即为整棵树的根，结合中序遍历，A结点左侧B即为根节点A的左子树，右侧DCFE则为A的右子树，同理可以得出C为A的右子树的根节点,D为C的左子树，EF为C的右子树，F为E的左子树。可以得到如下图，所以该二颗树的高度为4。</p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184114.png" alt></p>
</blockquote>

        <h3 id="8正规式">
          <a href="#8正规式" class="heading-link"><i class="fas fa-link"></i></a>8.正规式</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184210.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>根据图中展示，其正规式应以a开头，a结尾，b可以出现0次或多次，所以是 ab*a，基本上可以排除BCD三项，答案为A。</p>
</blockquote>

        <h3 id="9操作系统">
          <a href="#9操作系统" class="heading-link"><i class="fas fa-link"></i></a>9.操作系统</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184259.png" alt></p>

        <h4 id="2题目解析-9">
          <a href="#2题目解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查的是操作系统中文件管理的基本知识。<br></p>
<p>在使用已经存在的文件之前，要通过“打开(open )”文件操作建立起文件和用户之间的联系，目的是把文件的<strong>控制管理信息从辅存读到内存</strong>。打开文件应完成如下功能：<br></p>
<ul>
<li>在内存的管理表中申请一个空表目，用来存放该文件的文件目录信息。<br></li>
<li>根据文件名在磁盘上查找目录文件。将找到的文件目录信息复制到内存的管理表中。如果打开的是共享文件，则应进行相关处理，如共享用户数加t。<br></li>
<li>文件定位，卷标处理。<br></li>
<li>文件一旦打开，可被反复使用直至文件关闭。这样做的优点是减少查找目录的时间，加快文件存取速度，提高系统的运行效率。因此，本题的正确答案为B。</li>
</ul>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/25/2020年02月12日软件设计师每日一练/">2020年02月12日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1软件保护期限">
          <a href="#1软件保护期限" class="heading-link"><i class="fas fa-link"></i></a>1.软件保护期限</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213244.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>我国《著作权法》对著作权的保护期限作了如下规定: (1)著作权中的署名权、修改权、保护作品完整权的保护期不受限制。</p>
</blockquote>

        <h3 id="2专业英语">
          <a href="#2专业英语" class="heading-link"><i class="fas fa-link"></i></a>2.专业英语</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213355.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>不变只是愿望，变化才是永恒。—SWIFT<br></p>
<p>​		一个接一个的软件项目都是一开始设计算法，然后将算法应用到待发布的软件中，接着根据时间进度把第一次开发的产品发布给客户。<br></p>
<p>​		对于大多数项目，第一个开发的系统并不适用。它可能太慢、太大、难以使用，或者三者兼有。要解决所有的问题，除了重新开始以外，没有其他的办法—即开发一个更灵巧或者更好的系统。系统的丢弃和重新设计可以一步完成，也可以一块块地实现。所有大型系统的经验都显示，这是必须完成的步骤。而且，新的系统概念或新技术会不断出现，因此开发的系统必须被抛弃，但即使是最优秀的项目计划也不能无所不知地在最开始就解决这些问题。<br></p>
<p>​		因此，管理上的问题不再是“是否构建一个实验性的系统，然后抛弃它”，你必须这样做。现在的问题是“是否预先计划抛弃原型的开发，或者是否将该原型发布给用户”。从这个角度看待问题，答案更加清晰。将原型发布给用户，虽然可以获得时间，但是其代价高昂—对于用户，使用极其痛苦；对于重新开发的人员，分散了精力；对于产品，影响了声誉，即使是最好的再设计也难以挽回名声。<br><br>
因此，为舍弃而计划，无论如何，你一定要这样做。<br><br>
​</p>
</blockquote>

        <h3 id="3颜色深度">
          <a href="#3颜色深度" class="heading-link"><i class="fas fa-link"></i></a>3.颜色深度</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213520.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p><code>颜色深度</code>是表示位图图像中单个像素的颜色或灰度所占的位数，8位的颜色深度，表示每个像素有8位颜色位，可表示256种不同的颜色。存储位图图像的数据量与图像大小有关。而位图图像的大小与分辨率、颜色深度有关。本题图像的垂直方向分辨率为640像素，水平方向分辨率为480，颜色深度为8位，则该图像所需存储空间为（640×480× 8 ）/8 （Byte） = 307200（Byte）。经5：1压缩后，该图像所需存储空间为307200/5 =61440（Byte）。</p>
</blockquote>

        <h3 id="4gant-和pert图">
          <a href="#4gant-和pert图" class="heading-link"><i class="fas fa-link"></i></a>4.Gant 和Pert图</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214024.png" alt></p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214105.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214129.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214153.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>在软件项目的活动图中，从开始结点到结束结点，<strong>耗时最长的一条路径称为关键路径</strong>。在本题中，关键路径为：A-C-G-J-K。所以备选答案中的C是属于关键路径上的里程碑。</p>
<p>题目中提到“活动AD在活动AC开始3天后才开始，而完成活动DG过程中，由于有临时事件发生，实际需要15天才能完成”，所以可以将AD活动由原来的10天延长至13天，而DG活动由原来的10天延长至15天，此时计算出来的关键路径比原来长了3天，所以整个项目的最短工期会延长3天。</p>
</blockquote>

        <h3 id="5广义表">
          <a href="#5广义表" class="heading-link"><i class="fas fa-link"></i></a>5.广义表</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214314.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查数据结构基础知识。</p>
<p>链表是<strong>最灵活的存储结构</strong>，它允许同一个表中的结点类型可以不一致。静态数组是固定长度的数组，动态数组允许扩容，但是数组中的元素必须是相同类型的，这不适用于广义表。散列表的特点是元素的存储位置与其关键字值相关。</p>
</blockquote>

        <h3 id="6面向对象的基本概念">
          <a href="#6面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>6.面向对象的基本概念</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214504.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查面向对象基本概念中对象类之间的关系。泛化概化关系表示把几类对象类的公共属性和行为抽象成超类，然后其属性和方法被那些子类继承；聚合关系表示一个较大的“整体”类包含一个或多个较小的“部分”类；合成关系则表示关系中“整体”负责其“部分”的创建和销毁，如果“整体”不存在了，“部分”也将不存在。</p>
</blockquote>

        <h3 id="7程序设计思维">
          <a href="#7程序设计思维" class="heading-link"><i class="fas fa-link"></i></a>7.程序设计思维</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214610.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>一个模块的独立度通常使用聚合和祸合程度来度量。聚合衡量模块内部各元素结合的紧密程度：祸合度量不同模块间互相依赖的程度。提高聚合程度，降低模块之间的祸合程度是模块设计应该遵循的最重要的两个原则。聚合与祸合是相辅相成的两个设计原则，模块内的高聚合往往意味着模块之间的松祸合。而要想提高模块内部的聚合性，必须减少模块之间的联系。</p>
</blockquote>

        <h3 id="8文法重点">
          <a href="#8文法重点" class="heading-link"><i class="fas fa-link"></i></a>8.文法（重点）</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214707.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>
 &nbsp;&nbsp;&nbsp; 本题考查语言结构的文法表示。<br>
 &nbsp;&nbsp;&nbsp; 推导就是用产生式的右部替换产生式左部符号。从文法的开始符号出发，不能推导出“（（a，f）） ”、“（abc）”、 “（c，（da））”，产生符号串“（（fac，bb），g）”的最左推导过程如下：<br>
 　　S=&gt;（S，M）=&gt;（（S，M），M）=&gt;（（M，M），M）=&gt;（（MP，M）， M）=&gt;（（MPP， M），M ）<br>
 　　&nbsp;=&gt; （（PPP， M）， M）=&gt;（（fPP， M）， M）=&gt;（（faP， M）， M）”（（fac， M， M）=&gt;（（fac， MP），M）<br>
 　　&nbsp;=&gt; （（faa， PP）， M） =&gt; （（fac， bP）， M）=&gt;（（fac， bb）， M）=&gt;（（fac，bb），g））</p>
</blockquote>

        <h3 id="9侵权判断">
          <a href="#9侵权判断" class="heading-link"><i class="fas fa-link"></i></a>9.侵权判断</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214818.png" alt></p>

        <h4 id="2题目解析-9">
          <a href="#2题目解析-9" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>本题考查知识产权中关于软件著作权方面的知识。<br><br>
&nbsp;&nbsp;&nbsp; 著作权因作品的完成而自动产生，不必履行任何形式的登记或注册手续，也不论其是否已经发表，所以甲对该软件作品享有著作权。乙未经甲的许可擅自使用甲的软件作品的行为，侵犯了甲的软件著作权。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/24/2020年02月11日软件设计师每日一练/">2020年02月11日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">3.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">18分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1媒体的种类">
          <a href="#1媒体的种类" class="heading-link"><i class="fas fa-link"></i></a>1.媒体的种类</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214951.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<ul>
<li>
<p>感觉媒体：指人们接触信息的感觉形式。如：视觉、听觉、触觉、嗅觉和味觉等。</p>
</li>
<li>
<p>表示媒体：指信息的表示形式。如：文字、图形、图像、动画、音频和视频等。</p>
</li>
<li>
<p>显示媒体（表现媒体）：表现和获取信息的物理设备。如：输入显示媒体键盘、鼠标和麦克风等；输出显示媒体显示器、打印机和音箱等。</p>
</li>
<li>
<p>存储媒体：存储数据的物理设备，如磁盘、光盘和内存等。</p>
</li>
<li>
<p>传输媒体：传输数据的物理载体，如电缆、光缆和交换设备等。</p>
</li>
</ul>
</blockquote>

        <h3 id="2数据库设计">
          <a href="#2数据库设计" class="heading-link"><i class="fas fa-link"></i></a>2.数据库设计</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215311.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215340.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>答案 BADC</p>
<p>试题（53）的正确选项为B。根据题意，零件P关系的主键为（零件号，供应商）。<br></p>
<p>试题（54）的正确选项为A，试题（55）的正确选项为D。试题要求查询各种零件的平均单价、最高单价与最低单价之间差距，因此，首先需要在结果列中的空（54）填写“零件名称，AVG（单价），MAX（单价）-MIN（单价）”。其次必须用分组语句按零件号分组，</p>
<p>故空（55）应填写“GROUP BY零件号”。完整的SQL语句为：<br><br>
　　　　　SELECT 零件号，零件名称，AVG（单价），MAX（单价）-MIN（单价）<br><br>
&nbsp;　　　　 FROM P<br><br>
&nbsp; 　　　　GROUP BY零件号；<br></p>
<p>试题（56）的正确选项为C。为了解决关系P存在冗余以及插入异常和删除异常等问题，需要将零件关系P分解。选项A、选项B和选项D是有损连接的，且不保持函数依赖故分解是错误的，例如，分解为选项A、选项B和选项D后，用户无法查询某零件由哪些供应商供应，原因是分解是有损连接的，且不保持函数依赖。</p><p></p>
</blockquote>

        <h3 id="3编译与解释">
          <a href="#3编译与解释" class="heading-link"><i class="fas fa-link"></i></a>3.编译与解释</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215559.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>答案 A</p>
<p><strong>词法分析阶段</strong>，其任务是从左到右逐个字符地读入源程序，对构成源程序的<strong>字符流</strong>进行扫描和分解，从而识别出一个个单词（也称单词符号或符号）。这里所谓的单词是指逻辑上紧密相连的一组字符，这些字符组合在一起才表示某一含义。</p>
<p>词法分析过程依据的是语言的<strong>词法规则</strong>，即描述“单词” 分析构成程序的字符及由字符按照构造规则构成的符号是否符合程序语言的规定 ”是对单词的检查。</p>
<p><strong>语法分析的任务</strong>是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如“表达式”“语句”和“程序”等。语法规则就是各类语法单位的构成规则。</p>
<p><strong>语义分析阶段</strong>分析各语法结构的含义，检查源程序是否包含静态语言错误，并收集类型信息供后面的代码生成阶段使用。</p>
</blockquote>

        <h3 id="4uml">
          <a href="#4uml" class="heading-link"><i class="fas fa-link"></i></a>4.UML</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220031.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>在UML中，关联的多重度是指一个类的实例能够与另一个类的多少个实例<strong>相关联</strong>。它又称为<strong>重复度</strong>。多重度表示为一个整数范围n…m，整数n定义所连接的最少对象的数目，而m则为最多对象数（当不知道确切的最大数时，最大数用<em>号表示）。最常见的多重性有0…1、0…</em>、1…1和1…*。</p>
</blockquote>

        <h3 id="5mccabe度量法">
          <a href="#5mccabe度量法" class="heading-link"><i class="fas fa-link"></i></a>5.McCabe度量法</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220151.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>​	本题考查McCabe度量法。McCabe度量法是通过定义<strong>环路复杂度</strong>，建立程序复杂性的度量，它基于一个程序模块的程序图中环路的个数。</p>
<p>画图法 》 E 、G 自环  （C D E F  环） （ B C E F 环） 添一条起点 终点环  》环数 5</p>
<p>计算有向图G的环路复杂性的公式为V(G)=m-n+2，</p>
<p>其中V(G)是有向图G中的环路个数，m是G中的<strong>有向弧数</strong>（两节点之间的连线），n是G中的节点数。要采用McCabe度量法度量程序复杂度，需要先画出程序图，识别有向图中节点数n=7和有向弧数m=10，然后利用环路复杂性计算公式V(G)=m-n+2进行计算，得到图中程序图的程序复杂度是5。</p>
</blockquote>

        <h3 id="6软件过程改进">
          <a href="#6软件过程改进" class="heading-link"><i class="fas fa-link"></i></a>6.软件过程改进</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220740.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>《软件设计师教程（第5版）》P247页：</p>
<ul>
<li>CL0（未完成的）：过程域未执行或未得到CL1中定义的所有目标。<br></li>
<li>CL1（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。<br></li>
<li>CL2（已管理的）：其共性目标是集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制、和评审。<br></li>
<li>CL3（已定义级的）：其共性目标集中于已定义的过程的制度化。过程是按照组织的裁剪指南从组织的标准过程中裁剪得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。<br></li>
<li>CL4（定量管理的）：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的质量目标作为管理准则。<br></li>
<li>CL5（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户的改变和持续改进计划中的过程域的功效。<br></li>
</ul>
</blockquote>

        <h4 id="3cmmi-知识引申">
          <a href="#3cmmi-知识引申" class="heading-link"><i class="fas fa-link"></i></a>3.CMMI 知识引申</h4>
      
<blockquote>
<p>CMMI的全称为Capability Maturity Model Integration，即能力成熟度模型集成。CMMI是CMM模型的最新版本。早期的CMMI（CMMI-SE/SW/IPPD），SEI在部分国家和地区开始推广和试用。随着应用的推广与模型本身的发展，演绎成为一种被广泛应用的综合性模型。 [1]</p>
<p><strong>级别</strong></p>
<ul>
<li>CMMI共有5个级别，代表软件团队能力成熟度的5个等级，数字越大，成熟度越高，高成熟度等级表示有比较强的软件综合开发能力。</li>
<li>CMMI一级，执行级。在执行级水平上，软件组织对项目的目标与要做的努力很清晰，项目的目标可以实现。但是由于任务的完成带有很大的偶然性，软件组织无法保证在实施同类项目时仍然能够完成任务。项目实施能否成功主要取决于实施人员。</li>
<li>CMMI二级，管理级。在管理级水平上，所有第一级的要求都已经达到，另外，软件组织在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对项目相关的实施人员进行了相应的培训，对整个流程进行监测与控制，并联合上级单位对项目与流程进行审查。二级水平的软件组织对项目有一系列管理程序，避免了软件组织完成任务的随机性，保证了软件组织实施项目的成功率。</li>
<li>CMMl三级，明确级。在明确级水平上，所有第二级的要求都已经达到，另外，软件组织能够根据自身的特殊情况及自己的标准流程，将这套管理体系与流程予以制度化。这样，软件组织不仅能够在同类项目上成功，也可以在其他项目上成功。科学管理成为软件组织的一种文化，成为软件组织的财富。</li>
<li>CMMI四级，量化级。在量化管理级水平上，所有第三级的要求都已经达到，另外，软件组织的项目管理实现了数字化。通过数字化技术来实现流程的稳定性，实现管理的精度，降低项目实施在质量上的波动。</li>
<li>CMMI五级，优化级。在优化级水平上，所有第四级的要求都已经达到，另外，软件组织能够充分利用信息资料，对软件组织在项目实施的过程中可能出现的次品予以预防。能够主动地改善流程，运用新技术，实现流程的优化。</li>
</ul>
<p>由上述的5个级别可以看出，每一个级别都是更高一级的基石。要上高层台阶必须首先踏上所有下层的台阶</p>
<p><strong>作用</strong></p>
<p>很多软件企业纷纷实施CMMI管理模式，不少企业如：东软、托普、华为等企业通过了三级或四级评估。这一方面反映了我国企业在进入WTO后的危机意识，以及与世界接轨的迫切愿望。另一方面则反映出我国软件企业在改进管理方法上所作的努力。但是CM-MI到底能够为我们做什么呢？实际上这个问题对不同的人有不同的答案。对采购部门的人员来说，掌握了CMMI技术可以有目的地考察项目实施人员或公司的实施能力，从而保证所采购的项目能够顺利完成。对于项目经理来说，掌握CMMl技术能够提高自己的项目管理能力，从而能够使项目高质量、低成本、按期限地完成。对于企业领导人来说，CMMI技术不仅能够提升企业的管理水平，还能够引入科学的管理理念，提升企业的整体管理水平。</p>
<p>在美国，很多企业通过CMMI评估一方面为了满足承包国防工程或一些大企业的工程的要求，另一方面也是为了提高企业自身的管理能力。美国政府的工程项目，绝大多数都要求承包商具有一定的CMMI级别作为参加投标的资格。越来越多的大型企业业开始要求其工程承包商具有一定的CMMl级别。级别高的企业在赢得项目的竞标中具有一定的优势。因此，如果没有CMMI的等级评估，企业就会失去很多商机</p>
<p><strong>应用</strong></p>
<p>CMMI是一个庞大的过程元模型，自发布以来在世界软件界产生了巨大的影响。CMMI等级评估已经成为业界公认的标准，CMMI的证书成了一个企业或组织能力和形象的标志，没有这个证书不仅难以获得国外项目，甚至也难以在国内一些项目的竞标中获胜。CMMI适合企业操作，避免了某些管理体系只重理论而忽视实践的缺陷。在我国，随着媒体的宣传和政府的支持，许多企业引入了CMMI咨询和认证，对于整个软件行业的管理提升及研发效率提高起到了很大的帮助作用。但也有一些企业引入CMMI体系后，只留下一些形式上的开发流程和文档模板，在管理上并无实质性改进。对于CMMI，业界一直存在着两种声音，有人认为CMMI执行过度，得不偿失；也有人说它过于通用，实用价值不大；但多数人还是认同它，并根据需要加以应用。 [3]</p>
</blockquote>

        <h3 id="7后缀表达式">
          <a href="#7后缀表达式" class="heading-link"><i class="fas fa-link"></i></a>7.后缀表达式</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325221240.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>后缀表示也称为表达式的逆波兰表示。在这种表示方法中，将运算符号写在运算对象的后面，表达式中的运算符号按照计算次序书写。</p>
<p>对于表达式x-(y+c)<em>8，先计算y与c的和，再乘以8，最后用x减去这个这个计算，因此其后缀式为xyc+8</em>-。</p>
</blockquote>

        <h3 id="8编译与解析">
          <a href="#8编译与解析" class="heading-link"><i class="fas fa-link"></i></a>8.编译与解析</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325221347.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<blockquote>
<p>对C源程序进行编译时，</p>
<ol>
<li>需建立符号表，其作用是记录源程序中各个符号（变量等）的必要信息，</li>
<li>以辅助语义的正确性检查和代码生成，</li>
<li>在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。</li>
<li>符号表的建立可以始于<strong>词法分析阶段</strong>，也可以放到<strong>语法分析和语义分析阶段</strong>，但符号表的使用有时会延续到目标代码的运行阶段。</li>
</ol>
</blockquote>
<h4 id><a class="markdownIt-Anchor" href="#"></a> </h4>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/23/后缀表达式算法/">后缀表达式算法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1概念解析">
          <a href="#1概念解析" class="heading-link"><i class="fas fa-link"></i></a>1.概念解析</h3>
      
<p>​	实现逆波兰式的算法，难度并不大，但为什么要将看似简单的中序<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>转换为复杂的逆波兰式？原因就在于这个简单是相对人类的思维结构来说的，对计算机而言中序表达式是非常复杂的结构。相对的，逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的内存结构是栈式结构，它执行先进后出的顺序。</p>

        <h3 id="2实现算法">
          <a href="#2实现算法" class="heading-link"><i class="fas fa-link"></i></a>2.实现算法</h3>
      
<p>1.算法一</p>
<blockquote>
<ol>
<li>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</li>
<li>从左至右扫描中缀表达式；</li>
<li>遇到操作数时，将其压s2；</li>
<li>遇到运算符时，比较其与s1栈顶运算符的优先级：<br>
1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；<br>
2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；<br>
3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</li>
<li>遇到括号时：(1) 如果是左括号“(”，则直接压入s1(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
<li>重复步骤2至5，直到表达式的最右边</li>
<li>将s1中剩余的运算符依次弹出并压入s2</li>
<li>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</li>
</ol>
</blockquote>
<p>2.算法2</p>
<blockquote>
<p>将一个普通的中序<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>转换为<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">逆波兰表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的一般算法是：</p>
<p>首先需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：</p>
<p>（1）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0" target="_blank" rel="noopener">操作数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则分析出完整的运算数，该操作数直接送入S2栈</p>
<p>（2）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener">运算符</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则将该运算符与S1栈栈顶元素比较，如果该<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noopener">运算符优先级</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>(不包括括号运算符)大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，最后将该运算符送入S1栈。</p>
<p>（3）若取出的字符是“（”，则直接送入S1栈顶。</p>
<p>（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88" target="_blank" rel="noopener">出栈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，依次送入S2栈，此时抛弃“（”。</p>
<p>（5）重复上面的1~4步，直至处理完所有的输入字符</p>
<p>（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。</p>
<p>完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算了！</p>
</blockquote>

        <h3 id="3java-代码实现">
          <a href="#3java-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.Java 代码实现</h3>
      
<pre><code>	package DataStructures.Stack;

    import java.util.Stack;

    /**
     * @author yichangkong
     * @create 2020-03-21-22:47
     * 中缀表达式转后缀表达式
     */
    public class PolandNotaion {

        public static void main(String[] args) {

            //初始化两栈 S1 S2
            Stack&lt;String&gt; operatStack = new Stack();//；零时存取运算符
            Stack&lt;String&gt; polanStack = new Stack();//逆波兰表达式


            //测试案例
            String expersstion = "1 + ( ( 2 + 3 ) * 4 ) - 5";

            String[] arrayStr = expersstion.split(" ");//转换为字符串数组进行从左至右遍历扫描

            int size = arrayStr.length;//11

            System.out.println(size);

            boolean flag = true;


            for (int index = 0; index &lt; size; index++) {

                String str = arrayStr[index];

                //遇到操作数
                if (isNum(str)) {

                    polanStack.push(str);

                } else {//如果是操作符
                    if (operatorLevel(str) == 1) {
                        //(1) 如果是左括号“(”，则直接压入s1
                        if (str.equals("(")) {
                            operatStack.push(str);
                        } else {
                            //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                            boolean f1 = true;
                            while (f1) {

                                String s = operatStack.peek();
                                if (s.equals("(")) {
                                    operatStack.pop();
                                    f1 = false;
                                } else {
                                    polanStack.push(operatStack.pop());
                                }
                            }
                        }
                    } else {
                        flag = true;
                        while (flag) {
                            if (operatStack.size() == 0 || operatStack.peek().equals("(")) {//如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈
                                //直接入S1
                                operatStack.push(str);
                                flag = false;
                            } else {
                                int L1 = operatorLevel(str);
                                int L2 = operatorLevel(operatStack.peek());
                                //2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；
                                if (L1 &lt; L2) {
                                    operatStack.push(str);

                                    System.out.println("L!");
                                    flag = false;
                                } else { //3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较
                                    polanStack.push(operatStack.pop());
                                }
                            }
                        }
                    }
                }
            }

            while (operatStack.size() != 0) {
                polanStack.push(operatStack.pop());
            }
            System.out.println(polanStack);
        }


        //判断方法 检验输入的符号是否为数
        static public boolean isNum(String string) {

            if (operatorLevel(string) &gt; 4) {

                int num = Integer.parseInt(string);

                if (num &lt;= 9 || num &gt;= 0) {
                    return true;//是数字
                }
            }
            return false;//符号

        }


        //优先级 运算符 1 &gt; 2 &gt; 3 &gt;4
        static public int operatorLevel(String string) {

            switch (string) {
                case "(":
                    return 1;
                case ")":
                    return 1;

                case "+":
                    return 3;
                case "-":
                    return 3;
                case "*":
                    return 2;
                case "/":
                    return 2;
                case "#":
                    return 4;
                default:
                    return 5;
            }

        }
    }
</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/23/2020年02月10日软件设计师每日一练/">2020年02月10日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">17分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1软件的可维护性">
          <a href="#1软件的可维护性" class="heading-link"><i class="fas fa-link"></i></a>1.软件的可维护性</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210023.png" alt></p>
<p>2.题目解析</p>
<p>本题考查系统的可维护性评价指标。系统的可维护性可以定性地定义为:维护人员理解、改正、改动和改进这个软件的难易程度，其评价指标包括可<code>理解性</code>、<code>可测试性</code>和<code>可修改性</code>。</p>

        <h3 id="2数据的表示">
          <a href="#2数据的表示" class="heading-link"><i class="fas fa-link"></i></a>2…数据的表示</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210127.png" alt></p>
<p>2.题目解析</p>
<p>答案 D</p>
<p>在计算机中，n位补码（表示数据位），表示范围是-2<sup>n-1</sup>~+2<sup>n-1</sup>-1，其中最小值为人为定义，以n=8为例，其中-128的补码是人为定义的1000 0000。<br></p>

        <h3 id="3常用命令">
          <a href="#3常用命令" class="heading-link"><i class="fas fa-link"></i></a>3.常用命令</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210258.png" alt></p>
<p>2.题目解析</p>
<p>ipconfig/all能为DNS和WINS服务器显示它已配置且所要使用的附加信息（如IP地址等），并且显示内置于本地网卡中的物理地址。<br><br>
ipconfig/release也只能在向DHCP服务器租用其IP地址的计算机上起作用。如果你输入ipconfig /release，那么所有接口的租用IP地址便重新交付给DHCP服务器。<br><br>
/reset和/reload为干扰项，ipconfig不支持这两个参数。<br></p>

        <h3 id="4保护范围和对象">
          <a href="#4保护范围和对象" class="heading-link"><i class="fas fa-link"></i></a>4.保护范围和对象</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210448.png" alt></p>
<p>2.题目解析</p>
<p>根据我国《著作权法》的规定，有三种类型的作品不受法律保护。 第一种是依法禁止出版、传播的作品。 第二种是不适用于《著作权法》的作品。它们包括下列作品：</p>
<div>
	（1）法律、法规，国家的决议、决定、命令和其他具有立法、行政、司法性质的文件，极其官方正式译文；</div>
<div>
	（2）时事新闻；</div>
<div>
	（3）历法、通用数表、通用表格和公式。</div>
<div>
	国务院颁布的《计算机软件保护条例》属于法律法规，所以不受著作权法保护。</div>

        <h3 id="5软件测试">
          <a href="#5软件测试" class="heading-link"><i class="fas fa-link"></i></a>5.软件测试</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210546.png" alt></p>
<p>2.题目解析</p>
<p>&nbsp;在单元测试开始时，应该对通过所有被测模块的数据流进行测试。<br><br>
①输入参数是否与形式参数是否一致。<br><br>
②调用模块的实参与被调用模块形参是否一致。<br><br>
③全局变量在各模块中的定义和用法是否一致<br><br>
④外部输入、输出等等。</p>

        <h3 id="6软件测试">
          <a href="#6软件测试" class="heading-link"><i class="fas fa-link"></i></a>6.软件测试</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210637.png" alt></p>
<p>2.题目解析</p>
<p>根据等价类划分的原则，如果规定了输入数据的范围，则可划分为1个有效等价类和2个无效等价类。学生年龄的输入范围为16~40，则有效等价类为16≤年龄≤40，两个无效等价类为年龄&gt;40或年龄&lt;16。</p>

        <h3 id="7面向对象的基本概念">
          <a href="#7面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>7.面向对象的基本概念</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210922.png" alt></p>
<p>2.题目解析</p>
<p>面向对象系统中的封装单位是对象，对象之间只能通过接口进行信息交流，对象外部不能对对象中的数据随意地进行访问。封装是一种信息隐藏技术，目的是使对象的定义和实现分离，这样，就能减少耦合，类内部的实现可以自由改变而不会影响其他的类或对象。</p>

        <h3 id="8校验码">
          <a href="#8校验码" class="heading-link"><i class="fas fa-link"></i></a>8.校验码</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211037.png" alt></p>
<p>2.题目解析</p>
<p>采用模二除法运算的只有循环冗余检验CRC。</p>

        <h4 id="3校验方法">
          <a href="#3校验方法" class="heading-link"><i class="fas fa-link"></i></a>3.校验方法</h4>
      
<blockquote>
<p>常用的几种数据校验方式有奇偶校验、CRC校验、LRC校验、格雷码校验、和校验、异或校验等</p>
<p>一、奇偶校验</p>
<ol>
<li>定义</li>
</ol>
<p>根据被传输的一组二进制代码中“1”的个数是奇数或偶数来进行校验。</p>
<p>使用：通常专门设置一个奇偶校验位，存放代码中“1”的个数为奇数还是偶数。若用奇校验，则奇偶校验位为奇数，表示数据正确。若用偶校验，则奇偶校验位为偶数，表示数据正确。</p>
<ol start="2">
<li>应用</li>
</ol>
<p>eg.  数据位为 10001100 （1）  -&gt; 最后一位为校验位</p>
<p>此时若约定好为奇校验，那么数据表示为正确的，若为偶校验，那么数据传输出错了。</p>
<p>二、CRC校验（循环冗余校验码）</p>
<ol>
<li>定义</li>
</ol>
<p>CRC校验是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p>
<ol start="2">
<li>计算过程：<br>
a&gt; 设置CRC寄存器，并给其赋值FFFF(hex)。<br>
b&gt; 将数据的第一个8-bit字符与16位CRC寄存器的低8位进行异或，并把结果存入CRC寄存器。<br>
c&gt; CRC寄存器向右移一位，MSB补零，移出并检查LSB。<br>
d&gt; 如果LSB为0，重复第三步；若LSB为1，CRC寄存器与多项式码相异或。</li>
</ol>
<p>e&gt; 重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。</p>
<p>f&gt; 重复第2至第5步直到所有数据全部处理完成。</p>
<p>g&gt; 最终CRC寄存器的内容即为CRC值。</p>
<p>常用的CRC循环冗余校验标准多项式如下：   CRC(16位) = X16+X15+X2+1   CRC(CCITT) = X16+X12 +X5+1<br>
CRC(32位) = X32+X26+X23+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1<br>
以CRC(16位)多项式为例，其对应校验二进制位列为1 1000 0000 0000 0101。</p>
<ol start="3">
<li>应用：在发送端根据要传送的k位二进制码序列，以一定的规则产生一个校验用的r位监督码(CRC码)，附在原始信息后边，构成一个新的二进制码序列数共k+r位，然后发送出去。在接收端，根据信息码和CRC码之间所遵循的规则进行检验，以确定传送中是否出错。</li>
</ol>
<p>三、LRC校验</p>
<ol>
<li>
<p>定义：LRC校验用于ModBus协定的ASCII模式，这各校验比较简单，通讯速率较慢，它在ASCII协议中使用，检测了消息域中除开始的冒号及结束的回车换行号外的内容。它仅仅是把每一个需要传输的数据字节迭加后取反加1即可。</p>
</li>
<li>
<p>应用</p>
</li>
</ol>
<p>eg. 5个字节：01H+03H+21H+02H+00H+02H = 29H，然后取2的补码=D7H。</p>
<p>四、格雷码校验</p>
<ol>
<li>定义</li>
</ol>
<p>格雷码是一种无权码，也是一种循环码。是指任意两组相邻的代码之间只有一位不同，其余为都相同。</p>
<p>如：5的二进制为0101    6的二进制为0110</p>
<pre><code>    5的格雷码为0111    6的二进制为0101
</code></pre>
<p>五、校验和</p>
<ol>
<li>定义</li>
</ol>
<p>校验一组数据项的和是否正确。通常是以十六进制为数制表示的形式。如果校验和的数值超过十六进制的FF，也就是255。</p>
<ol start="2">
<li>应用</li>
</ol>
<p>eg. 数据01020304的校验和为a。</p>
<p>六、异或校验</p>
<ol>
<li>定义</li>
</ol>
<p>BCC校验其实是奇偶校验的一种，但也是经常使用并且效率较高的一种。所谓BCC校验法，就是在发送前和发送后分别把BCC以前包括ETX字符的所有字符按位异或后，按要求变换(增加或去除一个固定的值)后所得到的字符进行比较。相等即认为通信无错误，不相等则认为通信出错。</p>
<p>七、MD5校验</p>
<ol>
<li>定义</li>
</ol>
<p>MD5的实际应用是对一段Message(字节串)产生fingerprint(指纹)，可以防止被篡改。</p>
</blockquote>

        <h3 id="9网络攻击">
          <a href="#9网络攻击" class="heading-link"><i class="fas fa-link"></i></a>9.网络攻击</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211614.png" alt></p>
<p>2.题目解析</p>
<ol>
<li>
<p>DoS是<code>Denial of Service</code>的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</p>
</li>
<li>
<p>作个形象的比喻来理解DoS。街头的餐馆是为大众提供餐饮服务，如果一群地痞流氓要DoS餐馆的话，手段会很多，比如霸占着餐桌不结账，堵住餐馆的大门不让路，骚扰餐馆的服务员或厨子不能干活，甚至更恶劣……</p>
</li>
<li>
<p>SYN Flooding攻击便是Dos攻击的典型代表，该攻击以多个随机的源主机地址向目的路由器发送SYN包，而在收到目的路由器的SYN ACK后并不回应，这样，目的路由器就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致路由器崩溃。服务器要等待超时（Time Out）才能断开已分配的资源。</p>
</li>
</ol>

        <h3 id="10死锁">
          <a href="#10死锁" class="heading-link"><i class="fas fa-link"></i></a>10.死锁</h3>
      

        <h4 id="1题目-10">
          <a href="#1题目-10" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211851.png" alt></p>
<p>2.题目解析</p>
<p>本题考查对操作系统死锁方面基本知识掌握的程度。系统中同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m&lt;nw时，可能会引起死锁。<br></p>
<ul>
<li>情况a：m=2，n= 1，w=2，系统中有2个资源，1个进程使用，该进程最多要求2个资源，所以不会发生死锁。</li>
<li>情况b：m=2，n=2，w=1，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，所以不会发生死锁。</li>
<li>情况c：m=2，n=2，w=2，系统中有2个资源，2个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁，这时进程资源图如下图所示。<p></p></li>
</ul>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323212021.png" alt></p>
<p>情况d：m=4，n=3，w=2，系统中有4个资源，3个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个资源，此时，系统中还剩1个资源，可以使其中的一个进程得到所需资源运行完毕，所以不会发生死锁。<br>
　　情况e：m=4，n=3，w=3，系统中有4个资源，3个进程使用，每个进程最多要求3个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，第二轮系统先为一个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生列锁，这时进程资源图如下图所示。</p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323212044.png" alt></p>
<p>因此，情况c和e可能会发生死锁。</p>
<p>第二空发分析如下：</p>
<p>对于c情况，若将m加1，则情况c：m=3，n=2，w=2，系统中有3个资源，2个进程使用，每个进程最多要求2个资源，系统先为每个进程分配1个，此时，系统中还剩1个可供分配的资源，使得其中的一个进程能得到所需资源执行完，并释放所有资源使另一个进程运行完；若将w减1，则情况c：m=2，n=2，w=1，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，系统为每个进程分配1个，此时进程都能够运行完成，并释放所有资源，不会发生死锁。对于情况e与c分析同理。</p>
<p>因此，当m加1或w减1时，c和e不会发生死锁。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/22/2020年02月09日软件设计师每日一练/">2020年02月09日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-22</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">8分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1逻辑网络设计">
          <a href="#1逻辑网络设计" class="heading-link"><i class="fas fa-link"></i></a>1.逻辑网络设计</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322205126.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查的是网络系统设计原则，其中答案A不符合其中的实用性原则，</p>
<p>网络方案设计中应把握“<code>够用</code>”和“<code>实用</code>”原则。网络系统应采用成熟可靠的技术和设备，达到实用、经济和有效的目的。答案B不符合可扩展性原则，网络总体设计不仅要考虑到近期目标，也要为网络的进一步发展留有扩展的余地。</p>
<p><code>答案C说法正确</code>，符合开放性原则。答案D不正确，网络需求分析必须依赖于应用系统的需求分析。故答案选C.</p>

        <h3 id="2传值与传址">
          <a href="#2传值与传址" class="heading-link"><i class="fas fa-link"></i></a>2.传值与传址</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322205328.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>答案 C</p>
<p>传值调用最显著的特征就是被调用的函数内部对形参的修改不影响实参的值。引用调用是将实参的地址传递给形参，使得形参的地址就是实参的地址，函数中对形参的修改会导致原实参值的改变，因此可以实现实参与形参之间数据的双向传递。 在传值调用中，实参可以是变量，也可以是常量和表达式，而在传址调用中，实参不能是常量。</p>

        <h3 id="3树与二叉树">
          <a href="#3树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>3.树与二叉树</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210043.png" alt></p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210137.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210225.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210251.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210354.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>&nbsp;&nbsp;&nbsp; 本题考查哈夫曼树。<br><br>
&nbsp;&nbsp;&nbsp; 构造最优二叉树的哈夫曼算法如下。<br><br>
&nbsp;&nbsp;&nbsp; ① 根据给定的n个权值｛w1， w2，…，Wn｝构成n棵二叉树的集合F= {T1.T2，…，Tn}，其中每棵树T;中只有一个带权为w;的根结点，其左右子树均空。<br><br>
&nbsp;&nbsp;&nbsp; ② 在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，置新构造二叉树的根结点的权值为其左、右子树根结点的权值之和。<br><br>
&nbsp;&nbsp;&nbsp; ③从F中删除这两棵树，同时将新得到的二叉树加入到F中。<br><br>
&nbsp;&nbsp;&nbsp; 重复②、③，直到F中只含一棵树时为止。这棵树便是最优二叉树（哈夫曼树）。从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度是从树根到每一个结点的路径长度之和。树的带权路径长度为树中所有叶子结点的带权路径长度之和。<br><br>
&nbsp;&nbsp;&nbsp; 因此，C为最优二叉树，其带权路径长度（12+6）<em>3+15</em>2+23<em>2+29</em>2=188。<br><br>
<img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210849.png" alt></p>

        <h3 id="4多媒体技术概念">
          <a href="#4多媒体技术概念" class="heading-link"><i class="fas fa-link"></i></a>4.多媒体技术概念</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210925.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>通过话筒传入计算机的是我们人类的声音，而这种声音信号是一种连续的<code>模拟信号</code>，而非离散的数字信号，在接收到模拟信号以后，经过采样、量化等工作将模拟信号转换为数字信号在计算机中处理。</p>

        <h3 id="5有限自动机">
          <a href="#5有限自动机" class="heading-link"><i class="fas fa-link"></i></a>5.有限自动机</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211103.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查程序语言方面的基础知识。	　　对于题中自动机的状态图，先忽略状态q0的自环（识别若干个0），从初态q0到终态q1，该自动机可识别的字符串为1、101、10101、…，显然，该自动机识别的0、1串中1不能连续出现。</p>

        <h4 id="3技术引申">
          <a href="#3技术引申" class="heading-link"><i class="fas fa-link"></i></a>3.技术引申</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/lk1822791193/article/details/83343226?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">网址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="6多媒体技术">
          <a href="#6多媒体技术" class="heading-link"><i class="fas fa-link"></i></a>6.多媒体技术</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211258.png" alt></p>

        <h4 id="2题目解析-6">
          <a href="#2题目解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查计算机音乐信息处理技术的相关知识。WAV格式记录的是对于音乐信号的波形采样数据，它可以使用反映自然声音的信号采样序列来记录和回放声音信息。MIDI格式记录的是采用音乐信息序列交换的标准格式MIDI （ Musical Instrument Digital interface）标准来存贮和表达音乐的演奏信息，这些演奏信息包含每个音符演奏的时间信息、音量信息、长度信息、乐器或音色信息等，MID工消息序列可以间接反映出音乐的曲谱演奏信息。</p>

        <h3 id="7er模型">
          <a href="#7er模型" class="heading-link"><i class="fas fa-link"></i></a>7.ER模型</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211352.png" alt></p>

        <h4 id="2题目解析-7">
          <a href="#2题目解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>
	本题考查的是应试者对数据库系统中E-R模型方面的基础知识。<br>
	根据题意，学生S关系中一个学生属于一个院系，一个院系有多个学生，因此学生S和部门院系D之间是一个一对多的联系，故(a)应为1&nbsp; * ；又因为一个学生可以选择多门课程，一门课程可由多名学生选择，所以学生S和课程C关系之间是一个多对多的联系，故(b)应为* &nbsp;* 。<br>
	假设一对多联系(a)不转换为一个独立的关系模式，那么按照E-R模型向关系模型转换的规则，应当将一端的主键并入多端。所以，生成的关系模式学生S中应加入关系模式D的主键。</p>

        <h3 id="8规范化理论">
          <a href="#8规范化理论" class="heading-link"><i class="fas fa-link"></i></a>8.规范化理论</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211524.png" alt></p>

        <h4 id="2题目解析-8">
          <a href="#2题目解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>答案 D B</p>
<p>1、函数依赖关系为的函数依赖集 F={培训科目→→培训师，（学生，培训科目）→成绩，（时间，教室）→培训科目，（时间，培训师）→教室，（时间，学生）→教室}。可以得出，（时间，学生）→教室 →培训科目 →成绩 ，（时间，学生）→教室 →培训科目 →培训师时间和学生共同组合，可以推导出所有的属性，描述出所有的函数依赖关系。 所以主键是时间和学生的组合键。</p>
<p>2、存在传递函数依赖，时间和教室—&gt;培训科目； 培训科目→培训师。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/21/简单算法优化/">简单算法优化</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">52</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/21/2020年02月08日软件设计师每日一练/">2020年02月08日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-21</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">2.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">17分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1数据结构">
          <a href="#1数据结构" class="heading-link"><i class="fas fa-link"></i></a>1…数据结构</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321220324.png" alt></p>

        <h4 id="2题目解析">
          <a href="#2题目解析" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>在<code>不考虑字对齐规则</code>的情况下，C语言中一个结构体变量的存储区大小就是其所有成员所需存储区大小之和，一个联合体变量的存储区大小就是其各成员所需存储区大小中的<code>最大者</code>。因此题目中给定的联合体union T变量需要的存储区大小就是存储一个double类型变量的大小（即8字节），struct T类型变量的存储区最小应为int类型成员w存储区大小（4字节）与union T类型成员U的存储区大小之和，即12字节。</p>

        <h3 id="2uml">
          <a href="#2uml" class="heading-link"><i class="fas fa-link"></i></a>2.uml</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321220620.png" alt></p>

        <h4 id="2题目解析-2">
          <a href="#2题目解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>
	活动图可以更好地描述出行为的细节，阐明了业务用例实现的工作流程。活动图主要由以下一些元素组成：<br>
	（1）初始节点和活动终点。在活动图中有两个特殊的节点，一个用来表示活动的初始节点，它用一个实心圆表示，在一张不包括子图的活动图中有且只有一个初始节点。而另一个则是表示活动处理完成的活动终点，它用一个圆圈内加一个实心圆来表示，在活动图中可能包含多个活动终点。<br>
	（2）活动状态。是活动图中最主要的元素之一，它用来表示一个活动，如图中的a11等。<br>
	（3）转换。当一个活动结束时，控制流就会马上传递给下一个活动状态，在活动图中称之为转换，用一条带箭头的直线来表示，转移表示各种活动状态的先后顺序。<br>
	（4）分支与监护条件。对于任何一个控制流而言，都一定会存在分支、循环等形式的控制流。在活动图中，分支用一个菱形表示，它有一个进入转换（箭头从外指向分支符号），一个或多个离开转换（箭头从分支符号指向外）。而每个离开转换上都会有一个监护条件，用来表示满足什么条件的时候执行该转换。但要注意，在多个离开转换上的监护条件不能有矛盾，否则就会使得流程产生混乱。<br>
	（5）分岔与汇合。在实际的控制流中，除了顺序结构、分支结构和循环结构之外，还可能存在并发的事件流。在UML中，可以采用一个同步线来说明这些并行控制流的分岔和汇合。<br>
	在本题中，要求出那些活动是可以同时执行的，这就要求他们没有先后关系，显然选项A和C不正确，而对于D选项，a66和a77分别是判定条件连个不同结果下要执行的活动，也不是可以同时执行的活动，因此答案选B。</p>

        <h3 id="3软件开发过程基础知识">
          <a href="#3软件开发过程基础知识" class="heading-link"><i class="fas fa-link"></i></a>3.软件开发过程基础知识</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221047.png" alt></p>

        <h4 id="2题目解析-3">
          <a href="#2题目解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<ul>
<li>本题考查软件开发过程中的风险分析基础知识。<br>
风险分析包括风险识别、风险预测、风险评估和风险控制等4个不同活动，</li>
<li>​    在风险识别过程中，要识别潜在的预算、进度、个体、资源、用户和需求等方面的问题以及对整个项目的影响，并建立风险条目检查表，列出所有可能的风险事项。</li>
<li>​    在风险预测过程中，需要建立一个表示风险可能性的参考标准，描述风险条目的结果，估计风险对项目的影响等。</li>
</ul>

        <h4 id="3知识引申">
          <a href="#3知识引申" class="heading-link"><i class="fas fa-link"></i></a>3.知识引申</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/zhouzuoluo/article/details/102751168" target="_blank" rel="noopener">软件风险基础知识</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="4进程的状态">
          <a href="#4进程的状态" class="heading-link"><i class="fas fa-link"></i></a>4进程的状态.</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221454.png" alt></p>

        <h4 id="2题目解析-4">
          <a href="#2题目解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>​               在多线程运行环境中，每个线程自己独有资源很少，只有：程序计数器，寄存器和栈，其它的资源均是共享进程的，所以也只有这些独有资源是不共享的。答案 C</p>

        <h3 id="5ip地址与子网划分">
          <a href="#5ip地址与子网划分" class="heading-link"><i class="fas fa-link"></i></a>5.IP地址与子网划分</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221646.png" alt></p>

        <h4 id="2题目">
          <a href="#2题目" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>变长子网的可用主机数计算公式为2<sup>n</sup>-2（n为表示主机的位数）/26即主机位为32-26=6，所以可用主机地址为64-2=62。</p>
<p>用IP地址155.32.80.192与子网掩码进行逻辑与运算得出该IP地址所在的网络号为：155.32.80.192；所在网段的广播地址为：155.32.80.255；所以与该IP地址不在同一网段的是选项D</p>

        <h3 id="6文法">
          <a href="#6文法" class="heading-link"><i class="fas fa-link"></i></a>6.文法</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222023.png" alt></p>

        <h4 id="2题目解析-5">
          <a href="#2题目解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.题目解析</h4>
      
<p>本题考查程序语言基础知识。<br><br>
　　推导就是从文法的开始符号S出发，反复使用产生式，将产生式左部的非终结符替换为右部的文法符号序列〔展开产生式用功表示），直到产生一个终结符的序列时为止.从文法G的开始符号出发，能推导出的终结符号序列（句子）的全体称为文法G产生的语言。<br><br>
　　对于上下文无关文法S→11 | 1001|S0|SS，从S出发可推导出11，1001， 110， 1111，11110和10010等，将这些二进制序列转换成对应的十进制数可知，它们都能被3整除。</p><p></p>

        <h4 id="3知识引申编译原理文法">
          <a href="#3知识引申编译原理文法" class="heading-link"><i class="fas fa-link"></i></a>3.知识引申(编译原理——文法)</h4>
      
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/Helloyongwei/article/details/79638785" target="_blank" rel="noopener">知识博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="7软件质量保证">
          <a href="#7软件质量保证" class="heading-link"><i class="fas fa-link"></i></a>7.软件质量保证</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222412.png" alt></p>

        <h4 id="2题目-2">
          <a href="#2题目-2" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>ISO/IEC 9126软件质量模型，该模型的质量特性和质量子特性如下：<br></p>
<ol>
<li>功能性（适合性、准确性、互用性、依从性、安全性）；</li>
<li>可靠性（成熟性、容错性、易恢复性）；</li>
<li>易使用性（易理解性、易学性、易操作性）；</li>
<li>效率（时间特性、资源特性）；</li>
<li>可维护性（易分析性、易改变性、稳定性、易测试性）；</li>
<li>可移植性（适应性、易安装性、一致性、易替换性）。</li>
<li>安全性是功能特性的子特性。</li>
</ol>

        <h3 id="8后缀表达式">
          <a href="#8后缀表达式" class="heading-link"><i class="fas fa-link"></i></a>8.后缀表达式</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222904.png" alt></p>

        <h4 id="2题目-3">
          <a href="#2题目-3" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<p>参考答案 D 我是 C</p>
<p>本题考查逻辑表达式的计算及程序语言处理基础知识。<br><br>
&nbsp; “逻辑与运算”的优先级高于“逻辑或运算”。<br><br>
&nbsp; “逻辑与运算”表达式“x∧Y”的短路求值逻辑是：若x为假，则可知“x∧Y”的值为假，无需&nbsp;&nbsp;&nbsp; 再对y求值，因此只有在x为真时继续对y求值。<br><br>
&nbsp; “逻辑或运算”表达式“x∨y”的短路求值逻辑是：若x为真，则可知“x∨y”的值为真，无需再对y求值，因此只有在x为假时继续对y求值。<br><br>
&nbsp;&nbsp;&nbsp; 对于逻辑表达式“a∧b∨c∧（b ∨ x&gt;0）”，从运算符的优先级方面考虑需先对“a∧b”求值，然后对“c∧（b∨ x&gt;0）”求值，最后进行“∨”运算，因此后缀式为“ab∧cbx0&gt;∨∧∨”。</p><p></p>

        <h4 id="3算法实现">
          <a href="#3算法实现" class="heading-link"><i class="fas fa-link"></i></a>3.算法实现</h4>
      
<blockquote>
<p>将一个普通的中序<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>转换为<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">逆波兰表达式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的一般算法是：</p>
<p>首先需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：</p>
<p>（1）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0" target="_blank" rel="noopener">操作数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则分析出完整的运算数，该操作数直接送入S2栈</p>
<p>（2）若取出的字符是<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener">运算符</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，则将该运算符与S1栈栈顶元素比较，如果该<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noopener">运算符优先级</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>(不包括括号运算符)大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，最后将该运算符送入S1栈。</p>
<p>（3）若取出的字符是“（”，则直接送入S1栈顶。</p>
<p>（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88" target="_blank" rel="noopener">出栈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，依次送入S2栈，此时抛弃“（”。</p>
<p>（5）重复上面的1~4步，直至处理完所有的输入字符</p>
<p>（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。</p>
<p>完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算了！</p>
</blockquote>

        <h3 id="9专业英语">
          <a href="#9专业英语" class="heading-link"><i class="fas fa-link"></i></a>9.专业英语</h3>
      

        <h4 id="1题目-9">
          <a href="#1题目-9" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p>​	&nbsp; &nbsp; &nbsp; &nbsp;Observe that for the programmer， as for the chef， the urgency of the patron（顾客）may govern the scheduled completion of the task， but it cannot govern the actual completion. An omelette（煎鸡蛋）， promised in two minutes， may appear to be progressing nicely.But when it has not set in two minutes， the customer has two choices—waits or eats it raw.Software customers have had（ &nbsp;）choices.<br></p>
<p>​	　　Now I do not think software（ &nbsp;）have less inherent courage and firmness than chefs， nor than other engineering managers. But false（ &nbsp;）to match the patron’s desired date is much more common in our discipline than elsewhere in engineering. It is very（ &nbsp;）to make a vigorous， plausible， and job risking defense of an estimate that is derived by no quantitative method， supported by little data， and certified chiefly by the hunches of the managers.</p>
<p>​			Clearly two solutions are needed.We need to develop and publicize productivity figures， bug-incidence figures， estimating rules， and so on. The whole profession can only profit from（ &nbsp;）such data.Until estimating is on a sounder basis， individual managers will need to stiffen their backbones and defend their estimates with the assurance that their poor hunches are better than wish derived estimates.</p>

        <h4 id="2题目翻译">
          <a href="#2题目翻译" class="heading-link"><i class="fas fa-link"></i></a>2.题目翻译</h4>
      
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;观察一下编程人员，你可能会发现，同厨师一样，某项任务的计划进度，可能受限于顾客要求的紧迫程度，但紧迫程度无法控制实际的完成情况。就像约好在两分钟内完成一个煎蛋，看上去可能进行得非常好。但当它无法在两分钟内完成时，顾客只能选择等待或者生吃煎蛋。软件顾客的情况类似。<br>
	　　我现在并不认为软件经理内在的勇气和坚持不如厨师，或者不如其他工程经理。但为了满足顾客期望的日期而造成的不合理进度安排，在软件领域中却比其他的任何工程领域要普遍得多。而且，非量化方法的采用，少得可怜的数据支特，加上完全借助软件经理的直觉，这样的方式很难生产出健壮可靠和规避风险的估计。<br>
	　　显然我们需要两种解决方案。开发并推行生产率图表、缺陷率、估算规则等，整个组织最终会从这些数据的共享上获益。或者在基于可靠基础的估算出现之前，项目经理需要挺直腰杆并坚持他们的估计，确信自己的经验和直觉总比从期望得出的估计要强得多。</p>

        <h3 id="10编译与解析">
          <a href="#10编译与解析" class="heading-link"><i class="fas fa-link"></i></a>10.编译与解析</h3>
      

        <h4 id="1题目-10">
          <a href="#1题目-10" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321223914.png" alt></p>

        <h4 id="2题目-4">
          <a href="#2题目-4" class="heading-link"><i class="fas fa-link"></i></a>2.题目</h4>
      
<ol>
<li>目标代码生成阶段应考虑直接影响到目标代码速度的三个问题：</li>
<li>一是如何生成较短的目标代码；</li>
<li>二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；</li>
<li>三是如何充分利用计算机指令系统的特点，以提高目标代码的质量。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/20/2020年02月07日软件设计师每日一练/">2020年02月07日软件设计师每日一练</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2020-03-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon" data-popover="修改时间" data-popover-pos="up"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__value">2020-03-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="1面向对象的基本概念">
          <a href="#1面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1.面向对象的基本概念</h3>
      

        <h4 id="1题目">
          <a href="#1题目" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232539.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232729.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232750.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232817.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232842.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232906.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232925.png" alt></p>
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232948.png" alt></p>

        <h4 id="2解析">
          <a href="#2解析" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ul>
<li>
<p><code>开-闭原则</code>要求一个软件实体应当对扩展开放，对修改关闭。也就是说，我们在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，换句话说就是，应当可以在不必修改源代码的情况下改变这个模块的行为。<br></p>
</li>
<li>
<p><code>里氏代换原则</code>要求子类型必须能够替换它们的基类型，所以在里氏代换原则中，任何可基类对象可以出现的地方，子类对象也一定可以出现。</p>
</li>
<li>
<p><code>依赖倒转原则</code>是：要依赖于抽象，不要依赖于具体。也就是常说的要针对接口编程，不要针对实现编程。</p>
</li>
</ul>

        <h3 id="2排序与查找">
          <a href="#2排序与查找" class="heading-link"><i class="fas fa-link"></i></a>2.排序与查找</h3>
      

        <h4 id="1题目-2">
          <a href="#1题目-2" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233237.png" alt></p>

        <h4 id="2解析-2">
          <a href="#2解析-2" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233252.png" alt></p>

        <h3 id="3树与二叉树">
          <a href="#3树与二叉树" class="heading-link"><i class="fas fa-link"></i></a>3.树与二叉树</h3>
      

        <h4 id="1题目-3">
          <a href="#1题目-3" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235547.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233412.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235039.png" alt></p>

        <h4 id="2解析-3">
          <a href="#2解析-3" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233454.png" alt></p>

        <h3 id="4数据库的设计过程">
          <a href="#4数据库的设计过程" class="heading-link"><i class="fas fa-link"></i></a>4.数据库的设计过程.</h3>
      

        <h4 id="1题目-4">
          <a href="#1题目-4" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233649.png" alt></p>

        <h4 id="2解析-4">
          <a href="#2解析-4" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>软件设计必须依据对软件的需求来进行，结构化分析的结果为结构化设计提供了最基本的输入信息。从分析到设计往往经历以下流程：<br></p>
<p>（1）研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口。<br><br>
（2）根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型。针对两种不同的类型分别进行分析处理。<br><br>
（3）由数据流图推导出系统的初始结构图。<br><br>
（4）利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止。<br><br>
（5）根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计或数据文件的设计。<br><br>
（6）在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。<br><br>
所以接口设计的主要依据是数据流图，接口设计的任务主要是描述软件与外部环境之间的交互关系，软件内模块之间的调用关系。<br></p>

        <h3 id="5设计模式">
          <a href="#5设计模式" class="heading-link"><i class="fas fa-link"></i></a>5.设计模式</h3>
      

        <h4 id="1题目-5">
          <a href="#1题目-5" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233939.png" alt></p>

        <h4 id="2解析-5">
          <a href="#2解析-5" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<ul>
<li>
<p>享元模式提供支持大量细粒度对象共享的有效方法。</p>
</li>
<li>
<p>组合模式（Composite）：将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</li>
<li>
<p>迭代器模式（Iterator）：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。<br></p>
</li>
<li>
<p>备忘录模式（Memento）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。</p>
</li>
</ul>

        <h3 id="6面向对象的基本概念">
          <a href="#6面向对象的基本概念" class="heading-link"><i class="fas fa-link"></i></a>6.面向对象的基本概念</h3>
      

        <h4 id="1题目-6">
          <a href="#1题目-6" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234103.png" alt></p>

        <h4 id="2解析-6">
          <a href="#2解析-6" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>本题考查面向对象分析与设计的基本概念。<br><br>
&nbsp;&nbsp;&nbsp; 面向对象分析主要强调理解问题是什么，不考虑问题的解决方案，因此答案A、C是正确的。面向对象设计侧重问题的解决方案，并且需要考虑实现细节问题，因此选项D的说法是不正确的。</p>

        <h3 id="7专业英语">
          <a href="#7专业英语" class="heading-link"><i class="fas fa-link"></i></a>7.专业英语</h3>
      

        <h4 id="1题目-7">
          <a href="#1题目-7" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234247.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234330.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234406.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235147.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235227.png" alt><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235256.png" alt></p>

        <h4 id="2解析-7">
          <a href="#2解析-7" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>软件实体的尺寸比任何其他人类构造更复杂，因为没有两个部分相同（至少在语句级上）。如果是，我们将两个相似的部分分成一个，一个（71），开放或关闭。在这方面，软件系统与计算机，建筑物或汽车有着深刻的区别，其中重复的元素很多。<br></p>
<p>数字电脑本身比大多数人理解的很多情况都要更复杂。这使得构思，描述和测试他们非常复杂。软件系统比计算机更多（72）数量级。<br><br>
同样地，软件实体的放大不仅仅是较大尺寸的相同元素的重复;必然增加不同要素的数量。在大多数情况下，这些元素以（73）的方式彼此相互作用，并且整体的复杂性比线性增加更多。<br><br>
软件的复杂性是（74）的属性，而不是偶然的。因此，消除其复杂性的软件实体的描述往往会抽象出其本质。数学和物理科学通过构建复杂现象的简化模型，从模型中导出属性，并通过实验验证这些属性，在三个世纪以来取得了长足的进步。这是因为模型中被忽略的复杂性（75）不是现象的基本属性。当复杂性是本质时，它不起作用。<br><br>
开发软件产品的许多经典问题源于这一重要的复杂性，其非线性随着尺寸而增加。不仅技术问题，管理问题也来自于复杂性。<br></p>

        <h3 id="7计算机指令">
          <a href="#7计算机指令" class="heading-link"><i class="fas fa-link"></i></a>7.计算机指令</h3>
      

        <h4 id="1题目-8">
          <a href="#1题目-8" class="heading-link"><i class="fas fa-link"></i></a>1.题目</h4>
      
<p><img src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234631.png" alt></p>

        <h4 id="2解析-8">
          <a href="#2解析-8" class="heading-link"><i class="fas fa-link"></i></a>2.解析</h4>
      
<p>指令平均时钟数约为<br><br>
　　　（160000×1+30000×2 +24000×4+16000×8）/（160000+30000+24000+16000）<br><br>
&nbsp;&nbsp;&nbsp; =444000/230000≈1.93<br><br>
　　该计算机的运算速度约为</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/4/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417183933.png" alt="avatar"></div><p class="sidebar-ov-author__text">繁华落尽一场空：风往尘香花已尽</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/YichangKong" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/yichangkong" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-git"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/yichangkong" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">80</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">6</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">23</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Liu Jun</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v3.9.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zindex="-1"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script></body></html>