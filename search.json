[{"title":"测试","url":"/2020/04/17/测试/","categories":["java"]},{"title":"2020年03月06日软件设计师每日一练","url":"/2020/04/17/2020年03月06日软件设计师每日一练/","content":"\n### 1.Cache\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417161320.png)\n\n   <!--more-->\n\n2. 题目解析\n\n   >  本题考查计算机组成原理中的高速缓存基础知识。\n   >\n   > 高速缓存Cache有如下特点：它位于**CPU和主存**之间，**由硬件实现**；\n   >\n   > 容量小，一般在几KB到几MB之间；速度一般比主存快5到10倍，由快速半导体存储器制成；\n   >\n   > 其内容是主存内容的副本（**所以Cache无法扩大主存的容量**），对程序员来说是透明的；\n   >\n   > Cache既可存放程序又可存放数据。\n\n   > **Cache存储器用来存放主存的部分拷贝（副本）**。\n   >\n   > 控制部分的功能是：判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对 Cache存储器寻址。未命中时，若是读取操作，则从主存中读取数据，并按照确定的替换原则把该数据写入Cache存储器中：若是写入操作，则将数据写入主存即可。<br>\n   > Cache并不能扩大主存的容量，它与主存是两个部分。\n\n### 2.运算器和控制器\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417161554.png)\n\n2. 题目解析\n\n   >  CPU是一台计算机的运算核心和控制核心，其由**运算器、控制器、寄存器**及实现它们之间联系的数据、控制及状态的总线构成。其中运算器负责相关的逻辑、算术运算，寄存器用来存放一些相关的数据，而内部总线负责各部件间信息的传递，而控制器不仅要保证指令的正确执行，还要能够处理异常事件。\n\n### 3.文法\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417161642.png)\n\n2. 题目解析\n\n   > 一个文法的语言是该文法能产生的句子的集合。一个文法产生的句子是从文法开始符号出发推导出的所有终结符号串。\n\n### 4.设计模式\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417161741.png)\n\n2. 题目解析\n\n   >  设计模式能够在**需求变化的情况下，尽可能不更改原有的设计和实现**。\n\n### 5.树与二叉树\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417161835.png)\n\n2. 题目解析\n\n   > 一个连通图的生成树是一个极小连通子图，它包含图中的全部顶点，但只有构成一棵树的n-1条边。把生成树各边的权值总和称为生成树的权，把权值最小的生成树称为最小生成树。<br>\n   >  　　&nbsp;哈夫曼树又称最优二叉树，是一类带权路径长度最短的树。若深度为k的二叉树有2k-1个结点，则称其为满二叉树。可以对满二叉树中的结点进行连续编号:约定编号从根结点起，自上而下、自左至右依次进行。深度为k、有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。<br>\n   >  　　二叉排序树又称二叉查找树，它或者是一棵空树，或者是具有如下性质的二叉树。<br>\n   >  　　若它的左子树非空，则左子树上所有结点的值均小于根结点的值。<br>\n   >  　　若它的右子树非空，则右子树上所有结点的值均大于根结点的值。<br>\n   >  　　左、右子树本身就是两棵二叉排序树。<br>\n   >  　　显然，将一个无序序列中的元素依次插入到一棵二叉排序树中并进行中序遍历，可得到一个有序序列。\n\n### 6.编译与解析\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417162511.png)\n\n2. 题目解析\n\n   > **中间代码是源程序的一种内部表示，或称中间语言**。\n   >\n   > 中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现中间代码，即为中间语言程序，\n   >\n   > 中间语言的复杂性介于源程序语言和机器语言之间。中间语言有多种形式，\n   >\n   > 常见的**有逆波兰记号、四元式、三元式和树**。\n\n### 7.计算机\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200417162652.png)\n\n2. 题目解析\n\n   > 本题考查计算机基本工作原理。<br>\n   >  　　\n   >\n   > CPU中的**程序计数器PC**用于保存要执行的指令的地址\n   >\n   > \n   >\n   > **访问内存时 》需先将内存地址送入存储器地址寄存器MAR中 》向内存写入数据时 》待写入的数据要先放入数据寄存器MUR**。\n   >\n   > 程序中的指令一般放在内存中，要执行时，首先要访问内存取得指令并保存在指令寄存器IR中。<br>\n   >  　　\n   >\n   > 计算机中**指令的执行过程一般分为取指令 》分析指令并获取操作数 》运算 》传送结果等阶段**，每条指令被执行时都要经过这几个阶段。\n   >\n   > 若CPU要执行的指令为:MOV&nbsp; RO，# I00（即将数值100传送到寄存器R0中），则CPU首先要完成的操作是将要执行的指令的地址送入程序计数器PC，访问内存以获取指令。\n","tags":["软件设计师考题"]},{"title":"2020年03月05日软件设计师每日一练","url":"/2020/04/16/2020年03月05日软件设计师每日一练/","content":"\n### 1.风险分析\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416145928.png)\n\n2. 题目解析\n\n   > 本题考查软件开发过程中的风险分析基础知识。\n   >\n   > 风险分析包括风险识别、风险预测、风险评估和风险控制等4个不同活动，\n   >\n   > 在**风险识别过程**中，要识别潜在的预算、进度、个体、资源、用户和需求等方面的问题以及对整个项目的影响，并建立**风险条目检查表**，列出**所有可能的风险事项**。\n   >\n   > \n   >\n   > 在风险预测过程中，需要建立一个表示风险可能性的参考标准，描述风险条目的结果，估计风险对项目的影响等。\n   \n   <!--more-->\n\n### 2.最短路径问题\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416150331.png)\n\n2. 题目解析\n\n   > 本题考查最短路径问题。\n   >\n   > - ​\t　　贪心算法通过一系列的选择得到问题的解。它所做出的每一次选择是当前状态下局部最优选择，即贪心选择。\n   >\n   > - ​\t　　分治法的基本思想是把大问题分解成一些较小的问题，然后由小问题的解方便地构造出大问题的解。\n   > - ​\t　　&nbsp;动态规划策略设计算法利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。\n   > - ​\t　　回溯法也称为试探法，该方法首先暂时放弃关于问题规模大小的限制，并将问题的候选解按某种顺序逐一枚举和检验。\n   >\n   > ​\t　　迪杰斯特拉（Dijkstra）提出的按路径长度递增的次序产生最短路径的算法，其思想是把网中所有的顶点分成两个集合S和T、 S集合的初态只包含顶点v0，T集合的初态为网中除v0之外的所有顶点。凡以v0为源点，己经确定了最短路径的终点并入S集合中；顶点集合T则是尚未确定最短路径的顶点的集合。按各顶点与v0间最短路径长度递增的次序，逐个把T集合中的顶点加入到S集合中去，使得从v0到S集合中各顶点的路径长度始终不大于从v0到T集合中各顶点的路径长度。<br>\n   >\n   > ​\t　　从迪杰斯特拉算法求最短路径的过程可知，其算法策略属于贪心策略。\n\n### 3.排序与查找\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416150957.png)\n\n2. 题目解析\n\n   > ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416151029.png)\n\n### 4.算法基础和常见的算法\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416151138.png)\n\n2. 题目解析\n\n   > 1. 分治法的设计思想是将一个难以直接解决的大问题分解成一些规模较少的相同问题以便各个击破，分而治之。 \t\n   > 2. 动态规划法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。动态规划法可求解的问题一般具有最优子结构和重叠子问题，因此本题第一空选择B选项动态规划法。 \n   > 3. ​\t贪心法经常用于解决最优化问题，但他的最优往往是从局部最优来考虑的，每一步都选最优的方案，但这种方案不一定能得到整体上的最优解。\n   > 4. ​\t回溯法是一种既带有系统性又带有跳跃性的**搜索算法**。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。因此本题第二空选择C选项回溯法。\n\n### 5.IP地址与子网划分\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416151736.png)\n\n2. 题目解析\n\n   > **子网掩码255.255.224.0**的二进制表示为11111111.11111111.11100000.00000000，比正常的B类子网掩码为255.255.0.0多出了3位“1”\n   >\n   > 所以把B类网络划分成了2<sup>3</sup>=8个子网。\n\n### 6.Gant和Pert图\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416152125.png)\n\n2. 题目解析 \n\n   > 1、关键路径为ABCEFJ 和ABDGFJ ，18天。 \n   >\n   > 2、BC持续时间3天，**BD持续时间2天，由一人完成，则可以把先完成BD，再完成BC，则BC持续时间作为5天，则关键路径为ABCEFJ， 20天。**\n\n### 7.图\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416152238.png)\n\n2. 题目解析 \n\n   > 用邻接矩阵存储有向图，图中每一条弧对应矩阵一个非零元素，题目中提到一共有e条弧，所以一共e个非零元素。\n\n### 8.TCP和IP协议族\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416152332.png)\n\n2. 题目解析\n\n   > 本题主要考查Windows命令的作用。\n   >\n   >  \n   >\n   > - ​\tipconfig/all能为DNS和WINS服务器显示它已配置且所要使用的附加信息（如IP地址等），并且显示内置于本地网卡中的物理地址。\n   > - ​\tipconfig /renew只能在向DHCP服务器租用其IP地址的计算机上起作用。如果你输入ipconfig /renew，那么本地计算机便设法与DHCP服务器取得联系，并租用一个IP地址。\n   > - ​\tipconfig/flushdns命令是清除DNS缓存用的。 当访问一个网站时系统将从DNS缓存中读取该域名所对应的IP地址，如果查找不到时，就会到系统中查找hosts文件，因此采用ipconfig/flushdns命令可以解决客户端域名解析故障的问题。\n   > - ​\tipconfig/release也只能在向DHCP服务器租用其IP地址的计算机上起作用。如果你输入ipconfig /release，那么所有接口的租用IP地址便重新交付给DHCP服务器。\n\n### 9.计算机木马病毒\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416152508.png)\n\n2. 题目解析\n\n   > 《软件设计师教程（第5版）》P566页：计算机病毒具**有隐蔽性、传染性、潜伏性、触发性和破坏性**等特定。因此本题选择D选项，自毁性不属于计算机病毒的特征。\n\n### 10.关系代数\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200416152600.png)\n\n2. 题目解析 \n\n   > R×S表示关系R与关系S的笛卡尔积，其结果是一个具有n（n的值由关系R与S的元组个数共同决定）行7列元素的二维表，σ<sub>4&lt;5</sub> (R×S)是选取表中第4列（R.D）元素值小于第5列（S.C）元素值的记录，然后对这个结果进行投影操作，即选取出第3（R.C）、4（R.D）、7（S.E）列组成一个新表。\n   >\n   > ​\t因此第53空的结果应该为R.C，R.D，S.E，而第54空是从关系表R和S中进行查找，查找的条件为R.D元素值小于S.C元素值，即R.D&lt;S.C。\n\n","tags":["软件设计师考题"]},{"title":"2020年03月04日软件设计师每日一练","url":"/2020/04/15/2020年03月04日软件设计师每日一练/","content":"\n\n\n### 1.图\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415212919.png)\n\n2. 题目解析\n\n   > 无向连通图不一定有边，但两个顶点之间有路径。 \n   \n   <!--more-->                                                                             \n\n### 2.软件成本估算\n\n1. 题目 \n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415213317.png)\n\n2. 题目解析\n\n   > 软件成本估算比较常用的模型有Putnam模型，功能点模型，COCOMO模型和后续的COCOMO II模型。其中以COCOMO II模型的使用最为广泛，它是cocomo模型的改进，以成本为主要因素，考虑多成本驱动因素。因此本题选择D选项COCOMO II模型。                                                                              \n\n### 3.线性表\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415213736.png)\n\n2. 题目解析\n\n   > 采用单向循环链表存储的特点之一是从表中任意结点出发都能遍历整个链表，另外便于元素的元素节点的删除与插入。如需要对表中的任意节点进行随机访问需采用顺序存储结构。\n\n### 4.其他\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415213813.png)\n\n2. 题目解析 \n\n   > 逆向工程是在软件维护时，由于缺少文档资料，而对软件的一种分析。                                                                              \n\n### 5.数据库设计过程\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415213914.png)\n\n2. 题目解析\n\n   > -  需求分析：分析用户的需求，包括数据、功能和性能需求；得到数据流图、数据字典和需求说明书。\n   >\n   > - 概念设计：用数据模型明确地表示用户的数据需求。其反映了用户的现实工作环境，与数据库的具体实现技术无关。（E-R模型）。 \n   > - 逻辑设计：根据概念数据模型及软件的数据模型特性，按照一定的转换规则和规范化理论，把概念模型转换为逻辑数据模型，如层次模型、网状模型、关系模型等。**关系规范化是在逻辑设计阶段进行**。 \n   >\n   > - 物理设计：为一个确定的逻辑数据模型选择一个最适合应用要求的物理结构的过程。\n   >\n   > \n\n### 6.面向对象的基本概念\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415214102.png)\n\n2. 题目解析\n\n   >  面向对象系统中的**封装单位是对象**，对象之间只能通过接口进行信息交流，对象外部不能对对象中的数据随意地进行访问。\n   >\n   > **封装是一种信息隐藏技术**，目的是使对象的定义和实现分离，这样，就能减少耦合，类内部的实现可以自由改变而不会影响其他的类或对象。\n\n### 7.规范化理论\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415214259.png)\n\n2. 题目解析\n\n   > 本题看起来逻辑很复杂，但解题相对比较简单。根据函数依赖集，可以简单分析，在本题中\n   >\n   > **唯一入度为0的属性为A2，**  `这里好像就 A２A５　没有被其他函数映射`\n   >\n   > 因此，A2一定属于候选键集合，在选项中只有B选项符合要求。<br>\n   >\n   > 第二空，根据第一空可知R的一个主键为A2A5，由函数依赖集F可知，存在A2A5àA6，A5A6àA1，A1àA3，这里存在传递函数依赖，故A、B选项均不正确，C选项本身不正确，存在非主属性对候选键的传递函数依赖，是不满足3NF的。因此本题选择D选项。　\n   >\n   > 也可将完整的依赖图示绘制出来判断本题A2A5为候选键，并且每个非主属性完全函数依赖于主键。\n\n### 8.HTML语言\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415214628.png)\n\n2. 题目解析 \n\n   > 本题考查的是HTML基本标签的使用。\n   >\n   > - alink用于设置正在**被击中**的链接的颜色。\n   > - vlink用于设置**已使用**的链接的颜色。\n   > - background用于设置背景图片的URL。\n   > - bgcolor用于设置文档整体背景颜色。\n","tags":["软件设计师考题"]},{"title":"2020年03月03日软件设计师每日一练","url":"/2020/04/14/2020年03月03日软件设计师每日一练/","content":"\n### 1.有限自动机\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414153659.png)\n\n2. 题目解析 \n\n   > 本题因为是**不确定的有限自动机**，中间内容有多种可能，但由图可以看到，\n   >\n   > 从初态0开始，首字符只能为0，到终态结束之前，尾字符也只能为0，根据选项可以排除，本题选择A选项。\n   \n   <!--more-->\n\n### 2.运算器和控制器\n\n1. 题目 \n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414153809.png)\n\n2. 题目解析\n\n   > 本题考查计算机硬件组成基础知识。\n   > \n   >**CPU是计算机的控制中心**，主要由\n   > \n   >- 运算器\n   > - 控制器 （它是发布命令的“决策机构”，即完成协调和指挥整个计算机系统的操作）\n   >   - 程序计数器 \n   >     - 程序计数器(PC)是专用寄存器，具有寄存信息和计数两种功能，又称为指令计数器\n   >     - 在程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的初始内容即是程序第一条指令的地址\n   >     - 执行指令时，CPU将自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序执行的，因此修改的过程通常只是简单地对PC加1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。\n   >   - 指令寄存器 \n   >   - 指令译码器\n   >   - 时序产生器\n   >   - 操作控制器\n   >   - 它的主要功能有：从内存中取出一条指令，并指出下一条指令在内存中的位置；对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作；指挥并控制CPU、内存和输入输出设备之间数据的流动。\n   > - 寄存器组\n   > - 内部总线   \n   > \n   >等部件组成。 \n\n### 3.路由器\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414154303.png)\n\n2. 题目解析 \n\n   >  路由器是网络层设备，它可以起到**隔离子网、抑制广播风暴**的作用。\n   >\n   >  \n   >\n   > 路由器还能进行地址转换，**通常用于把私网地址转换成公网地址**，或者进行相反的转换。在路由表中，对于同一目标，可以设置不同的通路，提供不同的服务。\n   >\n   > \n   >\n   > IPv4数据报头的第二个字节（如下图所示）是服务类型字段（Type of Service ）。该字段规定了不同的优先级（Precedence）延迟（Delay ），吞吐率（Throughput）和可靠性（Reliability ），为上层协议提供不同的服务质量。\n   >\n   > \n   >\n   > IP数据报中的目标地址（Destinaion address）字段可以是广播地址、组播地址和单播地址，当目标地址为前两种类型时，路由器可以实现**点到多点的传输**。 \n   >\n   > \n   >\n   > **IP数据报格式**\n   >\n   > ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414154600.png)\n\n### 4.设计模式\n\n1. 题目 \n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414154657.png)\n\n2. 题目解析 \n\n   >  生成器模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>\n   > 实用范围<br>\n   >\n   > -  当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 \n   > -  当构造过程必须允许被构造的对象有不同表示时。\n\n### 5.内存容量\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414155019.png)\n\n2. 题目解析 \n\n   > 本题考查内存容量的计算。<br>\n   >  　　给定起、止地址码的内存容量=终止地址-起始地址+1。<br>\n   >  　　&nbsp;将终止地址加1等于E000H，再减去起始地址，即E0000H-A0000H=40000H。十六进制的（40000）<sub>16</sub>=2<sup>18</sup>。<br>\n   >  　　组成内存储器的芯片数量=内存储器的容量/单个芯片的容量。<br>\n   >  　　　　　　　　2<sup>18</sup>/（32*2<sup>10</sup>）=2<sup>18</sup>/2<sup>15</sup>=2<sup>3</sup>。\n\n### 6.UML\n\n1. 题目 \n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414155355.png)\n\n2. 题目解析 \n\n   > 顺序图（sequence diagram，序列图）。\n   >\n   > 顺序图是一种交互图（interaction diagram），交互图展现了一种交互，它由\n   >\n   > \n   >\n   > 一组对象或参与者以及它们之间可能发送的消息构成。交互图专注于系统的动态视图。顺序图是强调消息的时间次序的交互图。<br>\n   >\n   > \n   >\n   > 本题图示为序列图。序列图展示了**1个用例和多个对象**的行为\n\n### 7.编译与解析\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414155518.png)\n\n2. 题目解析 \n\n   >  编译语言是一种以**编译器来实现的编程语言**。\n   >\n   > \n   >\n   > 它不像**直译语言**一样，由解释器将代码一句一句运行，而是**以编译器，先将代码编译为机器码**，再加以运行。将某一种程序设计语言写的程序翻译成等价的另一种语言的程序的程序, 称之为编译程序。\n\n### 8.设计模式\n\n1. 题目 \n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414155641.png)\n\n2. 题目解析 \n\n   >  模式是一种问题的解决思路，它已经适用于一个实践环境，并且可以适用于其它环境。设计模式通常是对于某一类软件设计问题的可重用的解决方案，将设计模式引入软件设计和开发过程，其目的就在于要重用成功的软件开发经验。\n\n### 9.多媒体技术概念\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414155757.png)\n\n2. 题目解析 \n\n   > **矢量图形**是用一系列计算机**指令来描述和记录**一幅图的内容，\n   >\n   > 即通过指令描述构成一幅图的所有直线、曲线、圆、圆弧、矩形等图元的位置、维数和形状，也可以用更为复杂的形式表示图像中曲面、光照和材质等效果。矢量图法实质上是用数学的方式（算法和特征）来描述一幅图形图像，在处理图形图像时根据图元对应的数学表达式进行编辑和处理。在屏幕上显示一幅图形图像时，首先要解释这些指令，然后将描述图形图像的指令转换成屏幕上显示的形状和颜色。\n   >\n   > **编辑矢量图**的软件通常称为绘图软件，如适于绘制机械图、电路图的AutoCAD软件等。\n   >\n   > 这种软件可以产生和操作矢量图的各个成分，并对矢量图形进行移动、缩放、叠加、旋转和扭曲等变换。编辑图形时将指令转变成屏幕上所显示的形状和颜色，显示时也往往能看到绘图的过程。由于所有的矢量图形部分都可以用数学的方法加以描述，从而使得计算机可以对其进行任意放大、缩小、旋转、变形、扭曲、移动和叠加等变换，而不会破坏图像的画面。但是，用矢量图形格式表示复杂图像（如人物、风景照片），并且要求很高时，将需要花费大量的时间进行变换、着色和处理光照效果等。因此，矢量图形主要用于表示线框型的图画、工程制图和美术字等。 \n   > \n   >​\t　　\n   > \n   >**位图图像是指用像素点来描述的图**。图像一般是用摄像机或扫描仪等输入设备捕捉实际场景画面，离散化为空间、亮度、颜色（灰度）的**序列值**，即把一幅彩色图或灰度图分成许许多多的像素（点），\n   > \n   >每个像素用若干二进制位来指定该像素的颜色、亮度和属性。位图图像在计算机内存中由一组二进制位组成，这些位定义图像中每个像素点的颜色和亮度。\n   > \n   >**图像适合于表现比较细腻，层次较多，色彩较丰富，包含大量细节的图像**，并可直接、快速地在屏幕上显示出来。\n   > \n   >但占用存储空间较大，一般需要进行数据压缩。\n\n### 10.软件质量保证\n\n1. 题目\n\n   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200414160124.png)\n\n2. 题目解析 \n\n   > 模块结构评审时，主要包括以下方面的评审：</div>\n   >\n   > 1、控制流结构：规定了处理模块与处理模块之间的流程关系。检查处理模块之间的控制转移关系与控制转移形式（调用方式）。 \n   >\n   > 2、数据流结构：规定了数据模块是如何被处理模块进行加工的流程关系。检查处理模块与数据模块之间的对应关系；处理模块与数据模块之间的存取关系，如建立、删除、查询、修改等。 \n   >\n   > 3、模块结构与功能结构之间的对应关系：包括功能结构与控制流结构的对应关系；功能结构与数据流结构的对应关系；每个模块的定义（包括功能、输入与输出数据）。\n\n   ","tags":["软件设计考题"]},{"title":"算法复杂度","url":"/2020/04/13/算法复杂度/","content":"\n![**常用算法的时间复杂度和空间复杂度**](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413162417.png)\n\n<!--more-->\n\n### 1.简单介绍\n\n-  [算法复杂度O](https://www.cnblogs.com/yeshengCqupt/p/12495526.html)\n- 包括时间复杂度、空间复杂度\n\n### 2.时间复杂度\n\n1.  **介绍**\n\n   1. 赋值语句决定了程序运行时间，赋值语句越多，时间越长。\n   2. 大O表示法：**T(n)**表示主导的数量级\n   3. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。\n   4. T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。\n   5. 计算时间复杂度的方法：\n      -  用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  => T(n)=n²+7n+1\n      - 修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 => T(n) = n²\n      - 去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)\n\n2. **计算方式** \n\n   - **事后统计**的方法: 这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。\n   - **事前估算**的方法: 通过分析某个算法的时间复杂度来判断哪个算法更优.\n\n3. **时间频度**\n\n   -  时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)\n\n   - 举例说明 \n\n     比如计算1-100所有数字之和, 我们设计两种算法：\n\n     \n\n     ​    int total = 0;\n     ​\tint end = 100;\n     ​\t//使用for循环计算\n     ​\tfor(int i=0;i<=end;i++){\n     ​    \ttotal+=i;\n     ​\t}\n     ​\t//时间复杂度T(n)=n+1;\n\n       //直接计算\n       total=(1+end)*end/2;\n\n4. **计算时可进行忽略部分**\n\n   - 忽略常数项 \n     1.  ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413163922.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413163936.png)\n     2. 结论\n        - 2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略\n        - 3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略 \n   -  忽略低次项\n     1.  ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413164208.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413164222.png)\n     2. 结论 \n        -  2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10\n        - n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20\n   -  忽略系数\n     1. ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413164650.png) ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413164635.png)\n     2. 结论 \n        - 随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。\n        - 而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键\n\n5. **常见的时间复杂度**\n\n   1. 常数阶O(1) \n\n      - 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)\n\n      -  int i = 1;\n        int j = 2;\n        ++i;\n        j++;\n        int m = i + j;\n        \n      - 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。\n\n   2. 对数阶O(log2n) \n\n      -   int i = 1;\n          while(i<n){\n              i = i * 2;\n          }\n      \n      \n   - 说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) \n     \n      -  <img src=\"https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413165537.png\" style=\"zoom:150%;\" />\n      \n   - N=2^x  **>**  n= 2^i    ;  1024=2^10  log2(1024)=10\n     \n   - ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413171319.png)\n     \n     \n     \n     \n     \n   3. 线性阶O(n) \n\n      - for (int i = 1; i<=n; ++i){\n            j = i;\n            j++;\n        }\n      \n      \n   - 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度\n     \n   4. 线性对数阶O(nlog2n) \n\n      -  for(m = 1;m<n;m++){\n            i=1;\n            while(i<n){\n                i = 1 * 2;\n            }\n        }\n        \n      - 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)\n\n   5. 平方阶O(n^2)\n\n      -  for(x = 1;x<=n;x++){\n             for (i = 1; i<=n; i++){\n         \n           }   \n        }\n        \n      - 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n)\n\n   6. 立方阶O(n^3)\n\n   7. k次方阶O(n^k)\n\n   8. 指数阶O(2^n) \n\n   9. ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413165059.png)\n\n   10. **说明** \n\n       - 常见的算法时间复杂度由小到大依次为：**Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n)** ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低\n       - 从图中可见，我们应该尽可能避免使用指数阶的算法\n       \n   11. **平均时间复杂度和最坏时间复杂度**\n\n       1.  平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。\n\n       2. 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。\n\n       3. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。\n\n       4. ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200415220226.png)\n\n          \n\n\n### 3.空间复杂度\n\n1. 基本介绍\n   -  类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。\n   -  空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况\n   -  在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.\n2. **空间复杂度**\n   - 算法的空间复杂度通过计算算法所需的存储空间实现，\n   - 算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数，也是一种“渐进表示法”，这些所需要的内存空间通常分为“**固定空间内存**”\n   - （包括基本程序代码、常数、变量等）和“变动空间内存”（随程序运行时而改变大小的使用空间）。\n3. 计算方法\n   - 例如递归算法。忽略常数，用O(1)表示 ，递归算法的空间复杂度=递归深度N*每次递归所要的辅助空间， 对于单线程来说，递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数，因为递归最深的那一次所耗费的空间足以容纳它所有递归过程。","tags":["知识点讲解"]},{"title":"2020年03月02日软件设计师每日一练","url":"/2020/04/13/2020年03月02日软件设计师每日一练/","content":"\n### 1.软件质量保证\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413140440.png)\n\n#### 2.题目解析\n\n> McCall软件质量模型从软件产品的运行、修正和转移三个方面确定了11个质量特性，其中运行方面包含了正确性、可靠性、效率、完整性、使用性这些质量特性。修正方面包含了维护性、测试性、灵活性这3个质量特性。转移方面包含了维护性移植性、复用性、共运行性这3个质量特性。\n>\n\n<!--more-->\n\n#### 3.知识牵引（McCall软件质量模型）（[原网站](https://www.cnblogs.com/gaochundong/p/software_quality_models.html)）\n\n> # [软件质量模型](https://www.cnblogs.com/gaochundong/p/software_quality_models.html)\n>\n> 关于软件质量模型，业界已经有很多成熟的模型定义，比较常见的质量模型有 McCall 模型、Boehm 模型、FURPS 模型、Dromey 模型和 ISO9126 模型。\n>\n> - [*Jim McCall 软件质量模型（1977 年）*](https://www.cnblogs.com/gaochundong/p/software_quality_models.html#quality_model_mccall)\n> - [*Barry W. Boehm 软件质量模型（1978 年）*](https://www.cnblogs.com/gaochundong/p/software_quality_models.html#quality_model_boehm)\n> - [*FURPS/FURPS+ 软件质量模型*](https://www.cnblogs.com/gaochundong/p/software_quality_models.html#quality_model_furps)\n> - [*R. Geoff Dromey 软件质量模型*](https://www.cnblogs.com/gaochundong/p/software_quality_models.html#quality_model_dromey)\n> - [*ISO/IEC 9126 软件质量模型（1993 年）*](https://www.cnblogs.com/gaochundong/p/software_quality_models.html#quality_model_iso9126)\n> - [*ISO/IEC 25010 软件质量模型（2011 年）*](https://www.cnblogs.com/gaochundong/p/software_quality_models.html#quality_model_iso25010)\n>\n> ## Jim McCall 软件质量模型（1977 年）\n>\n> Jim McCall 的软件质量模型，也被称为 GE 模型（General Electrics Model）。其最初起源于美国空军，主要面向的是系统开发人员和系统开发过程。McCall 试图通过一系列的软件质量属性指标来弥补开发人员与最终用户之间的沟壑。\n>\n> McCall 质量模型使用 3 中视角来定义和识别软件产品的质量：\n>\n> \n>\n> 1. Product revision (ability to change).产品版本（更改的能力）\n>\n> 2. Product transition (adaptability to new environments).产品过渡（适应新环境）\n>\n> 3. Product operations (basic operational characteristics).产品运营（基本运营特征）\n>\n>    \n>\n>  \n>\n> > ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413140737.png)\n>\n> McCall 模型通过层级的要素、标准和指标来详述这 3 个视角定义（产品修改、产品转移、产品运行）。\n>\n> - 11 Factors (To specify)：描述软件的外部视角，也就是客户或使用者的视角。\n> - 23 Criterias (To build)：描述软件的内部视角，也就是开发人员的视角。\n> - Metrics (To control)：定义衡量指标和方法\n>\n> 下图中，左侧为 11 个质量要素，右侧为 23 个质量标准。\n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413140917.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413141100.png)\n>\n>  \n\n\n\n### 2.知识产权人确定\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413141131.png)\n\n#### 2.题目解析\n\n>  软件著作权是指软件的开发者或者其他权利人依据有关著作权法律的规定，对于软件作品所享有的各项专有权利。它不需要申请即可拥有。<br>\n>\n> ​    **软件专利权是指通过申请专利对软件的设计思想进行保护的一种方式，而非对软件本身进行的保护，我国在专利保护上，实行先申请制度，即谁申请在先，谁就享有该专利权，本题中由于公司没有申请专利，因此不具有专利权** 。<br>\n>\n> ​\t&nbsp;&nbsp;&nbsp; 软件商标权是指商标主管机关依法授予商标所有人对其注册商标受国家法律保护的专有权，在我国，商标权的获得必须履行商标注册程序，而且实行申请在先原则，即谁先申请，谁拥有该商标权。本题中由于公司没有申请商标权，因此不具有商标权。<br>\n>\n> ​\t&nbsp;&nbsp;&nbsp; 商业秘密一般是指不为公众所知悉，能为权利人带来经济利益，具有实用性并经权利人采取保密措施的技术信息和经营信息。<br>\n>\n> ​\t&nbsp;&nbsp;&nbsp; 综上所述，我们可知公司仅享有该软件产品的软件著作权和商业秘密权。\n\n### 3.多媒体技术概念\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413141318.png)\n\n#### 2.题目解析\n\n> 颜色深度是表示位图图像中单个像素的颜色或灰度所占的位数，\n>\n> **8位的颜色深度，表示每个像素有8位颜色位，可表示256种不同的颜色。**\n>\n> 存储位图图像的数据量与图像大小有关。而位图图像的大小与分辨率、颜色深度有关。本题图像的垂直方向分辨率为640像素，水平方向分辨率为480，颜色深度为8位，则该图像所需存储空间为\n>\n> （640×480× 8 ）/8 （Byte） = 307200（Byte）。经5：1压缩后，该图像所需存储空间为307200/5 =61440（Byte）\n\n### 4.内存\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413141640.png)\n\n#### 2.题目解析\n\n> 本题考查**运行过程中计算机内存布局及指令寻址方式。** \n>\n> 计算机运行时的内存空间划分情况如下图所示。\n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413141735.png)\n>\n> 运行时为名字分配存储空间的过程称为绑定。\n>\n> \n>\n> - 静态数据区：用于存放一对一的绑定且编译时就可确定存储空间大小的数据，\n>\n> - 栈：用于存放一对多的绑定且与活动同生存期的绑定;\n>\n> - 堆：用于存储由程序语句动态生成和撤销的数据。 \n>\n>   \n>\n> ​\t　　程序运行时，需要将程序代码（机器指令序列）**和代码所操作的数据加载至内存**。指令代码加载至代码区，数据则根据绑定关系可能位于静态数据区、栈或堆区。<br>\n>\n> ​\t　　立即数寻址方式是指指令所需的操作数由指令的地址码部分直接给出，其特点是取指令时同时取出操作数，以提高指令的执行速度。\n\n\n\n### 5.计算机硬件基础知识\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413142050.png)\n\n#### 2.题目解析\n\n>  本题考查的是计算机系统硬件方面的基础知识。构成计算机控制器的硬件主要有\n>\n> 指令寄存器IR，\n>\n> 程序计数器PC，\n>\n> 时序部件,\n>\n> 微操作形成部件等。而**算术逻辑单元ALU不是构成控制器的部件，属于运算器**。\n>\n> 对于程序状态字寄存器PSW属于运算器还是控制器**有争议**，本题最佳明确答案应该是C算术逻辑单元ALU。\n\n### 6.文法\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413142302.png)\n\n#### 2.题目解析\n\n>  上下文无关文法重要的原因在于它们\n>\n> **拥有足够强的表达力来表示大多数程序设计语言的语法**；\n>\n> 实际上，几乎所有程序设计语言都是通过上下文无关文法来定义的。\n>\n> 另一方面，上下文无关文法又足够简单，使得我们可以\n>\n> **构造有效的分析算法来检验一个给定字串是否是由某个上下文无关文法产生的**。\n\n### 7.ER模型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413142507.png)\n\n#### 2.题目解析\n\n>  在本题中显然是存在命名冲突，同一个实体在同系统中存在不同的命名，这是不被允许的。\n\n### 8.IP地址与子网划分\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200413142559.png)\n\n#### 2.题目解析\n\n>  由于分配给公司网络的地址块是210.115.192.0/20，C类子网网络号24位，留给子网掩码的比特数只有4位，所以只能划分为2<sup>4</sup>=16个C类子网，这16个C类子网的子网号为11000000~11001111，即192~207，所以210.115.210.0不属于该公司的网络地址。\n\n#### 3.知识牵引（IP地址与子网划分）\n\n[网址](https://blog.csdn.net/bobozai86/article/details/80139384?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6)","tags":["软件设计师考题"]},{"title":"2020年03月01日软件设计师每日一练","url":"/2020/04/12/2020年03月01日软件设计师每日一练/","content":"\n### 1.保护期限\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412174740.png)\n\n#### 2.题目解析\n\n>  我国《著作权法》对著作权的保护期限作了如下规定: (1)著作权中的\n>\n> **署名权、修改权、保护作品完整权**的保护期不受限制。\n\n<!--more-->\n\n### 2.符号数算数\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412174851.png)\n\n#### 2.题目解析\n\n>  符号数算术运算的溢出可根据运算结果的符号位和进位标志判别。该方法适用于两同号数求和或异号数求差时判别溢出。溢出的逻辑表达式为：VF=SF⊕CF即利用符号位和进位标志相异或，当异或结果为1时表示发生溢出；\n>\n> 当异或结果为0时，则表示没有溢出。\n\n#### 3.知识牵引（ 符号数算术运算）\n\n> 通常我们说的加减法进位方式判断是否溢出一般指的都是补码方式运算下的。无论是一位符号位还是两位符号位，逻辑是相同的。\n>\n> 先由一位符号位说起。\n>\n> 假设是5位机器位，一位用作符号位，四位用作数据位，那么数据的表示范围是：\n> −24−24 ~ 24−124−1\n> 即：-16~15\n>\n> 因此我们上来就看一个溢出的例子，形成一种直观的感受：\n> -8-9 = -17,果断是溢出的。\n>\n> 补码表示\n> 1，1000\n> 1，0111\n> =0，1111\n> 得到的数字是+1.\n> 具体发生了什么，你看，符号位发生了进位。但数据位的运算并没有进位。\n> 两个负数的符号位一进位，加和的数据居然由负变正了，所以肯定是发生了溢出。如果数据位也进位，就会让符号位还是1，看起来，符号位没有变化，因此检查不出来已经发生了进位。\n>\n> 而在补码运算中，数据位高位为1，其实是比较小的数，除了-8这种刚好卡在边界的，其他较大的，如：\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412175758.png)\n>\n> 可以看出来，-7-8 高位数据位进位，符号位也进位，但是并不会溢出。\n> −12−13−12−13，符号位进位，高位进位, 会溢出。\n> 要想举出高位进位，单数符号位不进位的，则可以在两个正数中举，这个比较容易想象，高位进位，表示超出了4位数据位表达的极限，恰好符号位都是0，因此也符合：\n> 只有一个高位进位或者符号位进位就为溢出的规则。\n>\n> 而针对两位符号位，其实就是把高位进位和符号位进位表示出来了，比如高位进位到低的符号位得到的10，或者01，就表示溢出了。\n>\n> 而11，00分别表示数据为负，正。\n>\n> 可以这么认为，符号位进位标识SF，和数据位进位标识C，两者不等时，即异或为1时，就产生了溢出。\n>\n> 判断规则很简单，深入理解更重要。\n>\n> update:第一稿在举例论证的时候补码的计算出现了错误，经过同学的指出，已经更正。这篇的核心就是想说：\n>\n> - 数据高位进位，符号位进位未进位，溢出。\n> - 数据位高位未进位，符号位进位，溢出。\n> - 数据位高位进位，符号位进位，不溢出。\n> - 数据位高位未进位，符号位未进位，不溢出。\n>\n> 溢出的判断就是这两个标识的组合。从中抽出布尔代数的表达式就是SF与C 异或为1 时判定为溢出。用双符号位时，右边的数符跟踪的是数据位高位是否进位。左边的数符跟踪的是符号位是否进位，这便是用11,00分别作为负数，正数且未溢出的标识，10，01则分别是负数和正数的溢出。\n>\n> 不管编码，我们知道整数的计算时，正数与正数相减等同于正数与负数相加不会溢出。只有正数加正数和负数加负数时才可能产生溢出。而这两种情况对应的便是异或为1的两种情况。\n>\n> 此外既然是溢出判断，也可以换个角度从编码表示范围思考。\n>\n> http://blog.csdn.net/u011240016/article/details/52608128\n>\n> 另外，本篇文章的起因是如何设计PSW中的SF与C的算式表达溢出。\n> 原文链接：https://blog.csdn.net/u011240016/java/article/details/52567295\n\n### 3.UML\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180016.png)\n\n#### 2.题目解析\n\n>  对于图示状态图，事件e2发生，而当前并没有处于B2状态时，不会发生变迁，因此本题选择C选项。                                                                              \n\n### 4.Cache\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180047.png)\n\n#### 2.题目解析\n\n>  本题考查高速缓存基础知识。<br>\n>  　\n>\n> 　高速缓存Cache有如下特点：它位于CPU和主存之间，由硬件实现;容量小，一般在几KB到几MB之间:速度一般比主存快5到10倍，由快速半导体存储器制成;其内容是主存内容的副本，对程序员来说是透明的；Cache既可存放程序又可存放数据。<br>\n>  　\n>\n> 　Cache主要由两部分组成：控制部分和Cache存储器部分。Cache存储器部分用来存放主存的部分拷贝〔备份）。控制部分的功能是：判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址。未命中时，若是读取操作，则从主存中读取数据，并按照确定的替换原则把该数据写入Cache存储器中；若是写入操作，则将数据写入主存即可。\n\n### 5.病毒\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180146.png)\n\n#### 2.题目解析\n\n>  “冲击波”病毒是一种蠕虫类型的病毒。在进行网络传播时，利用了Windows操作系统的RPC漏洞。\n\n#### 3.知识牵引（RPC漏洞）\n\n> [RPC](https://baike.baidu.com/item/RPC)（Remote Procedure Call, [远程过程调用](https://baike.baidu.com/item/远程过程调用)）是操作系统的一种消息传递功能，[微软](https://baike.baidu.com/item/微软)的描述为：“一种能允许[分布式应用程序](https://baike.baidu.com/item/分布式应用程序)调用网络上不同计算机的可用服务的消息传递实用程序。在计算机的远程管理期间使用” 。RPC 服务在windows服务项中不能手动停止，但是可以用第三方工具停止，在win2000中停止掉此服务后比较明显的特征是复制文件时，鼠标右键的“粘贴”总是禁用的。\n\n### 6.专业英语\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180354.png)\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180419.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180435.png)  ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180602.png)\n\n#### 2.题目解析\n\n> 在物理安全和信息安全**领域**，访问控制是选择性地限制访问某个地方或其他资源。访问行为可能意味着消耗，进入或使用。授权访问资源称为授权。<br>\n>\n> 访问控制机制介于用户（或代表用户执行的进程）和系统资源之间。资源如应用程序、操作系统、防火墙、路由器、文件和数据库。系统必须先验证（验证）寻求访问权限的用户。通常，认证功能确定用户是否能被允许访问该系统。然后，访问控制功能确定该用户的特定请求的访问是否被允许。一个安全管理员维护一个授权数据库，该数据库指定该用户允许哪些资源的访问类型。访问控制功能查询此数据库以确定是否授权访问。审计功能监控和保存用户对系统资源的访问记录。<br>\n>\n> 实际上，很多组件可以协同共享访问控制功能。所有的操作系统至少有一个基本的，在许多情况下是一个非常强大的访问控制组件。附加安全软件包可以添加到操作系统的本地安全控制功能。特定的应用程序或实用程序，如数据库管理系统，还包括访问控制功能。外部设备（如防火墙）也可以提供访问控制服务。\n\n\n\n### 7.开发系统互连参考模型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180718.png)\n\n#### 2.题目解析\n\n>  交换机有多种，共同的特点都是根据某种标识把输入数据包交换到输出端口。以太网交换机根据MAC地址进行交换：帧中继交换机根据虚电路号DLCI进行交换：Internet中使用的三层交换机根据IP地址进行转发，并根据MAC地址进行交换：ATM交换机根据虚电路标识VPI和VCI进行交换。\n\n### 8.Gant图和Pert图\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180759.png)\n\n#### 2.题目解析\n\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180849.png)\n\n### 9.声音信号\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200412180916.png)\n\n#### 2.题目解析\n\n>  声音信号是一种模拟信号，计算机要对其进行处理，必须将其转换为数字声音信号即用二进制数字的编码形式来表示声音。最基本的声音信号数字化方法是取样一量化法，分成如下3个步骤。<br>\n>\n>  （1）采样：把时间连续的模拟信号转换成时间离散、幅度连续的信号。在某些特定的时刻获取声音信号幅值叫做采样，由这些特定时刻采样得到的信号称为离散时问信号。一般都是每隔相等的一小段时间采样一次，其时间间隔称为取样周期，其倒数称为采样频率。采样定理是选择采样频率的理论依据，为了不产生失真，采样频率不应低于声音信号最高频率的两倍。因此，语音信号的采样频率一般为8kHz，音乐信号的采样频率则应在40kHz以上。采样频率越高，可恢复的声音信号分量越丰富，其声音的保真度越好。<br>\n>\n>  （2）量化：把在幅度上连续取值（模拟量）的每一个样本转换为离散值（数字量），因此量化过程有时也称为A/D转换（模数转换）。量化后的样本是用若干位二进制数（bit）来表示的，位数的多少反映了度量声音波形幅度的精度，称为量化精度，也称为量化分辨率。例如，每个声音样本若用16位（2个字节）表示，则声音样本的取值范围是0~65536精度是1/65536；若只用8位（1个字节）表示，则样本的取值范围是0~255，精度是1/256。量化精度越高，声音的质量越好，需要的存储空间也越多：量化精度越低，声音的质量越差，需要的存储空间也越少。<br>\n>\n>  （3）编码：经过采样和量化处理后的声音信号已经是数字形式了，但为了便于计算机的存储、处理和传输，还必须按照一定的要求进行数据压缩和编码，即：选择某一种或者几种方法对其进行数据压缩，以减少数据量，再按照某种规定的格式将数据组织成为文件。 \n>\n> ","tags":["软件设计师考题"]},{"title":"什么是微服务？","url":"/2020/04/12/什么微服务？/","content":"\n##### [转载网址](https://www.cnblogs.com/xiao2shiqi/p/11298663.html)\n\n> <img src=\"https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409190332.png\" style=\"zoom:80%;\" />\n\n<!--more-->\n\n1. ### 前言\n\n   > 最近几年微服务很火，大家都在建设微服务，仿佛不谈点微服务相关的技术，都显得不是那么主流了。\n   >\n   > 近几年见识到身边朋友的很多公司和团队都在尝试进行微服务的改变，但很多团队并没有实际微服务踩坑经验，很多团队甚至强行为了微服务而去微服务，最终写成一个大型的分布式单体应用，就是改造后的系统既没有微服务的快速扩容，灵活发布的特性，也让原本的单体应用失去了方便开发，部署容易的特性（项目拆为多份，开发部署复杂度都提高了），不得不说是得不偿失。\n   >\n   > \n   >\n   > 1. 什么是微服务？为什么要用微服务？\n   > 2. 微服务解决什么问题，又引入了什么问题？\n   > 3. 使用微服务应该要遵循哪些原则？什么样的情况你不应该使用微服务？\n   >\n   > \n   >\n   > （PS：因为市面上太多对如果使用微服务框架工具的教程，所以本篇只是一篇关于微服务的总体概述性文章，不涉及各种微服务框架的安装和使用教程，我们只谈论微服务本身的设计模式的优缺点和适合应用的场景）\n   >\n   > \n\n2. ### 什么是微服务？为什么要用微服务？\n\n   1. 什么是微服务？ \n\n      > 简单举例：看军事新闻的同学应该都知道，一艘航空母舰作战能力虽然很强，但是弱点太明显，就是防御能力太差，单艘的航空母舰很少单独行动，通常航空母舰战斗群才是主要军事力量，你可以把\n      >\n      > 单艘航母理解为的**单体应用**（防御差，机动性不好），\n      >\n      > 航母战斗群（调度复杂，维护费用高）理解为**微服务**。\n      >\n      > \n      >\n      > 大部分的开发者经历和开发过单体应用，无论是传统的 Servlet + JSP，还是 SSM，还是现在的 SpringBoot，它们都是单体应用，那么长期陪伴我们的单体应用有什么弊端？我们是面临了什么问题，导致我们要抛弃单体应用转向微服务架构？个人总结主要问题如下：\n      >\n      > - 部署成本高（无论是修改1行代码，还是10行代码，都要全量替换）\n      > - 改动影响大，风险高（不论代码改动多小，成本都相同）\n      > - 因为成本高，风险高，所以导致部署频率低（无法快速交付客户需求）\n      >\n      > 当然还有例如无法满足快速扩容，弹性伸缩，无法适应云环境特性等问题，但我们不一一详谈了，以上的问题，都是微服务架构要解决的问题，至于具体是怎么解决的，我们先放到后面再聊\n      >\n      > \n      >\n      > <img src=\"https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409191408.png\" style=\"zoom:50%;\" />\n\n      \n\n      \n\n      \n\n      \n\n3. ### 微服务解决什么问题，又引入了什么问题？\n\n   > 我们先看看微服务能带给我们什么？微服务架构的特点：\n   >\n   > \n   >\n   > - 针对特定服务发布，影响小，风险小，成本低\n   > - 频繁发布版本，快速交付需求\n   > - 低成本扩容，弹性伸缩，适应云环境\n   >\n   >  \n   >\n   > 我们知道一个朴素的理念，没有任何事物是完美的，任何东西都有两面性，有得必有失，那么在选择微服务在解决了快速响应和弹性伸缩的问题同时，它又给我们带来了什么问题？个人总结如下：\n   >\n   > \n   >\n   > - 分布式系统的复杂性\n   > - 部署，测试和监控的成本问题\n   > - 分布式事务和CAP的相关问题\n   >\n   >  \n   >\n   > 系统应用由原来的单体变成几十到几百个不同的工程，会所产生例如包括服务间的依赖，服务如何拆封，内部接口规范，数据传递等等问题，尤其是服务拆分，需要团队熟悉业务流程，懂得取舍，要保证拆分的粒度服务既符合“高内聚，低耦合”的基本原则，还要兼顾业务的发展以及公司的愿景，要还要说服团队成员为之努力，并且积极投入，在多方中间取得平衡。\n   >\n   > \n   >\n   > 对于分布式系统，部署，测试和监控都需要大量的中间件来支撑，而且中间件本身也要维护，原先单体应用很简单的事务问题 ，转到分布式环境就变得很复杂，分布式事务是采用简单的重试+补偿机制，还是采用二阶段提交协议等强一致性方法来解决，就要取决对业务场景的熟悉加上反复的权衡了，相同问题还包括对 CAP 模型的权衡，总之微服务对团队整体的技术栈水平整体要求更高\n   >\n   > monolithic单片  microserives 微服务\n   >\n   > \n   >\n   > <img src=\"https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409191717.png\" style=\"zoom:50%;\" />\n   >\n   > \n\n   \n\n4. ### 使用微服务应该遵循哪些原则？\n\n   > 古人云：兵马未动，粮草先行。建设微服务是需要建立长远规划，不是像写CMS那样建好数据库表，然后就开始干活，这样十有八九是会失败的。我们要进行微服务改造前，架构师要提前做好规划，我们把这里分为三步，前期阶段，设计阶段，技术阶段\n   >\n   > \n   >\n   > 前期阶段，大致要做好如下事情：\n   >\n   > - 和多方充分沟通，确保能符合客户和组织的需求，并且得到认同\n   > - 和团队沟通，让队友（开发/测试/运维）理解，并且积极投入\n   > - 和业务部门沟通，指定版本计划和上线时间\n   >\n   >  \n   >\n   > 设计阶段，参考 Sam Newman 的著作[《微服务设计》](https://book.douban.com/subject/26772677/)，单微服务必须要满足以下的条件，才符合微服务的基本要求：\n   >\n   > - 标准的 **REST 风格**接口（基于 HTTP 和 JSON 格式）\n   > - **独立部署**，避免共享数据库（避免因为数据库而影响整个分布式系统）\n   > - 业务上的高内聚，**减少依赖**（从设计上要避免服务过大或者太小）\n   >\n   >  \n   >\n   > 庞大的分布式系统，需要强大基础设施来支撑，微服务涉及哪些基础设施？\n   >\n   > - CI/CD和自动化（分布式系统几乎不可能通过人工手动发布）\n   > - 虚拟化技术（要保证微服务运行环境隔离，目前行业主流的是使用 **Docker 容器**）\n   > - 日志聚合，全链路监控（高度可观察和分析诊断问题）\n   >\n   >  \n   >\n   > 说了那么多，那什么样的情况下，你的团队不适合建设微服务？（请勿对号入座）\n   >\n   > 1. 开发团队不具备自主性，所在组织对开发团队限制非常多（具体请参考 [康威定律](https://zh.wikipedia.org/wiki/康威定律)）\n   >\n   > 2. 团队不熟悉业务，无法识别出服务的边界，进行合理的拆分（请参考 DDD [领域驱动设计](https://en.wikipedia.org/wiki/Domain-driven_design)）\n   >\n   >    <img src=\"https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409192152.png\" style=\"zoom:50%;\" />\n\n5. ### 总结\n\n   > 微服务设计其实是很早就有的设计思想，因为随着虚拟化技术的崛起，微服务可以低成本的实现，所以也开始流行和兴起。\n   >\n   > 微服务的内涵很深，其中就包括，自动化，去中心化，独立性等等，其中细节无法用一篇文章概述清楚，我们在做技术选型或者方案的时候，尽可能多去了解技术的本身和起源再结合我们业务的特点，进行更好的选择。","tags":["概念解析"]},{"title":"2020年02月29日软件设计师每日一练","url":"/2020/04/11/2020年02月29日软件设计师每日一练/","content":"\n### 1.软件维护类型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411152744.png)\n\n#### 2.题目解析\n\n> 1. 改正性维护也叫正确性维护，是指在使用过程中发现了隐蔽的错误后，为了诊断和改正这些隐蔽错误而修改软件的活动。 \t\n> 2. 适应性维护是指为了适应变化了的环境而修改软件的活动。 \n> 3. 完善性维护是指为了扩充或完善原有软件的功能或性能而修改软件的活动。\n> 4. 预防性维护是指为了提高软件的可维护性和可靠性、为未来的进一步改进打下基础而修改软件的活动。 \t\n> 5. 综上所述，可知针对应用在运行期的数据特点，修改其排序算法使其更高效属于完善性维护。\n\n<!--more-->\n\n### 2.MVC模式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411153011.png)\n\n#### 2.题目解析\n\n> MVC模式，即模型一视图一控制（Model-View-Controller）模式，它实际上是一种架构模式，是为那些需要为同样的数据提供多个视图的应用程序而设计的，它很好地体现了数据层与表示层的分离。<br>\n>\n>  &nbsp;&nbsp;&nbsp; MCV把应用程序分为3种对象类型。<br>\n>  　　·模型：应用问题域中包含的抽象领域知识；<br>\n>  　　·视图：将应用问题域中包含的抽象领域知识呈现给用户的方法；一个模型可以用于多个视图；<br>\n>  　　·控制器：用户界面对用户输入的响应方式。\n\n### 3.逆向工程\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411153257.png)\n\n#### 2.题目解析\n\n> **逆向工程产品设计可以认为是一个从产品到设计的过程**。简单地说，\n>\n> 逆向工程产品设计就是根据已经存在的产品，反向推出产品设计数据（包括各类设计图或数据模型）的过程。这个过程一般是在软件交付使用之后进行，\n>\n> 所以是在原软件生命周期的软件维护阶段进行。\n\n### 4.面向对象的基本概念\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411153411.png)\n\n#### 2.题目解析\n\n>    多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。也就是说客户类其实在调用方法时，并不需要知道特定子类的实现，都会用统一的方式来调用。\n\n### 5.算法基础和常见的算法\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411153550.png)\n\n#### 2.题目解析\n\n> 分支限界法一般以**广度优先**或以**最小耗费（最大效益）优先**的方式搜索问题的解空间，那么肯定能找出最优解。<br>\n> 贪心算法的思想是：**总是做出在当前来说是最好的选择，而并不从整体上加以考虑，它所做的每步选择只是当前步骤的局部最优选择，**但从整体来说不一定是最优的选择。所以用该算法并不能保证求得0-1背包问题的最优解。<br>\n> 回溯法的思想是：按选优条件向前搜索，以达到目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。它其实是遍历了整个解空间，所以肯定能找到最优解。<br>\n>\n> 动态规划法的思想是：在求解问题中，对于每一步决策，列出各种可能的局部解，再依据某种判定条件，舍弃那些肯定不能得到最优解的局部解，在每一步都经过筛选，以每一步都是最优解来保证全局是最优解。它能求得0-1背包问题的最优解。\n\n### 6.输入输出控制方式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411153806.png)\n\n#### 2.题目解析\n\n> - **指令周期（Instruction Cycle）**：取出并执行一条指令的时间。<br>\n>\n> - **总线周期（BUS Cycle）**：也就是一个访存储器或I/O端口操作所用的时间。<br>\n>\n> - **时钟周期（Clock Cycle）**：又称震荡周期，是处理操作的最基本单位。<br>\n>\n> - **指令周期、总线周期和时钟周期之间的关系**：一个指令周期由若干个总线周期组成，而一个总线周期时间又包含有若干个时钟周期。<br>\n>\n> - 一个总线周期包含一个（只有取址周期）或多个机器周期。<br> \n>   &nbsp;机器周期：在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。<br>\n>   &nbsp;DMA响应过程为：DMA控制器对DMA请求判别优先级及屏蔽，向总线裁决逻辑提出总线请求。当CPU执行完当前总线周期即可释放总线控制权。此时总线裁决逻辑输出总线应答，表示DMA已经响应，通过DMA控制器通知I/O接口开始DMA传输。\n>\n>    \n\n#### 3.知识牵引  DMA（直接存储器访问） [网站](https://baike.baidu.com/item/DMA/2385376?fr=aladdin)\n\n> DMA(Direct Memory Access，直接存储器访问) 是**所有现代电脑的重要特色**，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到[暂存器](https://baike.baidu.com/item/暂存器/4308343)，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。\n>\n> - 中文名\n>\n>   直接存储器访问\n>\n> - 外文名\n>\n>   Direct Memory Access\n>\n> - 缩  写\n>\n>   DMA\n>\n> - 功  能\n>\n>   不同速度的硬件装置来沟通\n>\n> - 来  源\n>\n>   嵌入式底层驱动\n>\n> - ## 原理\n>\n>    \n>\n>   DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。像是这样的操作并没有让[处理器](https://baike.baidu.com/item/处理器)工作拖延，反而可以被重新排程去处理其他的工作。DMA 传输对于高效能 嵌入式系统算法和网络是很重要的。\n>\n>    DMA\n>\n>   ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411154302.png)\n>\n>   \n>\n>   在实现DMA传输时，是由DMA控制器直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器，而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。一个完整的DMA传输过程必须经过DMA请求、DMA响应、DMA传输、DMA结束4个步骤。\n>\n>   ### 请求\n>\n>   CPU对DMA控制器初始化，并向[I/O接口](https://baike.baidu.com/item/I%2FO接口)发出操作命令，I/O接口提出DMA请求。\n>\n>   ### 响应\n>\n>   DMA控制器对DMA请求判别优先级及屏蔽，向总线裁决逻辑提出总线请求。当CPU执行完当前总线周期即可释放总线控制权。此时，总线裁决逻辑输出总线应答，表示DMA已经响应，通过DMA控制器通知I/O接口开始DMA传输。\n>\n>   ### 传输\n>\n>   DMA控制器获得总线控制权后，CPU即刻挂起或只执行内部操作，由DMA控制器输出读写命令，直接控制RAM与I/O接口进行DMA传输。\n>\n>   在DMA控制器的控制下，在存储器和外部设备之间直接进行数据传送，在传送过程中不需要中央处理器的参与。开始时需提供要传送的数据的起始位置和数据长度。\n>\n>   ### 结束\n>\n>   当完成规定的成批数据传送后，DMA控制器即释放总线控制权，并向I/O接口发出结束信号。当I/O接口收到结束信号后，一方面停 止I/O设备的工作，另一方面向CPU提出中断请求，使CPU从不介入的状态解脱，并执行一段检查本次DMA传输操作正确性的代码。最后，带着本次操作结果及状态继续执行原来的程序。\n>\n>   由此可见，DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为RAM与I/O设备开辟一条直接传送数据的通路，使CPU的效率大为提高。\n\n\n\n### 7.风险管理\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411154342.png)\n\n#### 2.题目解析\n\n>    本题考查风险预测知识。风险预测从风险发生的可能性大小以及风险发生所产生的后果是否严重两个方面评估风险。\n\n### 8.保护范围和对象\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200411154419.png)\n\n#### 2.题目解析\n\n>  专利审查指南的规定：<br>\n> 在审查过程中，对于不同的申请人同日 （指申请日，有优先权的指优先权日） 就同样的发明创造分别提出专利申请，并且这两件申请符合授予专利权的其他条件的，应当根据专利法实施细则第四十一条第一款的规定，\n>\n> 通知申请人自行协商确定申请人。\n\n####  ","tags":["软件设计考题"]},{"title":"2020年02月28日软件设计师每日一练","url":"/2020/04/10/2020年02月28日软件设计师每日一练/","content":"\n### 1.排序与查找\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410113412.png)\n\n<!--more-->\n\n#### 2.题目解析\n\n> **插入排序的基本思想是逐个将待排序元素插入到已排序的有序表中。**\n>\n> 假设n个待排序元素存储在数组R[n+1]中(R[0]预留)，则：<br>\n> (1)初始时数组R[1..1]中只包含元素R[1]，则数组R[1..1]必定有序；<br>\n> (2)从i=2到n，执行步骤3；<br>\n> (3)此时，数组R被划分成两个子区间，分别是有序区间R[1..i-1]和无序区间R[i..n]，将当前无序区间的第1个记录R[i]插入到有序区间R[1..i]中适当的位置上，使R[1..i]变为新的有序区间。<br>\n> 在实现的过程中，设置监视哨R[0]，并从R[i-1]到R[0]查找元素R[i]的插入位置<br>\n> 那么用插入排序对数组&lt;3，1，4，1，5，9，6，5&gt;进行排序的过程为：<br>\n> 原元素序列：&nbsp; 监视哨&nbsp; &nbsp;（3），1，4，1，5，9，6，5<br>\n>\n> 第一趟排序：&nbsp; &nbsp;&nbsp;1&nbsp; （1，3），4，1，5，9，6，5&nbsp;&nbsp;&nbsp; 1插入时与3比较1次<br>\n> 第二趟排序：&nbsp; &nbsp;&nbsp;4&nbsp; （1，3，4），1，5，9，6，5&nbsp;&nbsp;&nbsp; 4插入时与3比较1次<br>\n> 第三趟排序：&nbsp; &nbsp;&nbsp;1&nbsp; （1，1，3，4），5，9，6，5&nbsp;&nbsp;&nbsp; 1插入时分别与4、3、1比较1次，共比较3次<br>\n> 第四趟排序：&nbsp; &nbsp;&nbsp;5&nbsp; （1，1，3，4，5），9，6，5&nbsp;&nbsp;&nbsp; 5插入时与4比较1次<br>\n> 第五趟排序：&nbsp; &nbsp;&nbsp;9&nbsp; （1，1，3，4，5，9），6，5&nbsp;&nbsp;&nbsp; 9插入时与5比较1次<br>\n> 第六趟排序：&nbsp;&nbsp;&nbsp; 6&nbsp; （1，1，3，4，5，6，9），5&nbsp;&nbsp;&nbsp; 6插入时与9和5分别比较1次，共比较2次<br>\n> 第七趟排序：&nbsp;&nbsp;&nbsp; 5&nbsp; （1，1，3，4，5，5，6，9）&nbsp;&nbsp; 5插入时与9，6，5分别比较1次，共比较3次。<br>\n> 那么整个排序过程需要比较的次数为12次。<br>\n>\n> **归并排序的思想是将两个相邻的有序子序列归并为一个有序序列，然后再将新产生的相邻序列进行归并，当只剩下一个有序序列时算法结束。**\n>\n> 其基本步骤如下：<br>\n> (1)将n个元素的待排序序列中每个元素看成有序子序列，对相邻子序列两两合并，则将生成n/2个子有序序列，这些子序列中除了最后一个子序列长度可能小于2外，其他的序列长度都等于2；<br>\n> (2)对上述n/2个长度为2的子序列再进行相邻子序列的两两合并，则产生n/4个子有序序列，同理，只有最后一个子序列的长度可能小于4；<br>\n> (3)第i趟归并排序为，对上述n/i个长度为i的子序列两两合并，产生n/2i个长度为2i的子有序序列；<br>\n> (4)重复执行此步骤，直到生成长度为n的序列为止。<br>\n> 那么用归并排序对数组&lt;3，1，4，1，5，9，6，5&gt;进行排序的过程为：<br>\n> 原元素序列：&nbsp; 3，1，4，1，5，9，6，5<br>\n> 第一趟排序： [1，3]，[1，4]，[5，9]，[5，6]&nbsp;&nbsp;&nbsp; 比较4次<br>\n> 第二趟排序： [1，1，3，4]， [5，5，6，9]&nbsp;&nbsp; &nbsp;&nbsp;前半部分比较3次，后半部分比较3次<br>\n> 第三趟排序： [1，1，3，4，5，5，6，9]&nbsp;&nbsp; 5分别与1，1，3，4比较一次，共比较4次，后面的序列都不小于5，因此可以直接复制到结果序列。<br>\n> 所以整个排序过程需要比较的次数为14次。 \n>\n> \n\n### 2.Linux命令行\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410113917.png)\n\n#### 2.题目解析\n\n> 修改linux文件权限命令：chmod。\n\n#### 3.知识牵引\n\n> [Linux命令行详解](https://blog.csdn.net/u012104219/article/details/79125771)\n\n### 3.数据的表示\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410114309.png)\n\n#### 2.题目解析\n\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410114331.png)\n\n### 4.磁盘存储\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410114427.png)\n\n#### 2.题目解析\n\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410114444.png)\n\n### 5.开发系统互连参考模型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410114503.png)\n\n#### 2.题目解析\n\n> 路由器是用于连接多个**逻辑上分开**的网络，所谓\n>\n> - 逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，**路由器具有判断网络地址和选择IP路径的功能。** \n> - 路由器的每个端口所连接的网络都独自构成一个广播域。\n>\n> 集线器内部，各接口都是通过背板总线连接在一起的，在逻辑上构成一个共享的总线。所以，集线器和所有接口的主机共同构成了一个冲突域和一个广播域。\n>\n>  交换机上每个接口都是自己的一个冲突域。交换机和所有的接口所连接的主机共同构成了一个广播域。\n\n### 6.HTML语言\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410114839.png)\n\n#### 2.题目解析\n\n>  本题考查的是HTML基本标签的使用。\n>\n> - alink用于设置正在被击中的链接的颜色。\n> - vlink用于设置已使用的链接的颜色。\n> - background用于设置背景图片的URL。\n> - bgcolor用于设置文档整体背景颜色。\n\n### 7.软件设计\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410115029.png)\n\n#### 2.题目解析\n\n> 数据耦合:两个模块彼此间通过数据参数交换信息。 \n>\n> <br>\n> 标记耦合:一组模块通过参数表传递记录信息，这个记录是某一个数据结构的子结构，而不是简单变量。<br>\n> <br>\n> 控制耦合:两个模块彼此间传递的信息中有控制信息。<br>\n> <br>\n> 内容耦合:一个模块需要涉及到另一个模块的内部信息。<br>\n> <br>\n> 本题应该选择B选项。\n\n### 8.面向对象的基本概念\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410120707.png)\n\n#### 2.题目解析\n\n> 聚合对象是指一个对象包含其他对象。\n\n### 9.线性表\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410120927.png)\n\n#### 2.题目解析\n\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200410120953.png)","tags":["软件设计师考题"]},{"title":"SpringBoot介绍","url":"/2020/04/09/SpringBoot详解/","content":"\n1. 官方文档解析\n\n   #### 1.介绍Spring Boot\n\n   > Spring Boot可以轻松创建可以运行的独立的，生产级的基于Spring的应用程序。我们对Spring平台和第三方库采取自己的看法，以便您尽可能轻松地使用本教程。大多数Spring Boot应用程序只需要很少的Spring配置。\n   >\n   > 您可以使用Spring Boot来创建可以使用java -jar或更传统的war部署来启动的Java应用程序 。我们还提供了一个运行“spring script”的命令行工具。\n   >\n   > 我们的主要目标是：\n   >\n   > - 为所有Spring开发提供一个更快，更广泛的入门体验。\n   >\n   > - 立即开始开发。\n   >\n   > - 提供大型项目（如嵌入式服务器，安全性，指标，运行状况检查和外部配置）通用的一系列非功能性功能。\n   >\n   > - 绝对不会生成代码，并且不需要XML配置。\n   >\n   >   \n\n2. springbooot\n\n   1.启动流程\n\n   > <img src=\"https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409202136.png\" style=\"zoom:150%;\" />\n\n   ","tags":["技术介绍"]},{"title":"2020年02月27日软件设计师每日一练","url":"/2020/04/09/2020年02月27日软件设计师每日一练/","content":"\n### 1.正规式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409160004.png)\n\n#### 2.题目解析\n\n>   B项从0到1然后走不了了，C项在3状态结束，不对；D项也只到1状态。 \n\n### 2.其他\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409160055.png)\n\n#### 2.题目解析\n\n>  运行Web浏览器的计算机与网页所在的计算机首先要建立TCP连接，采用HTTP协议传输网页文件。\n>\n> HTTF是Hyper Text Transportation Protocol（超文本传输协议）的缩写，是计算机之间交换数据的方式。\n>\n> HTTP应用的相当广泛，其主要任务是用来浏览网页，但也能用来下载。用户是按照一定的规则（协议）和提供文件的服务器取得联系，并将相关文件传输到用户端的计算机中来。\n\n### 3.专业英语\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409160447.png)\n\n#### 2.题目解析\n\n> 一个项目是一个(临时)独特的、复杂的、相关的活动序列，它有一个目标或目的,必须在特定的时间完成,在预算之内,并且遵循相关说明书。\n>\n> 项目管理是针对在有限时间内以最低成本完成一个可接受系统的开发，其范围、计划、人员、组织、指导和控制的过程。\n>\n> <span>对于任何系统开发项目而言，有效的项目管理</span>是必要的\n>\n> 以一个可接受的预算开发和实现，并且符合用户的期望和规范。\n>\n> 项目管理是一个从项目开始，到项目结束，贯穿整个项目，直到项目完成才结束的过程。\n>\n> 良好的项目管理的先决条件是定义良好的系统开发过程。过程管理是一种持续的活动，它记录、管理和改进组织为系统开发所选择的方法(“过程”)。流程管理涉及的活动、可交付成果和质量标准适用于所有的项目。\n>\n> （1）A-</pmicrosoft></pmicrosoft></pmicrosoft></pmicrosoft></pmicrosoft>任务&nbsp; &nbsp; B-工作&nbsp; &nbsp; C-序列&nbsp; &nbsp; D-活动\n>\n> （2）A-规格说明书  B-规则  C-估计  D-设计\n>\n> （3）A-完美的  B-可接受的  C-受约束的  D-完整的\n>\n> （4）A-工期  B-规范  C-期望  D-需求\n>\n> （5）A-单个的  B-特定的  C-一些的  D-所有的\n\n### 4.多媒体技术\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409165125.png)\n\n#### 2.题目解析\n\n>\n> 本题考查计算机音乐信息处理技术的相关知识。WAV格式记录的是对于音乐信号的波形采样数据，它可以使用反映自然声音的信号采样序列来记录和回放声音信息。MIDI格式记录的是采用音乐信息序列交换的标准格式MIDI （ Musical Instrument Digital interface）标准来存贮和表达音乐的演奏信息，这些演奏信息包含每个音符演奏的时间信息、音量信息、长度信息、乐器或音色信息等，MID工消息序列可以间接反映出音乐的曲谱演奏信息。\n\n### 5.软件开发模型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409165454.png)\n\n#### 2.题目解析\n\n> 本题考查的是常见的软件开发模型的基本概念。<br>\n> \t&nbsp;&nbsp;&nbsp; 瀑布模型给出了软件生存周期中制定开发计划、需求分析、软件设计、编码、测试和维护等阶段以及各阶段的固定顺序，上一阶段完成后才能进入到下一阶段，整个过程如同瀑布流水。该模型为软件的开发和维护提供了一种有效的管理模式，但在大量的实践中暴露出其缺点，其中最为突出的是缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题。这些问题有可能造成开发出的软件并不是用户真正需要的，并且这一点只有在开发过程完成后才能发现。所以瀑布模型适用于需求明确，且很少发生较大变化的项目。<br>\n> \t&nbsp;&nbsp;&nbsp; 为了克服瀑布模型的上述缺点，演化模型允许在获取了一组基本需求后，通过快速分析构造出软件的一个初始可运行版本（称作原型），然后根据用户在适用原型的过程中提出的意见对原型进行改进，从而获得原型的新版本。这一过程重复进行，直到得到令用户满意的软件。该模型和螺旋模型、喷泉模型等适用于对软件需求缺乏明确认识的项目。<br>\n> \t&nbsp;&nbsp;&nbsp; 螺旋模型将瀑布模型和演化模型进行结合，在保持二者优点的同时，增加了风险分析，从而弥补了二者的不足。该模型沿着螺线旋转，并通过笛卡尔坐标的四个象限分别表示四个方面的活动：制定计划、风险分析、实施工程和客户评估。螺旋模型为项目管理人员及时调整管理决策提供了方便，进而可降低开发风险.<br>\n> \t&nbsp;&nbsp;&nbsp; 喷泉模型是以面向对象的软件开发方法为基础.以用户需求为动力，以对象来驱动的模型。该模型主要用于描述面向对象的开发过程，体现了面向对象开发过程的迭代和无间隙特性。迭代指模型中的活动通常需要重复多次，相关功能在每次迭代中被加入新的系统。无间隙是指在各开发活动（如分析、设计、编码）之间没有明显边界。\n\n### 6.行业标准\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409165657.png)\n\n#### 2.题目解析\n\n> 《标准化法》第二章第七条规定“国家标准、行业标准分为强制性标准和推荐性标准。保障人体健康，人身、财产安全的标准和法律、行政法规规定强制执行的标准是强制性标准，其他标准是推荐性标准。<br>\n>  &nbsp;&nbsp;&nbsp; “省、自治区、直辖市标准化行政主管部门制定的工业产品的安全、卫生要求的地方标准，在本行政区域内是强制性标准。”<br>\n>  &nbsp;&nbsp;&nbsp; 按照我国《标准化法》的规定，上海市标准化行政主管部门制定并发布的工业产品的安全、卫生要求的标准，在其行政区域内是强制性标准。\n\n### 7.ER模型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409165944.png)\n\n#### 2.题目解析\n\n>  不同的数据模型具有不同的数据结构形式。目前最常用的数据结构模型有层次模型（hierarchical model）、网状模型（network model）、关系模型（relational Model）和面向对象数据模型（object oriented model）。其中层次模型和网状模型统称为非关系模型。非关系模型的数据库系统在20 世纪70年代非常流行，在数据库系统产品中占据了主导地位。到了20年纪80年代，逐渐被关系模型的数据库系统取代，但某些地方，由于历史的原因，目前层次和网状数据库系统仍在使用。\n>\n>    关系模型是目前最常用的数据模型之一。关系数据库系统采用关系模型作为数据的组织方式，在关系模型中用二维表格结构表达实体集以及实体集之间的联系，其最大特色是描述的一致性。关系模型是由若干个关系模式组成的集合。一个关系模式相当于一个记录烈，对应于程序设计语言中类型定义的概念。关系是一个实例，也是一张表，对应于程序设计语言中变量的概念。给定变量的值随时间可能发生变化；类似地，当关系被更新时，关系实例的内容也随时间发生了变化。\n\n### 8.开发系统互连参考模型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409170023.png)\n\n#### 2.题目解析\n\n>  中继器是物理层设备，其作用是对接收的信号进行再生放大，以延长传输的距离。\n>\n> 网桥是数据链路层设备，可以识别MAC地址，进行帧转发。\n>\n> 交换机是由硬件构成的多端口网桥，也是一种数据链路层设备。路由器是网络层设备，可以识别IP地址，进行数据包的转发。\n\n### 9.数字证书\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200409170206.png)\n\n#### 2.题目解析\n\n> 第一空考查的是关于用户身份进行认证也就是数字签名的认证，这里使用的应该是发送方的公钥，这4个选项中，能包含发送方公钥的只有A选项数字证书；<br>\n>\n> 第二空确保消息不可否认，也就是考查确保发送者身份的不可抵赖，所以这里使用的应该是发送方的数字签名。","tags":["软件设计师考题"]},{"title":"2020年02月26日软件设计师每日一练","url":"/2020/04/08/2020年02月26日软件设计师每日一练/","content":"\n### 1.编译与解释\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408162457.png)\n\n#### 2.题目解析\n\n> 本题考查程序语言基础知识。<br>\n>\n> 对C源程序进行编译时，需建立符号表，其作用是记录源程序中**各个符号（变量等）的必要信息**，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。符号表的建立可以始于词法分析阶段，也可以放到语法分析和语义分析阶段，但符号表的使用有时会延续到目标代码的运行阶段。\n\n### 2.数据的表示\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408162658.png)\n\n#### 2.题目解析\n\n> **对阶时，小数向大数看齐；对阶是通过较小数的尾数右移实现的。**\n\n### 3.CISC和RISC\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408162908.png)\n\n#### 2.题目解析\n\n本题考查计算机复杂指令集。 答案 A</div>\n<div>\n\tCISC计算机指复杂指令集计算机，是20世纪六、七十年代发展起来的系列计算机。这种计算机所支持的指令系统趋于多用途、强功能化。指令系统围绕着缩小与高级语言的语义差距以及有利于操作系统的优化而设计。指令系统的复杂化使得设计周期变长，正确性难于保证，不易维护。而且在复杂的指令系统中，只有少数基本指令是经常使用的，需要大量硬件支持的复杂指令利用率却很低。所以在70年代末，随着VLSI技术的发展产生了RISC计算机。</div>\n<br>\n<div>\n\tRISC计算机指精简指令集计算机，这种计算机有下列特点。</div>\n<div>\n\t(1)指令系统中只包含使用频率较高但不复杂的指令。</div>\n<div>\n\t(2)指令长度固定，指令格式少，寻址方式少。</div>\n<div>\n\t(3)只有存取数指令访问主存，其他指令都在寄存器之间运算。</div>\n<div>\n\t(4)大部分指令在一个机器周期内完成，采用流水技术。</div>\n<div>\n\t(5)CPU中增加了通用寄存器的数量。</div>\n<div>\n\t(6)硬联逻辑控制，不用微程序控制技术。</div>\n<div>\n\t(7)采用优化的编译，以有效地支持高级语言。</div>\n\n​              \n\n### 4.分布式数据库\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408163059.png)\n\n#### 2.题目解析\n\n> 本题考查的是分布式数据库相关知识。<br>\n>\n> - 分片透明：是指用户不必关系数据是如何分片的，它们对数据的操作在全局关系上进行，即关系如何分片对用户是透明的，因此，当分片改变时应用程序可以不变。分片透明性是最高层次的透明性，如果用户能在全局关系一级操作，则数据如何分布，如何存储等细节自不必关系，其应用程序的编写与集中式数据库相同。<br>\n> - 复制透明：用户不用关心数据库在网络中各个节点的复制情况，被复制的数据的更新都由系统自动完成。在分布式数据库系统中，可以把一个场地的数据复制到其他场地存放，应用程序可以使用复制到本地的数据在本地完成分布式操作，避免通过网络传输数据，提高了系统的运行和查询效率。但是对于复制数据的更新操作，就要涉及到对所有复制数据的更新。<br>\n> - 位置透明：是指用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的<br>\n>   局部映像透明性（逻辑透明）是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关系局部DBMS支持哪种数据模型、使用哪种数据操纵语言，数据模型和操纵语言的转换是由系统完成的。因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。<br>\n>\n> 本题提到不需要了解具体如何分块存储，如果描述为不需要了解物理存储或存储位置，则为位置透明，而涉及到如果分块存储，应该为分片透明。对于分布式数据库，分片是一种大局性的划分，而物理上的存储位置则更为底层，所以对于如何分块存储，强调更多的是分片而不是物理位置。\n\n### 5.数据的表示\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408163249.png)\n\n#### 2.题目解析\n\n> ​    在计算机中，n位补码（表示数据位），表示范围是-2<sup>n-1</sup>~+2<sup>n-1</sup>-1，其中最小值为人为定义，以n=8为例，其中-128的补码是人为定义的1000 0000。\n\n### 6.白盒测试案例\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408163440.png)\n\n#### 2.题目解析\n\n>  本题考查软件测试方法中白盒测试的基础知识。<br>\n>\n> **白盒测试也称为结构测试，**根据程序的内部结构和逻辑来设计测试用例，对程序的执行路径和过程进行测试，检查是否满足设计的需要。白盒测试常用的技术涉及不同覆盖标准，在测试时需根据指定的覆盖标准确定测试数据。\n\n### 7.面向对象的基本概念\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408163547.png)\n\n#### 2.题目解析\n\n> 单一职责原则：设计目的单一的类，本题描述“就一个类而言，应该仅有一个引起它变化的原因”属于单一职责原则。 \n>\n> 开放-封闭原则：对扩展开放，对修改封闭<br> \n>\n> 里氏（Liskov）替换原则：子类可以替换父类<br> \n>\n> 接口隔离原则：使用多个专门的接口比使用单一的总接口要好","tags":["软件设计师考题"]},{"title":"2020年02月25日软件设计师每日一练","url":"/2020/04/07/2020年02月25日软件设计师每日一练/","content":"\n### 1.网络安全协议\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408155828.png)\n\n#### 2.题目解析\n\n> TLS是安全传输层协议的简称，用于在两个通信应用程序之间提供保密性和数据完整性。<br>\n> \t\n>\n> SSL是安全套接层协议的简称，它也是一种为网络通信提供安全和数据完整性的协议，它与TLS非常接近，它们都是在传输层对网络连接进行加密。<br>\n> \t\n>\n> PGP是一个基于RSA公匙加密体系的邮件加密软件。，用它可以对邮件保密以防止非授权者阅读。<br>\n> \t\n>\n> HTTPS即安全版的HTTP（超文本传输协议）的，它是在HTTP下加入SSL层，HTTPS的安全基础就是SSL。<br>\n>\n> IPSec是网络层的安全协议，它通过使用加密的安全服务来确保在网络上进行保密而安全的通讯。\n\n### 2.软件设计\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408155943.png)\n\n#### 2.题目解析\n\n> 系统结构图（SC）又称为模块结构图，它是软件概要设计阶段的工具，反映系统的功能实现和模块之间的联系与通信，包括各模块之间的层次结构，即反映了系统的总体结构。 \n>\n> SC包括模块、模块之间的调用关系、模块之间的通信和辅助控制符号等4个部分。\n\n### 3.设计模式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408160814.png)\n\n#### 2.题目解析\n\n>\n> ​\t\tA选项：策略模式（Strategy）：定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化。<br>\n>\n> ​\t\tB选项：抽象工厂模式（Abstract Factory）:提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类。</div>\n> ​\t\n>\n> ​\t\tC选项：观察者模式（有时又被称为发布-订阅Subscribe&gt;模式、模型-视图View&gt;模式、源-收听者Listener&gt;模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。</div>\n>\n> ​\t\tD选项：状态模式（State）：允许一个对象在其内部状态改变时改变它的行为\n>\n> 本题题干描述属于策略模式。\n\n\n\n### 4.多媒体技术概念\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408161125.png)\n\n#### 2.题目解析\n\n>   dpi是Dots Per Inch的缩写，也就是每英寸的像素。\n\n### 5.段页式存储\n\n#### 1.题目\n\n#### ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408161216.png)\n\n#### 2.题目解析\n\n页式存储中的逻辑地址与物理地址之间的变换需要掌握变换的规则。 \n\n 逻辑地址的构成是：逻辑页号+页内地址。 \n\n \n\t物理地址的构成是：物理块号+页内地址。 \n \n\t从构成可以看出逻辑地址与物理地址的页内地址是一样的，不同的是逻辑页号与物理块号。而这两者的关系，正是通过题目已给出的表来进行映射的。如逻辑页号1就对应着物理块号3。 \n \n\t所以题目告诉我们“逻辑地址为十六进制1D16H”时，我们先要把逻辑地址中的页号与页内地址分离。</p>\n \n\t通过什么条件分离呢？ \n \n\t题目中的“<span style=\"color: rgb(255, 0, 0);\">计算机系统页面大小为4K</span>”，从这句话可以看出，页内地址是二进制的12位（4K=2<sup><span style=\"color: rgb(255, 0, 0);\"><font size=\"2\">12</font></span></sup>）。二进制12位对应十六进制3位。 \n\t所以D16H是页内地址。页号也就是1了。通过页表查询到物理块号：3。所以物理地址是：3D16H。\n\n\n\n### 6.操作系统\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408161904.png)\n\n#### 2.题目解析\n\n> 本题考查的是UNIX操作系统中设备管理的基本概念。<br>\n>  　　\n>\n> 在UNIX操作系统中，**把输入/输出设备看作是特殊文件。**\n>\n> 在UNIX系统中包括两类设备：块设备和字符设备。设备特殊文件有一个索引节点，在文件系统目录中占据一个节点，但其索引节点上的文件类型与其他文件不同，是“块”或者是“字符”特殊文件。文件系统与设备驱动程序的接口是通过设备开关表。硬件与驱动程序之间的接口：控制寄存器、I/O指令，一旦出现设备中断，根据中断矢量转去执行相应的中断处理程序，完成所要求的I/O任务。这样，可以通过文件系统与设备接口，对设备进行相关的操作，因为每个设备有一个文件名，可以向访问文件那样操作。\n\n### 7.关系？？？\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408162202.png)\n\n#### 2.题目解析\n\n> ×S表示关系R与关系S的笛卡尔积，其结果是一个具有n（n的值由关系R与S的元组个数共同决定）行7列元素的二维表，σ<sub>4&lt;5</sub> (R×S)是选取表中第4列（R.D）元素值小于第5列（S.C）元素值的记录，然后对这个结果进行投影操作，即选取出第3（R.C）、4（R.D）、7（S.E）列组成一个新表。<br>\n> \t因此第53空的结果应该为R.C，R.D，S.E，而第54空是从关系表R和S中进行查找，查找的条件为R.D元素值小于S.C元素值，即R.D&lt;S.C。\n\n### 8.UML\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408162307.png)\n\n#### 2.题目解析\n\n>  类图和对象图反映了设计视图的静态特征，状态图和活动图反映了系统的动态特征\n\n####  ","tags":["软件设计师考题"]},{"title":"2020年02月24日软件设计师每日一练","url":"/2020/04/06/2020年02月24日软件设计师每日一练/","content":"\n### 1.SQL语言\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408154537.png)\n\n#### 2.题目解析\n\n>  **赋予用户权限命令**的简单格式可以概括为：GRANT 权限ON 数据库对象TO 用户 WITH GRANT OPTION。 而WITH GRANT OPTION是可选项，表示用户可以将其权限通过GRANT语句授权给其它用户。因此本题的正确答案应分别是INSERT ON和WITH GRANT OPTION。\n\n### 2.UML\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408154645.png)\n\n#### 2.题目解析\n\n>  参与者是指存在于系统外部并直接与系统进行交互的人、系统、子系统或类的外部实体的抽象。\n\n### 3.Gant图和Pert图\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408154803.png)\n\n#### 2.题目解析\n\n>  本题中，关键路径为：ABDGIKL，其长度为22，所以最短工期22天。 \n>\n> **BD是关键路径上的活动，其总时差为0，不能被耽误，有任何延误，都会影响总工期，**所以BD最多延误0天不会影响总工期。\n\n### 4.绝对路径和相对路径\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408154956.png)\n\n#### 2.题目解析\n\n> 该题考查的是操作系统中文件管理的内容。</p>\n>\n> Windows操作系统中的文件目录结构： \n> 在对数据文件进行操作时，一般要用盘符指出被操作的文件或目录在哪一磁盘。盘符也称驱动器名。 \n> 文件是按一定格式建立在外存储介质上的一组相关信息的集合。 计算机中的文件，一般上存储在磁盘、光盘或磁带中，如果没有特殊说明，我们认为文件上存储在磁盘上的，称为磁盘文件。每一个文件必须有一个名字，称为文件名。\n>\n> 文件目录，即Windows操作系统中的文件夹。为了实现对文件的统一管理，同时又方便用户，操作系统采用树状结构的目录来实现对磁盘上所有文件的组织和管理。根目录用“\\”表示，从根目录或当前目录至所要找的文件或目录所需要经过的全部子目录的顺序组合。 \n>\n> 绝对路径指的是从根目录开始到目标文件或目录的一条路径。所以fault.swf文件的绝对路径是“\\swshare\\flash\\fault.swf”，即该文件的全文件名。\n>\n> 相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。使用相对路径可以为我们带来非常多的便利。“.”和“..”分别表示当前目录和上一级目录。&nbsp;当前工作目录为swshare，该目录下swshare子目录中有文件fault.swf，所以fault.swf相对路径为.\\flash\\或flash\\。\n\n\n\n### 5.软件项目风险\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408155210.png)\n\n#### 2.题目解析\n\n>    软件项目风险是指在软件开发过程中遇到的预算和进度等方面的问题以及这些问题对软件项目的影响。软件风险分析包括风险识别、风险预测、风险评估和风险控制共4个不同活动。\n>\n> 其中风险控制是利用某些技术和方法设法避开或转移风险，在此活动中，通常需要考虑风险避免、风险监控和风险管理及意外事件计划3方面问题。 \n\n### 6.总线系统\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408155314.png)\n\n#### 2.题目解析\n\n                                    总线的带宽指单位时间内传输的数据总量。\n> 在计算机当中，时钟频率是其时钟周期的倒数，表示时间的度量，本题时钟周期为1/200MHz。<br>\n> 总线宽度是指总线的线数，即数据信号并行传输的能力，本题传送大小与总线宽度一致，不需要处理。<br>\n> <br>\n> 传送32bit的字，即数据总量为32bit；5个时钟周期，即(1/200MHz) *5，为总时间。<br>\n> <br>\n> 带宽=数据总量/总时间（注意单位的转换）<br>\n> <br>\n> 即总带宽=32bit/（5/200MHz）=1280Mbit/s=160MB/s。\n\n### 7.关系自然连接\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408155516.png)\n\n#### 2.题目解析\n\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408155542.png)\n\n### 8.电脑系统\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200408155601.png)\n\n#### 2.题目解析\n\n> 软件的\n>\n> - 可扩充性指软件的体系结构、数据设计和过程设计的可扩充程度，可扩充性影响着软件的灵活性和可移植性。软件可靠性指软件按照设计要求，在规定时间和条件下不出故障，可持续运行的程度，\n> - 可靠性取决于软件的一致性、安全性、容错性和准确性等.\n> - 复用性指软件或软件的部件能被再次用于其他应用中的程度，软件复用性取决于其模块独立性、通用性和数据共享性等。\n> - 可移植性指将软件系统从一个计算机系统或环境移植到另一种计算机系统或环境中运行时所需工作量的大小，可移植性取决于系统中硬件设备的特征、软件系统的特点和开发环境、系统分析与设计中关于通用性、软件独立性和可扩一充性等方面的考虑。\n\n####  ","tags":["软件设计师考题"]},{"title":"2020年02月23日软件设计师每日一练","url":"/2020/04/05/2020年02月23日软件设计师每日一练/","content":"\n### 1.树与二叉树\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407214828.png)\n\n#### 2.题目解析\n\n> &nbsp;&nbsp;&nbsp; 本题考查哈夫曼树。<br>\n>\n> ​    构造最优二叉树的哈夫曼算法如下。<br>\n> ​\t&nbsp;&nbsp;&nbsp; ① 根据给定的n个权值｛w1， w2，…，Wn｝构成n棵二叉树的集合F= {T1.T2，…，Tn}，其中每棵树T;中只有一个带权为w;的根结点，其左右子树均空。<br>\n> ​\t&nbsp;&nbsp;&nbsp; ② 在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，置新构造二叉树的根结点的权值为其左、右子树根结点的权值之和。<br>\n> ​\t&nbsp;&nbsp;&nbsp; ③从F中删除这两棵树，同时将新得到的二叉树加入到F中。<br>\n> ​\t&nbsp;&nbsp;&nbsp; 重复②、③，直到F中只含一棵树时为止。这棵树便是最优二叉树（哈夫曼树）。从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度是从树根到每一个结点的路径长度之和。树的带权路径长度为树中所有叶子结点的带权路径长度之和。<br>\n> ​\t&nbsp;&nbsp;&nbsp; 因此，C为最优二叉树，其带权路径长度（12+6）*3+15*2+23*2+29*2=188。<br>\n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407215151.png)\n\n#### 3.知识牵引（哈夫曼树）\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407215326.png)\n\n> 在[计算机](https://baike.baidu.com/item/计算机)[数据处理](https://baike.baidu.com/item/数据处理)中，哈夫曼编码使用[变长编码表](https://baike.baidu.com/item/变长编码表)对源符号（如文件中的一个字母）进行编码，其中[变长编码表](https://baike.baidu.com/item/变长编码表)是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、[期望值](https://baike.baidu.com/item/期望值)降低，从而达到[无损压缩](https://baike.baidu.com/item/无损压缩)数据的目的。\n>\n> 例如，在英文中，e的出现[机率](https://baike.baidu.com/item/机率)最高，而z的出现概率则最低。当利用哈夫曼编码对一篇英文进行压缩时，e极有可能用一个[比特](https://baike.baidu.com/item/比特)来表示，而z则可能花去25个[比特](https://baike.baidu.com/item/比特)（不是26）。用普通的表示方法时，每个英文字母均占用一个[字节](https://baike.baidu.com/item/字节)，即8个[比特](https://baike.baidu.com/item/比特)。二者相比，e使用了一般编码的1/8的长度，z则使用了3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。\n>\n> 哈夫曼树又称最优二叉树，是一种带权路径长度最短的[二叉树](https://baike.baidu.com/item/二叉树)。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1*L1+W2*L2+W3*L3+...+Wn*Ln），N个权值Wi（i=1,2,...n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,...n）。可以证明哈夫曼树的WPL是最小的。\n>\n> ## 应用\n>\n> **1、**[哈夫曼编码](https://baike.baidu.com/item/哈夫曼编码)\n>\n> 在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。若报文中可能出现26个不同字符，则固定编码长度为5。然而，传送报文时总是希望总长度尽可能短。在实际应用中，各个字符的出现频度或使用次数是不相同的，如A、B、C的使用频率远远高于X、Y、Z，自然会想到设计编码时，让使用频率高的用短码，使用频率低的用长码，以优化整个报文编码。\n>\n> 为使不等长编码为前缀[编码](https://baike.baidu.com/item/编码/80092)(即要求一个字符的编码不能是另一个字符编码的前缀)，可用字符集中的每个字符作为叶子结点生成一棵编码二叉树，为了获得传送报文的最短长度，可将每个字符的出现频率作为字符结点的权值赋予该结点上，显然字使用频率越小权值越小，权值越小叶子就越靠下，于是频率小编码长，频率高编码短，这样就保证了此树的最小带权路径长度效果上就是传送报文的最短长度。因此，求传送报文的最短长度问题转化为求由字符集中的所有字符作为叶子结点，由字符出现频率作为其权值所产生的哈夫曼树的问题。利用哈夫曼树来设计二进制的前缀编码，既满足前缀编码的条件，又保证报文编码总长最短。\n>\n> **哈夫曼静态编码：**它对需要编码的数据进行两遍扫描：第一遍统计原数据中各字符出现的频率，利用得到的频率值创建哈夫曼树，并必须把树的信息保存起来，即把字符0-255(2^8=256)的频率值以2-4BYTES的长度顺序存储起来，（用4Bytes的长度存储频率值，频率值的表示范围为0--2^32-1，这已足够表示大文件中字符出现的频率了）以便解压时创建同样的哈夫曼树进行解压；第二遍则根据第一遍扫描得到的哈夫曼树进行编码，并把编码后得到的码字存储起来。\n>\n> **哈夫曼动态编码：**动态哈夫曼编码使用一棵动态变化的哈夫曼树，对第t+1个字符的编码是根据原始数据中前t个字符得到的哈夫曼树来进行的，编码和解码使用相同的初始哈夫曼树，每处理完一个字符，编码和解码使用相同的方法修改哈夫曼树，所以没有必要为解码而保存哈夫曼树的信息。编码和解码一个字符所需的时间与该字符的编码长度成正比，所以动态哈夫曼编码可实时进行。\n>\n> **2、哈夫曼[译码](https://baike.baidu.com/item/译码)**\n>\n> 在通信中，若将字符用哈夫曼编码形式发送出去，对方接收到编码后，将编码还原成字符的过程，称为哈夫曼译码。\n>\n> ## 基本术语\n>\n> 哈夫曼树又称为最优树.\n>\n> **1、路径和路径长度**\n>\n> 在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。\n>\n> **2、结点的权及带权路径长度**\n>\n> 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407215749.png)\n>\n> **3、树的带权路径长度**\n>\n> 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。\n\n### 2.多种程序语言特点\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407215834.png)\n\n#### 2.题目解析\n\n> ​\tHTML：静态网页<br>\n> ​\tLISP：一种基于λ演算的函数式编程语言<br>\n> ​\tPHP ：混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页。\n\n### 3.其他\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407215925.png)\n\n#### 2.题目解析\n\n> &nbsp;&nbsp;&nbsp; 商标专用权是企业、事业单位和个体工商业者，对其生产、制造、加工、拣选或者经销的商品，向商标局申请商品商标注册，经商标局核准注册的商标为注册商标，所取得的专用权，受法律保护。并且，促使生产者、制造者、加工者或经销者保证商品质量和维护商标信誉，对其使用注册商标的商品质量负责，便于各级工商行政管理部门通过商标管理，监督商品质量，制止欺骗消费者的行为。<br>\n>  &nbsp;&nbsp;&nbsp; 实用新型专利权是受我国《专利法》保护的发明创造权利。实用新型专利权被授予后，除法律另有规定的以外，任何单位或者个人未经专利权人许可，不得为生产经营目的制造、使用、销售其专利产品，或者使用其专利方法以及使用、销售依照该专利方法直接获得的产品。<br>\n>  &nbsp;&nbsp;&nbsp; 因此，小王购买了“海之久”牌活动硬盘，只享有该U盘的所有权，而不享有题目中所提及活动硬盘的其他权利。\n\n### 4.编译与解析\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407220126.png)\n\n#### 2.题目解析\n\n> 本题考查程序语言基础知识。<br>\n> \t编译正确的程序可以消除词法及语法错误，但不能完全消除语义错误。<br>\n> \t语义错误分两类，静态语义错误可以通过编译程序检测发现，而动态语义错误需要到运行时才能被发现\n\n#### 3.知识牵引（[编程语言的语法和语义](https://www.cnblogs.com/feng9exe/p/6420516.html)）\n\n> 为了完整地定义编程语言，我们需要： \n> 语法，描述程序看起来是什么样的； \n> 语义，描述程序的含义。\n>\n> # 语法\n>\n> ## 语法的定义\n>\n> 每一种编程语言都有一系列规则，描述在那种语言中什么样的字符串被认为是有效程序。这些规则定义了这种语言的语法。通过语言的语法规则，我们能把像 y = x + 1 这样可能有效的程序与像 >/;x:1@4 这样毫无意义的字符串区分开。\n>\n> ## 抽象语法树\n>\n> 当然，计算机程序的预期用途是被计算机读取，而要读程序就需要语法解析器：这个分析器程序能够读取代表程序的字符串，根据语法规则检查它是否有效，然后把它转换成一个适合被进一步处理的结构化表示。 \n> 有各种各样的工具能把一种语言的语法规则自动转换成一个语法解析器。 \n> 总体来讲一个语法解析器应该读入像 y = x + 1 这样的字符串，然后把它转换成抽象语法树（ AST）。抽象语法树是源代码的一种表示，去掉了空格之类的无关细节，而只关注程序的分层结构。\n>\n> ## 语法总结\n>\n> 语法关心的只是程序的表面是什么样的，而不是它的含义。程序有可能语法正确但没有任何实际意义。例如，程序 y = x + 1 本身可能没有任何意义，因为并没有事先说明 x 是什么，而程序 z = true + 1 可能会在运行时候报错，因为它试图在一个布尔型值上加数字。\n>\n> # 操作语义\n>\n> ## 操作语义定义\n>\n> 考虑程序含义的最实际方法是思考它做了些什么：在运行程序的时候，我们期望发生什么呢？在运行时编程语言中不同的结构都是如何表现的？把它们放到一起组成更大的程序时会是什么效果？ \n> 这是操作语义学（ operational semantic）的基础，这种方法为程序在某种机器上的执行定义一些规则，以此来捕捉编程语言的含义。这个机器常常是一种抽象的机器：\n>\n> ## 小步规约\n>\n> 那么，我们如何设计一台抽象机器，并使用它定义一种编程语言的操作语义呢？一种方法就是假想一台机器，用这台机器直接按照这种语言的语法进行操作一小步一小步地对其进行反复规约，从而对一个程序求值。不管最后得到的结果含义是什么，我们每一步都能让程序更接近最终结果。\n>\n> 这种小步规约类似于对代数式求值的方式。例如， 为了对 (1×2) + (3×4) 求值，我们知道应该：\n>\n> 1. 执行左侧的乘法（ 1×2 变成了 2），这样表达式就规约成了 2 + (3×4)；\n> 2. 执行右侧的乘法（ 3×4 变成了 12），这样表达式规约成了 2 + 12\n> 3. 执行加法（ 2 + 12 变成了 14），最终得到 14。\n>\n> 我们可以认为 14 就是结果， 因为通过上面步骤已经不能再进一步规约了；我们认为 14 是一个特殊代数表达式，它是一个值，有自己的含义，不需要进一步的努力了。\n>\n> ## 小步规约的形式化规则\n>\n> 把如何进行每一小步的规约写成形式化规则，这个非形式化的过程就可以转换成一个操作语义。 \n> 这些规则本身需要用某种语言（ 元语言）写下来，而这种语言通常是数学符号。 \n\n### 5.时间复杂度与空间复杂度**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407220524.png)\n\n#### 2.题目解析\n\n> 这是典型的01背包问题，动态规划算法中，自底向上（递推）：从小范围递推计算到大范围，可以看到装第一个和第五个物品价值是最高的，这时候V=12了，然后占了6的重量了，只能装物品2了，价值15。<br>\n> \t而此时的算法过程是对物品n和背包容量W分别进行比较以找到最优结果，因此时间复杂度为O(nW)。<br>\n> \t<br>\n> \t空（3）（4）是部分背包，部分背包的时候计算每个物品单位重量价值多少，单位重量v={3 1.5 5/6 0.8 1.5},可以看到1 2 5的单位价值最高，选择125后背包重量还只有8，还有2个重量可以选择3得等5/3的价值，就是1.67，所以第三问为16.67。<br>\n> \t再来看时间复杂度，本题先进行归并排序，然后再根据有序序列来选择放入背包的物品，因此算法分两部分，首先是归并排序时间复杂度为O(nlgn)，然后是放背包，因为已经排过序，所以只需要线性处理即可，此时时间复杂度为O(n)，综合起来，由于O(nlgn)&gt;O(n)，因此整体时间复杂度为O(nlgn)。\n\n### 6.软件设计\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407220618.png)\n\n#### 2.题目解析\n\n> 内聚是指模块内部各元素之间联系的紧密程度，模块的内聚类型通常可以分为7种，根据内聚度从高到低排序分别如下：<br>\n> \t功能内聚：完成一个单一功能，各个部分协同工作，缺一不可。<br>\n> \t顺序内聚：处理元素相关，而且必须顺序执行。<br>\n> \t通信内聚：所有处理元素集中在一个数据结构的区域上。<br>\n> \t过程内聚：处理元素相关，而且必须按特定的次序执行。<br>\n> \t瞬时内聚：所包含的任务必须在同一时间间隔内执行（如初始化模块）。<br>\n> \t逻辑内聚：完成逻辑上相关的一组任务。<br>\n> \t偶然内聚：完成一组没有关系或松散关系的任务。\n\n### 7.总线系统\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407220745.png)\n\n#### 2.题目解析\n\n​               总线的带宽指单位时间内传输的数据总量。 \n\n> 在计算机当中，时钟频率是其时钟周期的倒数，表示时间的度量，本题时钟周期为1/200MHz。<br>\n> 总线宽度是指总线的线数，即数据信号并行传输的能力，本题传送大小与总线宽度一致，不需要处理。<br>\n> <br>\n> 传送32bit的字，即数据总量为32bit；5个时钟周期，即(1/200MHz) *5，为总时间。<br>\n> <br>\n> 带宽=数据总量/总时间（注意单位的转换）<br>\n> <br>\n> 即总带宽=32bit/（5/200MHz）=1280Mbit/s=160MB/s。<br>\n> <br>","tags":["软件设计师考题"]},{"title":"2020年02月22日软件设计师每日一练","url":"/2020/04/04/2020年02月22日软件设计师每日一练/","content":"\n### 1.关系代数\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407200002.png)\n\n#### 2.题目解析\n\n>  关系R（A,B,C,D）和S（A,C,E,F）做自然连接时，**会以两个关系公共字段做等值连接**，然后将操作结果集中重复列去除，所以运算后属性列有（4+4）-2=6个。（A、C为重复列）因此，本题选择C选项。<br>\n> <br>\n>\n> 对于问题2，求自然连接的笛卡尔积等价表达式，首先笛卡尔积需要选取同属性名则值相等的元组，本题A、C为同属性名，因此需要满足R.A=S.A^R.C=S.C，转换为数字序号则为：<span style=\"font-size:14px;\">1=5^3=6。而对于选择条件R.B&gt;S.E，转换为数字序号，则为2&gt;7，注意D选项的'7'为字符而不是数字。<br>\n> <br>\n> 综上，本题选择B选项。\n\n### 2.TCP/IP协议族\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407200131.png)\n\n#### 2.题目解析\n\n>  DHCP客户端可从DHCP服务器获得本机IP地址、DNS服务器的地址、DHCP服务器的地址、默认网关的地址等，但没有Web服务器、邮件服务器地址。\n\n### 3.设计模式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407200237.png)\n\n#### 2.题目解析\n\n> - 外观模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。\n> - 适配器模式（Adapter）：将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作。\n> - 责任链模式（Chain of Responsibility）：通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。\n> - 桥接模式（Bridge）：将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化。\n\n### 4.数据库事务处理\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407200427.png)\n\n#### 2.题目解析\n\n>本题考查的是数据库事务处理方面的基础知识。\n>\n>并发事务如果对数据读写时不加以控制，会破坏事务的隔离性和一致性。控制的手段就是加锁，在事务执行时限制其他事务对数据的读取。在并发控制中引入两种锁：排它锁&lt; Exclusive Locks， X锁）和共享锁（Share Locks ， S锁）。 \n>\n>排它锁又称为写锁，用于对数据进行写操作时进行锁定。如果事务T对数据A加上X锁后，就只允许事务T对数据A进行读取和修改，其他事务对数据A不能再加任何锁，从而也不能读取和修改数据A，直到事务T释放A上的锁。 \n>\n>共享锁又称为读锁，用于对数据进行读操作时进行锁定。如果事务T对数据A加上了S锁后，事务T就只能读数据A但不可以修改。其他事务可以再对数据A加S锁来读取，只要数据A上有S锁，任何事务都只能再对其加S锁读取而不能加X锁修改。因此，正确答案是D。\n\n### 5.数据库安全性\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407200605.png)\n\n#### 2.题目解析\n\n> DMBS是数据库管理系统，主要用来保证数据库的安全性和完整性。而DBA通过授权功能为不同用户授权，主要的目的是为了保证数据的安全性。                                                                              \n\n### 6.树与二叉树\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407200829.png)\n\n#### 2.题目解析\n\n> 本题考查数据结构基础知识。<br>\n> 　　具有m个结点的二叉树采用二叉链表存储结构，链表中共有m个结点，每个结点中两个指针（当前结点的左、右孩子指针），则共有2m个指针。除了树根之外，其余的每个结点都由一个来自父结点的指针所指向，因此该二叉链表结点中的空指针总数必定为2m-（m-1）=m+1个，可以充分利用这些空指针域来存放结点的前驱和后继信息。<br>\n> 　　对图（a）所示的二叉树进行中序线索化后如图（b）所示。<br>\n> 假设指针s指向中序线索二叉树中的某结点，则s→right指向的结点不一定是s所指结点的直接后继结点。当s结点具有右子树时，s→right指向其右子树而不是后继结点。同理，s→left指向的结点不一定是s所指结点的直接前驱结点。在线索二叉树中，s所指结点的left和right指针可能指向相同的结点，从s所指结点出发的right链可能构成环。\n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407201638.png)\n\n### 7.校验方法\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407201717.png)\n\n#### 2.题目解析\n\n> 本题考查校验方法。<br>\n> \t　　奇偶校验是一种简单有效的校验方法。这种方法通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）或者为偶数（偶校验），从而使码距变为2。它可以检测代码中奇数位出错的编码，但不能发现偶数位出错的情况，即当合法编码中奇数位发生了错误，即编码中的1变成0或0变成1，则该编码中1的个数的奇偶性就发生了变化，从而可以发现错误。<br>\n> \t　　海明码也是利用奇偶性来检错和纠错的校验方法。海明码的构成方法是:在数据位之间插入k个校验位，通过扩大码距来实现检错和纠错。<br>\n> \t例如，对于8位的数据位，进行海明校验需要4个校验位。令数据位为D7、D6、D5、D4、D3、D2、D1、D0，校验位为P4、P3、P2、P1，形成的海明码为H12、H11、…、H3、H2、H1，对应关系如下所示：\n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407201800.png) 　　\n>\n> 循环冗余校验码广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生k个校验位来进行编码，其编码长度为k+r，CRC的代码格式为：\n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407201829.png)\n>\n>  　　循环冗余校验码是由两部分组成的，左边为信息码（数据〕，右边为校验码。若信息码占k位，则校验码就占n-k位。校验码是由信息码产生的，校验码位数越长.该代码的校验能力就越强.在求CRC编码时，采用的是模2运算。\n\n### 8.位示图\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407201934.png)\n\n#### 2.题目解析\n\n> &nbsp;&nbsp;&nbsp; 位示图法是为管理磁盘空闲存储空间而提出的一种方法，该方法是在外存上建立一张位示图来记录文件存储器的使用情况。每一位仅对应文件存储器上的一个物理块，取值0和1分别表示空闲和占用。<br>\n> \t&nbsp;&nbsp;&nbsp; 在本题中，题目告诉我们字长32位，即一个字可以表示32个物理块得使用情况，而物理块依次编号为：0、1、2、…，那么第4096号物理块的使用情况应该在位示图中的第129个字中描述，因为（4096+1）/32等于128余1，所以这一位应属于第129个字的第一位，其中4096+1的这个1是因为编号是从0开始计数的，所以才加1。<br>\n> \t&nbsp;&nbsp;&nbsp; 由于磁盘的容量为200GB，每个物理块的大小为1MB，那么总共有200GB/1MB=200 x1024个物理块，需要200 x1024位来表示，因此位示图中字的个数=200 x1024/32=6400个。\n\n#### 3.知识牵引\n\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407202255.png)\n>\n> ## 简介 \n>\n> 位示图是利用二进制的一位来表示磁盘中的一个盘块的使用情况。当其值为“0”时，表示对应的盘块空闲；为“1”时，表示已经分配。有的系统把\"0\"作为盘块已分配的标记，把“1”作为空闲标志。(它们的本质上是相同的，都是用一位的两种[状态标志](https://baike.baidu.com/item/状态标志)空闲和已分配两种情况。)磁盘上的所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位构成一个集合，称为位示图。通常可用m*n个位数来构成位示图，并使m*n等于磁盘的总块数。\n>\n> 位示图也可描述为一个二维数组map:\n>\n> Var map：array of bit；\n>\n> 位示图用于存储空间的分配和回收。\n>\n> ## 位示图的实现\n>\n> ### 1. 定义：\n>\n> 位示图（bitmap）又叫位图，它的最小单元是一个bit。每个bit有两种取值1或0。\n>\n> 位示图是一种非常常用的结构，在索引，数据压缩等方面有广泛应用。本文介绍了位图的实现方法及其应用场景。\n>\n> ### 2. 实现\n>\n> 在C/C++中没有位示图这种数据类型，下面我们利用int来实现一个位示图类\n>\n> 每个int有sizeof(int)*8个bit","tags":["软件设计师考题"]},{"title":"2020年02月21日软件设计师每日一练","url":"/2020/04/03/2020年02月21日软件设计师每日一练/","content":"\n### 1.算法分析方法\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407181939.png)\n\n#### 2.题目解析\n\n> 本题考查基本的算法分析方法。<br>\n>  　　根据递归定义式，对F（5）的求解过程可由以下递推式表示:<br>\n>  &nbsp;&nbsp;&nbsp; F（5）=F（4）+F（3）=F（3）+ F（2）+F（3）=F（2）+F（1）+F（2）+F（2）+F（1）<br>\n>  &nbsp; =F（1）+F（0）+ F（1）+ F（1）+ F（0）+ F（1）+ F（0）+ F（1）<br>\n>  　　因此计算F（5）需要7次“+”运算，该递归定义采用了分治的策略。 \n\n3.知识牵引（回溯）\n\n> 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优[搜索](https://baike.baidu.com/item/搜索/2791632)法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称\n>\n> ## 基本思想\n>\n> 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。\n>\n> [八皇后问题](https://baike.baidu.com/item/八皇后问题)就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的[节点](https://baike.baidu.com/item/节点)，从而减少状态空间树节点的生成。[回溯法](https://baike.baidu.com/item/回溯法)是一个既带有系统性又带有跳跃性的的[搜索算法](https://baike.baidu.com/item/搜索算法)。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而[回溯法](https://baike.baidu.com/item/回溯法)在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。\n\n### 2.设计模式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407182336.png)\n\n#### 2.题目解析\n\n> 命令模式的特点为：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。本题描述为命令模式。<br>\n> <br>\n> 职责链模式（Chain of Responsibility）：通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。<br>\n> <br>\n> 观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。<br>\n> <br>\n>\n> 策略模式（Strategy）：定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化。 \n\n\n\n### 3.防火墙技术\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407182453.png)\n\n#### 2.题目解析\n\n> 本题考查防火墙的概念。防火墙是指设置在不同网络或网络安全域之间的一系列部件组合，是不同网络或网络安全域之间信息的唯一出入口，能根据安全策略控制出入网络的信息流。<br>\n>  &nbsp;　　防火墙一般由软件以及支持该软件运行的硬件系统构成;能控制经过防火墙的双向信息，而不仅仅是某个方向的信息;防火墙可以过滤一些网络攻击，但一般无法定位攻击。防火墙的主要支撑技术是包过滤技术。<br>\n>  　　从上面的内容可以看出，B、C、D三个选项都是错误的，只有A是正确的。</p>\n\n### 4.索引文件\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407182547.png)\n\n#### 2.题目解析\n\n> 设块长为512B，每个块号占3B，一个物理块可放：512/3=170个目录项（向下取整），也即：<br>\n> \t一个一级索引可存放的文件大小为：`（170×512）B/1024=85KB。`<br>\n> \t一个二级索引可存放文件的大小为：（170×170×512）B/1024=14,450KB。<br>\n> \t一个三级索引可存放文件的大小为：（170×170×170×512）B/1024=2,456,500KB。<br>\n> \t这里还要请大家注意，计算过程中，对于1个物理块可放的目录项需要向下取整，并且注意单位转换。\n\n### 5.可靠性\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407182716.png)\n\n#### 2.题目解析\n\n> 容错系统\n>\n> 是指在一定程度上具有容错功能的系统，实现容错的主要办法就是**冗余，冗余附加技术的构成主要包括冗余备份程序的存储及调用、实现错误检测和错误恢复的程序、实现容错软件所需的固化程序。**\n\n### 6.排序与查找\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407182915.png)\n\n#### 2.题目解析\n\n>  选项中的序列是对堆做类似于层次遍历的操作所得的结果。将4个选项还原为堆时，其中D答案中第二个关键字小于第五个关键字，不满足小根堆的条件。                                                                              \n\n### 7.软件过程改进\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407183029.png)\n\n#### 2.题目解析\n\n> &nbsp;&nbsp;&nbsp; 本题考查软件能力成熟度集成模型的基础知识。<br>\n> \t&nbsp;&nbsp;&nbsp; 能力成熟度集成模型CMMI是CMM模型的最新版本，**基于连续式表述的CMMI共有6个（0-5）能力等级**，对应于未完成级、已执行级、已管理级、已定义级、量化管理级、优化级。每个能力等级对应到一个一般目标，以及一组一般执行方法和特定方法。<br>\n>\n> 1. ​\t能力等级0指未执行过程，表明过程域的一个或多个特定目标没有被满足；\n> 2. ​\t能力等级1指过程通过转化可识别的输入工作产品，产生可识别的输出工作产品，关注于过程域的特定目标的完成；\n> 3. ​\t能力等级2指过程作为已管理的过程制度化，针对单个过程实例的能力；\n> 4. ​\t能力等级3指过程作为已定义的过程制度化，关注过程的组织级标准化和部署；\n> 5. ​\t能力等级4指过程作为定量管理的过程制度化；能力等级5指过程作为优化的过程制度化，表明过程得到很好地执行且持续得到改进。\n\n### 8.UML\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407183217.png)\n\n#### 2.题目解析\n\n>    统一过程的基本特征是用例驱动、以架构为中心的迭代式增量开发。其核心的工作流包括捕获用户需求、分析、设计、实现和测试等。首先，开发人员通过和用户的沟通、了解，捕获用户需求并制作软件用例图（用况图），从而得到软件的用况模型。然后分析并设计满足这些用例的系统，得到分析模型、设计模型和实施模型，进而实现该系统，最后通过测试模型来验证系统是否满足用况中描述的功能。\n>\n> **需求捕获过程中得到的用例**将各个核心工作流结合为一个整体，驱动整个软件开发过程。\n\n### 9.网络安全控制技术\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407183309.png)\n\n#### 2.题目解析\n\n>    防火墙技术、访问控制技术和入侵检测技术都属于网络安全控制技术，而差错控制技术是一种用来保证数据传输质量的技术，不属于网络安全控制技术。","tags":["软件设计师考题"]},{"title":"2020年02月20日软件设计师每日一练","url":"/2020/04/02/2020年02月20日软件设计师每日一练/","content":"\n### 1.传址与传值\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407185110.png)\n\n#### 2.题目解析\n\n> 传值调用最显著的特征就是被调用的函数内部对形参的修改不影响实参的值。\n>\n> 引用调用是将实参的地址传递给形参，使得形参的地址就是实参的地址。\n\n### 2.RUP\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407185217.png)\n\n#### 2.题目解析\n\n>  本题考查RUP中每个阶段结束时所产生的里程碑。初启阶段结束时的里程碑是生命周期目标；精化阶段结束时的里程碑是生命周期架构；构建阶段结束时的里程碑是最初运作能力；移交阶段的里程碑是产品发布。\n\n#### 3.知识牵引（RUP）\n\n> RUP（Rational Unified Process），[统一软件开发过程](https://baike.baidu.com/item/统一软件开发过程/2088774)，[统一软件过程](https://baike.baidu.com/item/统一软件过程)是一个[面向对象](https://baike.baidu.com/item/面向对象/2262089)且基于网络的程序开发方法论。\n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407185435.png)\n\n> 软件统一过程（RUP）是Rational软件公司（Rational公司被IBM并购）创造的软件工程方法。RUP描述了如何有效地利用商业的可靠的方法开发和部署软件，是一种重量级过程（也被称作厚方法学），因此特别适用于大型软件团队开发大型项目。\n>\n> ## 三大特点\n>\n> RUP最重要的它有三大特点：1）软件开发是一个迭代过程，2）软件开发是由Use Case驱动的，3）软件开发是以架构设计（Architectural Design）为中心的。\n>\n> ### 迭代模型\n>\n> RUP强调软件开发是一个迭代模型(Iterative Model)，它定义了四个阶段(Phase)：初始(Inception)、细化(Elaboration)、构造(Construction)、交付(Transition)。其中每个阶段都有可能经历以上所提到的从商务需求分析开始的各个步骤，只是每个步骤的高峰期会发生在相应的阶段，例如开发实现的高峰期是发生在构造阶段。实际上这样的一个开发方法论是一个二维模型，这种迭代模型的实现在很大程度上提供了及早发现隐患和错误的机会，因此被现代大型信息技术项目所采用。 [2] \n>\n> ### 用例驱动\n>\n> RUP的另一大特征是用例驱动。用例是RUP方法论中一个非常重要的概念。简单地说，一个用例就是系统的一个功能。在系统分析和系统设计中，用例被用来将一个复杂的庞大系统分割、定义成一个个小的单元，这个小的单元就是用例。然后以每个小的单元为对象进行开发。按照RUP过程模型的描述，用例贯穿整个软件开发的生命周期。在需求分析中，客户或用户对用例进行描述，在系统分布和系统设计过程中，设计师对用例进行分析，在开发实现过程中，开发编程人员对用例进行实现，在测试过程中，测试人员对用例进行检验。 [2] \n>\n> ### 以架构为中心\n>\n> RUP的第三大特征是它强调软件开发是以构架为中心的。构架设计(ArchitecturalDesign)是系统设计的一个重要组成部分。在构架设计过程中，设计师(Architect)必须完成对技术和运行平台的选取，整个项目的基础框架( Framework)的设计，完成对公共组件的设计，如审计( Auditing)系统、日志(Iog)系统、错误处理(Exception Handling)系统、安全(Security)系统等。设计师必须对系统的可扩展性( Extensibility)、安全性(Security)、可维护性( Maintainability)、可延拓性(Scalability)、可重用性(Reusability)和运行速度(Performance)提出可行的解决方案。 [2]\n>\n> ## 优势\n>\n> ### 迭代式开发\n>\n> 在软件开发的初期就想完全、准确地获得用户的需求基本是不可能的。实际上，设计者常常碰到的问题是需求在整个软件开发过程中经常会发生变化。而迭代式开发允许每次迭代开发过程中需求发生变化，它正是通过不断迭代来细化对问题的理解。这样，迭代式开发大大降低了项目开发的风险，提高了软件开发的效率。 [1] \n>\n> ### 需求管理\n>\n> 准确地确定系统的需求是一个连续渐进的过程，开发人员不可能在系统开发之前就完全详细地理解系统的全部需求。而RUP正是提供了如何获得、组织系统的功能和约束条件并将其文档化的方法。 [1] \n>\n> ### 便于复用的软件体系结构\n>\n> 组件是可复用的单位，为了达到软件复用的目的，可以由组件来组成系统。基于独立的、可替换的、模块化组件的体系结构的优点是它方便管理，并能有效地提高软件的重用性。RUP展示了如何设计一个灵活的、有很强适应性的、有利于理解和便于复用的软件体系结构。 [1] \n>\n> ### 有利于可视化建模\n>\n> RUP常常和UML相互联系，这就有利于建立软件系统的可视化模型。RUP提供了对软件系统进行可视化建模的方法。 [1] \n>\n> ### 对软件质量进行验证\n>\n> 在RUP中，软件质量的评估不再是事后进行或单独小组进行的分离活动，而是贯穿于软件开发的过程中，这样就有利于及早发现软件中存在的不足。 [1]\n>\n> ## 开发过程\n>\n> RUP中的[软件生命周期](https://baike.baidu.com/item/软件生命周期)在时间上被分解为四个顺序的阶段，分别是：初始阶段（Inception）、细化阶段（Elaboration）、构造阶段（Construction）和交付阶段（Transition）。每个阶段结束于一个主要的里程碑（Major Milestones）；每个阶段本质上是两个里程碑之间的时间跨度。在每个阶段的结尾执行一次评估以确定这个阶段的目标是否已经满足。如果评估结果令人满意的话，可以允许项目进入下一个阶段。\n>\n> ### 初始阶段\n>\n> 初始阶段的目标是为系统建立商业案例并确定项目的边界。为了达到该目的必须识别所有与系统交互的外部实体，在较高层次上定义交互的特性。本阶段具有非常重要的意义，在这个阶段中所关注的是整个项目进行中的业务和需求方面的主要风险。对于建立在原有系统基础上的开发项目来讲，初始阶段可能很短。初始阶段结束时是第一个重要的里程碑：生命周期目标（Lifecycle Objective）里程碑。生命周期目标里程碑评价项目基本的生存能力。\n>\n> ### 细化阶段\n>\n> 细化阶段的目标是分析问题领域，建立健全的[体系结构](https://baike.baidu.com/item/体系结构)基础，编制[项目计划](https://baike.baidu.com/item/项目计划)，淘汰项目中最高风险的元素。为了达到该目的，必须在理解整个系统的基础上，对体系结构作出决策，包括其范围、主要功能和诸如性能等非功能需求。同时为项目建立支持环境，包括创建开发案例，创建模板、准则并准备工具。细化阶段结束时第二个重要的里程碑：生命周期结构（Lifecycle Architecture）里程碑。生命周期结构里程碑为系统的结构建立了管理基准并使项目小组能够在构建阶段中进行衡量。此刻，要检验详细的系统目标和范围、结构的选择以及主要风险的解决方案。\n>\n> ### 构造阶段\n>\n> 在构建阶段，所有剩余的[构件](https://baike.baidu.com/item/构件)和应用程序功能被开发并集成为产品，所有的功能被详细测试。从某种意义上说，构建阶段是一个制造过程，其重点放在管理资源及控制运作以优化成本、进度和质量。构建阶段结束时是第三个重要的里程碑：初始功能（Initial Operational）里程碑。初始功能里程碑决定了产品是否可以在[测试环境](https://baike.baidu.com/item/测试环境)中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运作。此时的产品版本也常被称为“beta”版。\n>\n> ### 交付阶段\n>\n> 交付阶段的重点是确保软件对最终用户是可用的。交付阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量的调整。在生命周期的这一点上，用户反馈应主要集中在产品调整，设置、安装和可用性问题，所有主要的结构问题应该已经在[项目生命周期](https://baike.baidu.com/item/项目生命周期)的早期阶段解决了。在交付阶段的终点是第四个里程碑：产品发布（Product Release）里程碑。此时，要确定目标是否实现，是否应该开始另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段的结束重合。\n>\n> 知识网址[](https://baike.baidu.com/item/RUP/8924595?fr=aladdin)\n\n\n\n### 3.开发模型（敏捷开发方法）\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407185645.png)\n\n#### 2.题目解析\n\n> 本题考查敏捷开发方法。<br>\n> \t　　极限编程（XP）是敏捷开发的典型方法之一，是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方法，它由价值观、原则、实践和行为4个部分组成。其中4大价值观为沟通、简单性、反馈和勇气。\n\n#### 3.知识牵引\n\n> 敏捷开发模式\n>\n> 是一种从1990年代开始逐渐引起广泛关注的一些新型[软件开发方法](https://baike.baidu.com/item/软件开发方法/971447)，是一种**应对快速变化的需求**的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于\"非敏捷\"，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而[自我组织](https://baike.baidu.com/item/自我组织)型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重做为软件开发中人的作用。\n>\n> ## 对比其它方法\n>\n> ### 1.瀑布模型\n>\n> 瀑布模型是由W.W.Royce在1970年最初提出的软件开发模型，　瀑布式开发是一种老旧的计算机软件开发方法。\n>\n> 瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。\n>\n> 步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。\n>\n> 瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，\n>\n> 代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。\n>\n> ### 2.迭代式开发\n>\n> 迭代式开发也被称作迭代增量式开发或迭代进化式开发，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。\n>\n> 什么是迭代式开发？\n>\n> 每次只设计和实现这个产品的一部分,\n>\n> 逐步逐步完成的方法叫迭代开发,\n>\n> 每次设计和实现一个阶段叫做一个迭代.\n>\n> 在迭代式开发方法中，整个开发工作被组织为一系列的短小的、\n>\n> 固定长度（如3周）的小项目，被称为一系列的迭代。\n>\n> 每一次迭代都包括了需求分析、设计、实现与测试。\n>\n> 采用这种方法，开发工作可以在需求被完整地确定之前启动，\n>\n> 并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。\n>\n> 再通过客户的反馈来细化需求，并开始新一轮的迭代。\n>\n> 迭代式开发的优点：\n>\n> 1、降低风险\n>\n> 2、得到早期用户反馈\n>\n> 3、持续的测试和集成\n>\n> 4、使用变更\n>\n> 5、提高复用性\n>\n> ### 3.螺旋开发\n>\n> 螺旋开发，1988年，巴利·玻姆(Barry Boehm)正式发表了软件系统开发的“螺旋模型”，它将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。\n>\n> “螺旋模型”刚开始规模很小，当项目被定义得更好、更稳定时，逐渐展开。\n>\n> “螺旋模型”的核心就在于您不需要在刚开始的时候就把所有事情都定义的清清楚楚。您轻松上阵，定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。如此不断轮回重复，直到得到您满意的最终产品。\n>\n> （1）制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；\n>\n> （2）风险分析：分析评估所选方案，考虑如何识别和消除风险；\n>\n> （3）实施工程：实施软件开发和验证；\n>\n> （4）客户评估：评价开发工作，提出修正建议，制定下一步计划。\n>\n> 螺旋模型很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。\n>\n> ### 4.敏捷开发\n>\n> 敏捷软件开发又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。\n>\n> - 人和交互重于过程和工具。\n> - 可以工作的软件重于求全而完备的文档。\n> - 客户协作重于合同谈判。\n> - 随时应对变化重于循规蹈矩。\n>\n> 其中位于右边的内容虽然也有其价值，但是左边的内容最为重要。\n>\n> 人员彼此信任 人少但是精干 可以面对面的沟通\n>\n> 项目的敏捷开发：\n>\n> 敏捷开发小组主要的工作方式可以归纳为：作为一个整体工作； 按短迭代周期工作； 每次迭代交付一些成果；\n>\n> 关注业务优先级； 检查与调整。\n>\n> 最重要的因素恐怕是项目的规模。规模增长，面对面的沟通就愈加困难，\n>\n> 因此敏捷方法更适用于较小的队伍，40、30、20、10人或者更少。\n>\n> 大规模的敏捷软件开发尚处于积极研究的领域。\n>\n> ### 四者对比区别：\n>\n> 传统的瀑布式开发，也就是从需求到设计，从设计到编码，从编码到测试，从测试到提交大概这样的流程，要求每一个开发阶段都要做到最好。\n>\n> 特别是前期阶段，设计的越完美，提交后的成本损失就越少。\n>\n> 迭代式开发，不要求每一个阶段的任务做的都是最完美的，而是明明知道还有很多不足的地方，却偏偏不去完善它，而是把主要功能先搭建起来为目的，以最短的时间，\n>\n> 最少的损失先完成一个“不完美的成果物”直至提交。然后再通过客户或用户的反馈信息，在这个“不完美的成果物”上逐步进行完善。\n>\n> 螺旋开发，很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。\n>\n> 敏捷开发，相比迭代式开发两者都强调在较短的开发周期提交软件，但是，敏捷开发的周期可能更短，并且更加强调队伍中的高度协作。\n>\n> 敏捷方法有时候被误认为是无计划性和纪律性的方法，实际上更确切的说法是敏捷方法强调适应性而非预见性。\n>\n> 适应性的方法集中在快速适应现实的变化。当项目的需求起了变化，团队应该迅速适应。这个团队可能很难确切描述未来将会如何变化.\n\n### 4.磁盘存储\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407193138.png)\n\n#### 2.题目解析\n\n\n系统读记录的时间为27/9=3ms， \n\n> 系统读记录的时间为27/9=3ms\n>\n> 对R0的处理，先读出记录需要3ms，然后处理需要3ms，同时磁头也在转动，当处理完R0时，磁头已经到达R2的位置。 \n>\n> 再处理R1 ，磁头需要旋转到R1的开始位置，再加上读取R0块和处理R0块的时间，至此，一共花费了30ms。<br>\n> <br>\n> ......<br>\n> <br>\n> 后面的R2至R8依此类推，当处理完R7并将磁头移到R8时总共耗时：8*30=240ms，再加上R8的读取和处理时间， \n>\n> 因此整个的时间为：8*30+3+3=246ms \n> <br>\n> 对于第二种情况，若对信息进行分布优化的结果如下所示：  \n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407193704.png)\n>\n> 从上表可以看出，当读出记录R1并处理结束后，磁头刚好转至R2记录的开始处，立即就可以读出并处理，因此处理9个记录的总时间为： >\n> &nbsp;&nbsp;&nbsp; 9×（3ms（读记录）＋3ms（处理记录））＝9 × 6ms=54ms\n\n\n\n### 5.知识产权人确定\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407193402.png)\n\n#### 2.题目解析\n\n>  &nbsp;　　因李某大学毕业后在M公司销售部门工作，后由于该公司软件开发部门人手较紧，李某被暂调到该公司软件开发部开发新产品，2周后，李某开发出一种新软件。该软件与工作任务有关，属于职务作品。所以，该项作品应属于软件公司所有。<br>\n>  　　法律依据:著作权法规定“执行本单位的任务或者主要是利用本单位的物质条件所完成的职务作品，其权利属于该单位。”<br>\n>  　　职务作品人是指作品人或者设计入执行本单位的任务，或者主要是利用本单位的物质技术条件所完成的作品的人。该作品的权利为该作品人所在单位所有。职务作品包括以下情形:<br>\n>  　　①在本职工作中做出的作品。<br>\n>  　　②履行本单位交付的本职工作之外的任务所做出的作品。<br>\n>  　　③退职、退休或者调动工作后1年内做出的，与其在原单位承担的本职工作或者原单位分配的任务有关的作品。<br>\n>  　　④主要利用本单位的物质技术条件（包括本单位的资金、设备、不对外公开的技术资料等）完成的作品。 \n\n\n\n### 6.系统可靠性计算\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407193450.png)\n\n#### 2.题目解析\n\n> 本题描述的系统中，两个P1部件形成`并联算法`，其可靠度为：<br>\n> \t&nbsp;&nbsp;&nbsp; 1-（1-0.9） ×（1-0.9）=0.99<br>\n> \t　　同样，两个P2部件形成并联子系统，其可称度为0.99。这两个并联子系统形成串联系统。所以整个系统的可靠性就是两个子系统可靠性的乘积，即0.99 × 0.99 =0.9801 。\n\n### 7.时间复杂度和空间复杂度\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407193627.png)\n\n#### 2.题目解析\n\n> 本题考查算法分析的基础知识。<br>\n> \t　　在算法分析中，符号O用于表示算法运行时间的上限。从定义上说，对一个函g(n)，O(g(n))表示函数集合：<br>\n> \t　　｛f(n)：存在正常数c和n0，使得对所有的n≥n0，有0≤f(n)≤cg(n)｝<br>\n> \t　　根据上述定义，可以知道表达式T(n)=an<sup>2</sup>+bnlgn+cn+d在函数集合O(n<sup>2</sup>)中。对此问题，\n>\n> 简单的做法是忽略n的低阶项和最高阶项n<sup>2</sup>的常系数，故答案应为O(n<sup>2</sup>)。\n\n### 8.设计模式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407193856.png)\n\n#### 2.题目解析\n\n> 适配器模式将一个接口转换成为客户想要的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。<br>\n>\n> 代理模式通过提供与对象相同的接口来控制对这个对象的访问。<br>\n>\n> 组合模式组合多个对象形成树型结构以表示整体—部分的结构层次。<br>\n>\n> 装饰器模式动态地给一个对象增加其他职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。\n\n### 9.图\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200407194000.png)\n\n#### 2.题目解析\n\n> 本题主要考查图的存储结构，\n>\n> 常见的图的存储结构有邻接矩阵存储和邻接表存储，其中在邻接矩阵存储方式中，矩阵中每个元素的值都表示两个点之间的边的信息，如果每两个点之间都有变的信息，那么矩阵中的所有元素都是有效元素，那么从存储空间的利用率角度来看，其利用率较高，而采用邻接表存储其存储空间利用率肯定低于邻接矩阵，\n>\n> 因为采用邻接表存储，不仅要存储边的信息，还要存储节点信息，指针信息等。<br>\n> \t\n>\n> 这种情况下，这个图很显然是一个完全图，因此从存储空间的利用率角度来看，完全图适合采用邻接矩阵存储。","tags":["软件设计师考题"]},{"title":"2020年02月19日软件设计师每日一练","url":"/2020/04/01/2020年02月19日软件设计师每日一练/","content":"\n### 1.索引文件\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401160441.png)\n\n#### 2.题目解析\n\n> 设块长为512B，每个块号占3B，一个物理块可放：512/3=170个目录项（向下取整），也即：<br>\n> \t一个一级索引可存放的文件大小为：（170×512）B/1024=85KB。<br>\n> \t一个二级索引可存放文件的大小为：（170×170×512）B/1024=14,450KB。<br>\n> \t一个三级索引可存放文件的大小为：（170×170×170×512）B/1024=2,456,500KB。<br>\n> \t这里还要请大家注意，计算过程中，对于1个物理块可放的目录项需要向下取整，并且注意单位转换。\n\n### 2.可靠性\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401161033.png)\n\n#### 2.题目解析\n\n>  可靠性指的是，软件产品与在规定的一段时间内和规定的条件下维持其性能水平有关的能力，是一个系统对于给定时间间隔内、在给定条件下无失效运作的概率。\n>\n> 它的子特性包括：成熟性、容错性、易恢复性，对于软件可靠性与软件潜在错误的数量、位置有关，并且与软件产品的使用方式有关，\n>\n> 对于软件产品的开发方式并不能决定软件产品的可靠性。\n\n### 3.运算器和控制器\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401161135.png)\n\n#### 2.题目解析\n\n> 运算器： \n>\n> ① 算术逻辑单元ALU\n>\n> ② 累加寄存器\n>\n> ③ 数据缓冲寄存器\n>\n> ④ 状态条件寄存器\n>\n> 控制器：\n>\n> ① 程序计数器PC\n>\n> ② 指令寄存器IR\n>\n> ③ 指令译码器\n>\n> ④ 时序部件       \n\n### 4.专业英语\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401180616.png)\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401180945.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401181005.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401181720.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401182130.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401182141.png)\n\n#### 2.题目解析\n\n> 基本上，云计算仅仅意味着将IT资源作为服务来提供。几乎所有的IT资源都可以作为一个云服务来提供：如应用程序，计算能力，存储容量，网络，编程工具，甚至通讯服务和协作工具。<br>\n>\n> 开始大规模提供云计算的互联网服务提供商有谷歌，亚马逊和其他一些基础建设商。云架构的特点是：系统不断扩大，水平分布系统资源，抽象的虚拟服务和管理，然后不断配置，汇集资源。在这种体系结构中，数据主要存放在“互联网某处”的服务器和“云服务”与客户端运行的应用程序上。\n>\n> 要想建立一个能收取使用费的云网格，必须要建立经得起单个元素或节点失败的云网格。当用网格来处理一批日常工作时，需要定义一个明确的开始和结束点，云服务可以是连续的。但更重要的是，云可以扩展可用的文件存储，数据库，网络服务来适用于网络和企业应用。\n\n### 5.多级存储体系\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401182418.png)\n\n#### 2.题目解析\n\n>  题目中的存储设备按访问速度排序为：通用寄存器> Cache>内存>硬盘。                                                                              \n\n### 6.数据库模式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401182641.png)\n\n#### 2.题目解析\n\n>  计算机数据库中的视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n\n### 7.知识产权人确定\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200401182711.png)\n\n#### 2.题目解析\n\n>  本题考查软件著作权方面的基础知识。接受他人委托开发的软件，其著作权的归属由委托人与受托人签订书面合同约定；无书面合同或者合同未作明确约定的，其著作权由受托人享有。                                                                              \n\n","tags":["软件设计师考题"]},{"title":"2020年02月18日软件设计师每日一练","url":"/2020/03/31/2020年02月18日软件设计师每日一练/","content":"\n### 1.有限自动机\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331164511.png)\n\n#### 2.题目解析\n\n> 1 既是初态也是终态，从图中可以看出a能连续出现，保持在状态1。                                                                              \n\n### 2.UML\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331164611.png)\n\n#### 2.题目解析\n\n正确答案： C　C　我的答案：C B\n\n> 序列图主要用于按照交互发生的一系列顺序，显示对象之间的这些交互。以本题为例，第1个消息——xfer（m:Money,a2）表示外部有对象要调取a1这个对象的xfer()操作。而evaluation就是在a1调用john的check()操作之后的一个消息反馈。</div>\n>\n> 在整个图中, evaluation是一个消息反馈，不需要由Account来实现，而check()操作应由Person实现，而非Account。所以Account需要实现的包括：xfer()、plus()和minus()。\n\n### 3.迭代和递归算法\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331164730.png)\n\n#### 2.题目解析\n\n> 本题考查迭代和递归算法。<br>\n>\n> 递归是设计和描述算法的一种有力的工具。<br>\n>\n> 能采用递归描述的算法通常有这样的特征：为求解规模为N的问题，设法将它分解成一些规模较小的问题，然后从这些小问题的解方便地构造出大问题的解，并且这些规模较小的问题也能采用同样的分解和综合方法，分解成规模更小的问题，并从这些更小问题的解构造出规模稍大问题的解。特别地，当规模N=1时，能直接得到解。<br>\n>\n> 由于递归函数执行过程中引起一系列的函数调用和返回，因此需要较多的时间开销（控制转移和存储空间管理操作所需的时间）及空间开销（每一次调用时为函数中的形式参数和自动局部变量分配存储空间等），因此与实现相同功能的非递归函数相比，运行效率较低。\n\n### 4.软件设计\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331165100.png)\n\n#### 2.题目解析\n\n>  本题考查软件系统设计知识。系统设计为系统制定蓝图，软件设计模型关注新系统总体结构、代码设计、处理过程、数据结构和界面模型等。对项目范围的关注在软件设计之前。\n\n### 5.UML\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331165135.png)\n\n#### 2.题目解析\n\n>  类图（Class Diadram）展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中，最常见的就是类图，它给出系统的静态设计视图。<br>\n>\n>  组件图（Component Diagram）展现了一组组件之间的组织和依赖。<br>\n>\n>  通信图（communication diagram）。通信图也是一种交互图，它强调收发消息的对象或参与者的结构组织。\n>\n>  署图（Deploy Diagram）是用来对面向对象系统的物理方面建模的方法，展现了运行时处理结点以及其中构件（制品）的配置。“用于展示所交付系统中软件组件和硬件之间的物理关系”的是部署图。 \n>\n>  \n\n### 6.面向对象设计\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331174909.png)\n\n#### 2.题目解析\n\n> 本题考查的是面向对象设计中各种对象的职责。经典的MVC模式中，边界对象表示了系统与参与者之间的接口，该对象从参与者处收集信息，并将之转换为二种被实体对象和控制对象使用的形式。\n\n### 7.知识产权人确定\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331175212.png)\n\n#### 2.题目解析\n\n> 这个是同一类产品，构成近似商标，“近似商标”是指文字、数字、图形、三维标志或颜色组合等商标的构成要素的发音、视觉、含义或排列顺序及整体结构上虽有一定区别，但又使人难以区分，容易产生混淆的商标。会产生商标侵权，故不能同时注册。\n>\n> 由双方协商决定。\n\n### 8.多种程序语言特点\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331175325.png)\n\n#### 2.题目解析\n\n>   本题考查程序语言基础知识。<br>\n>\n> 选项 A 涉及程序语言的一般概念，程序设计语言的基本成分包括数据、运算、控制和传输等。<br>\n>\n> 选项 B 考查高级语言和低级语言的概念。对于程序设计语言，高级语言和低级语言是指其相对于运行程序的机器的抽象程度。低级语言在形式上更接近机器指令，汇编语言就是与机器指令一一对应的。高级语言对底层操作进行了抽象和封装，其一条语句对应多条机器指令，使编写程序的过程更符合人类的思维习惯，井且极大简化了人力劳动。 高级语言不依赖于具体的机器硬件。<br>\n>\n> 选项 C 考查局部变量的概念，凡是在函数内部定义的变量都是局部变量(也称作内部变量)，包括在函数内部复合语句中定义的变量和函数形参表中说明的形式参数 。局部 变量只能在函数内部使用，其作用域是从定义位置起至函数体或复合语句体结束为止。 局部变量的值通常在其生存期内是变化的。<br>\n>\n> 选项D考查常量的概念，程序中常量的值在运行时是不能改变的。\n\n### 9.多种程序语言特点\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200331175542.png)\n\n#### 2.题目解析\n\n> 强、弱类型语言有两种划分方法.\n>\n> 一种是从内存上来说：允许将一块内存看做多种类型。比如直接将整型变量与字符变量相加。 \n>\n> 另一种是从语法上来说：在变量或者对象使用前，需要声明类型的语言就是强类型语言。 \n>\n> 根据题意对弱语言的定义：不需要进行变量/对象类型声明的语言，可知本题是从语法的角度来区分强弱类型语言。java、c/c++、c#中变量在使用前都需要声明其类型，而python则不需要。因此从语法上来说，python是弱类型语言。 \n\n\n\n","tags":["软件设计师考题"]},{"title":"2020年02月17日软件设计师每日一练","url":"/2020/03/30/2020年02月17日软件设计师每日一练/","content":"\n### 1.总线系统\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330225223.png)\n\n#### 2.题目解析\n\n>  总线复用，顾名思义就是一条总线实现多种功能。\n>\n> 常见的总线复用方式有**总线分时复用**，它是指在不同时段利用总线上同一个信号线传送不同信号，例如，地址总线和数据总线共用一组信号线。采用这种方式的目的是减少总线数量，提高总线的利用率。\n\n### 2.编译与解释\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330225434.png)\n\n#### 2.题目解析\n\n> ​\t用高级语言编写的程序不能直接被机器执行，而是经过相关的处理后，将其变成目标程序后才能被机器执行，而这一过程就是一个编译的过程，而实现这个功能的程序就称为编译程序。\n\n### 3.算法基础与常见的算法\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330225525.png)\n\n#### 2.题目解析\n\n> - **分治法**的设计思想是将一个难以直接解决的大问题分解成一些规模较少的相同问题以便各个击破，分而治之。<br>\n> - **动态规划法**与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。动态规划法可求解的问题一般具有最优子结构和重叠子问题，因此本题第一空选择B选项动态规划法。<br>\n>   \n> - **贪心法**经常用于解决最优化问题，但他的最优往往是从局部最优来考虑的，每一步都选最优的方案，但这种方案不一定能得到整体上的最优解。<br>\n>   \n> - **回溯法**是一种既带有系统性又带有跳跃性的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。因此本题第二空选择C选项回溯法。</p>\n\n### 4.Gant图和Pert图\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330225658.png)\n\n#### 2.题目解析\n\n> 本题考查软件项目计划基础知识。<br>\n>\n> 软件项目计划的一个重要内容是**安排进度**，\n>\n> 常用的方法有Gantt图和PERT图。\n>\n> - Gantt图用水平条状图描述，它以日历为基准描述项目任务，可以清楚地表示任务的持续时间和任务之间的并行，但是不能清晰地描述各个任务之间的**依赖关系**。\n> - PERT图是一种网络模型，描述一个项目任务之间的关系。可以明确表达任务之间的依赖关系，即哪些任务完成后才能开始另一些任务，以及如期完成整个工程的关键路径。<br>\n>\n> &nbsp;&nbsp;&nbsp; 图中任务流1→2→5→7→9的持续时间是15， 1→2→5→8→9的持续时间是13，1→3→6→8→9的持续时间是8， 4→6→8→9的持续时间为9。所以项目关键路径长度为15。事件6在非关键路径上，其后的任务需要时间为5，所以最晚开始时间=15-5=10。\n\n### 5.多媒体技术概念\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330225921.png)\n\n#### 2.题目解析\n\n> 图像分辨率与显示分辨率是两个不同的概念。图像分辨率确定的是组成一幅图像像素的数目，而显示分辨率确定的是显示图像的区域大小。它们之间的关系是:<br>\n>  　　①图像分辨率大于显示分辨率时，在屏幕上只能显示部分图像。例如，当图像分辨率为800 X 600，屏幕分辨率为640 X 480时，屏幕上只能显示一幅图像的64%左右。<br>\n>  　　②图像分辨率小于屏幕分辨率时，图像只占屏幕的一部分。例如，当图像分辨率为320 X 240，屏幕分辨率为640 X 480时，图像只占屏幕的1/4 。\n\n### 6.CVS\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330230047.png)\n\n#### 2.题目解析\n\n>    CVS的全称是Concurrent Version System，它是一个免费的协同版本控制工具，主要用于软件源码的维护。此外CVS可以维护任意文档的开发和使用，例如共享文件的编辑修改，而不仅仅局限于程序设计。CVS维护的文件类型可以是文本类型也可以是二进制类型。CVS基于客户端朋及务器模式，多个用户可通过网络（或本地）方式同时访问，从而使得CVS成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选。\n\n### 7.数据库模式\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330230256.png)\n\n#### 2.题目解析\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330230416.png)\n\n### 8.TCP/IP协议族\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330230441.png)\n\n#### 2.题目解析\n\n>  DHCP客户端可从DHCP服务器获得本机IP地址、DNS服务器的地址、DHCP服务器的地址、默认网关的地址等，但没有Web服务器、邮件服务器地址。\n\n### 9.协议\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330230555.png)\n\n#### 2.题目解析\n\n>  IEEE 802.11标准定义的分布式协调功能采用了载波监听多路访问肿突避免（CSMA/CA协议）。在无线网中进行冲突检测是有困难的。例如，两个站由于距离过大或中间障碍物的分隔而检测不到冲突，但是位于它们之间的第三个站可能会检测到冲突，这就是所谓隐蔽终端问题。采用冲突避免的办法可以解决隐蔽终端的问题。802.11定义了一个帧间隔（Inter Frame Spacing ，IFS ）时间。另外还有一个后退计数器，其初始值是由随机数发生器设置的，递减计数直到0。基本的操作过程如下：<br>\n>  　　（1）如果一个站有数据要发送并且监听到信道忙，则产生一个随机数设置自己的后退计数器并坚持监听；<br>\n>  　　（2）监听到信道空闲后等待一个IFS时间，然后开始计数，最先计数完的站可以开始发送；<br>\n>  　　（3）其他站在监听到有新的站开始发送后暂停计数，在新的站发送完成后再等待一个 IFS时间继续计数，直到计数完成开始发送。<br>\n>  　　CSMA/CA协议可以采用载波检测方法发现信道空闲，也可以采用能量检测方法发现信道空闲。这个算法对参与竞争的站是公平的，基本上是按先来先服务的顺序获得发送的机会。 ","tags":["软件设计师考题"]},{"title":"2020年02月16日软件设计师每日一练","url":"/2020/03/29/2020年02月16日软件设计师每日一练/","content":"\n### 1.代数关系\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330223304.png)\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330223332.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330223359.png)\n\n#### 2.题目解析\n\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330223454.png)\n\n### 2.编译与解析\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330223521.png)\n\n#### 2.题目解析\n\n> 在编译时产生的**目标文件**都是从地址0开始的，连接时将各个目标文件进行符号替换，这时会修改相应的地址，最后产生一个从地址0开始的可执行文件。在该可执行文件中的地址称为逻辑地址。\n\n### 3.数据压缩技术\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330223635.png)\n\n#### 2.题目解析\n\n> 本题主要考查编码方法。<br>\n>\n> 根据解码后数据与原始数据是否完全一致可以分为两大类：\n>\n> 一类是熵编码、冗余压缩法，也称无损压缩法、无失真压缩法；\n>\n> 二是熵压缩法，也称有损压缩法、有失真压缩法。其中熵编码的一个重要特征就是解码后数据与原始数据完全一致，要达到这种效果，显然，那么压缩比就较低。这种方法一般适用于文本、数据的压缩，当然，如果要求有高质量的视音频的话，也可以采用这种方式压缩。\n>\n> 常见的熵编码方法有\n>\n> ​\t\t\tLZ编码（Lempel-Zev编码）、行程编码、哈夫曼编码（Huffman编码）。而小波变换编码、线性预测编\t\t\t码、\t\tPCM、DPCM都是有损压缩。<br>\n>\n> 哈夫曼编码是一种可变长的编码方式，该方法完全依据字符出现的概率来构造异字头的平均长度最短的码字。<br>\n> 小波变换编码的原理是因为大多数语音和图像信号倾向于非均匀频谱，即只集中在某一时间段的某一频段，小波包基表示信号时正好有这种自适应性，可通过选定一个阈值将这此时间段和频段的相应系数保留编码而丢弃其他时间段和频段上的小幅值的系数；另外，小波包基的每次分解都把信号分成低频和高频两部分，而多数的语音和图像信号的统计特性表明大幅值的系数往往集中在低频区内，这样可给那些小幅值系数分配很少的比特数，甚至可以不传输或存储，从而压缩了数据。<br>\n>\n> 线性预测编码中被预测的信号各样值都是此前样值的线性组合的预测编码。<br>\n>\n> PCM（脉冲编码调制）是把一个时间连续，取值连续的模拟信号变换成时间离散，取值离散的数字信号后在信道中传输。脉冲编码调制就是对模拟信号先抽样，再对样值幅度量化，编码的过程。\n\n### 4.TCP/IP协议族\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330224044.png)\n\n#### 2.题目解析\n\n>  TCP与UDP区别：\n>\n> 1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接；\n>\n> 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付；\n>\n> 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；\n>\n> 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信；\n>\n> 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节；\n>\n> 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道，整体来看UDP开销较小。\n>                  \n\n### 5.面向对象的基本概念\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330224346.png)\n\n\n\n#### 2.题目解析\n\n> 静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。<br>\n> 动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。\n\n### 6.数据库设计过程\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330224441.png)\n\n#### 2.题目解析\n\n>   软件设计必须依据对软件的需求来进行，结构化分析的结果为结构化设计提供了最基本的输入信息。从分析到设计往往经历以下流程：<br>\n>\n> （1）研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口。<br>\n> （2）根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型。针对两种不同的类型分别进行分析处理。<br>\n> （3）由数据流图推导出系统的初始结构图。<br>\n> （4）利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止。<br>\n> （5）根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计或数据文件的设计。<br>\n> （6）在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。<br>\n> 所以接口设计的主要依据是数据流图，接口设计的任务主要是描述软件与外部环境之间的交互关系，软件内模块之间的调用关系。\n\n### 7.排序与查找\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330224700.png)\n\n#### 2.题目解析\n\n>  　　装填因子α表示了哈希表的装满程度，显然，α越大发生冲突的可能性就越大。\n\n### 8.保护期限\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330224756.png)\n\n#### 2.题目解析\n\n> 根据《中华人民共和国商标法》第三十八条：注册商标有效期满，需要继续使用的，应当在期满前六个月内申请续展注册。专利权和著作权到期后都无法延长，而商业秘密权无期限限制\n\n### 9.DNS查询\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330224858.png)\n\n#### 2.题目解析\n\n#### 3.知识引申\n\n> DNS域名系统（服务）协议 \n>\n> 域名系统（服务）协议（DNS）[是](https://baike.baidu.com/item/是)一种[分布式网络](https://baike.baidu.com/item/分布式网络/8951687)[目录服务](https://baike.baidu.com/item/目录服务/10413830)，主要用于域名与 IP 地址的相互转换，以及控制因特网的电子邮件的发送。\n>\n> 大多数因特网服务依赖于 DNS 而工作，一旦 DNS 出错，就无法连接 Web 站点，电子邮件的发送也会中止。\n>\n> DNS 有两个独立的方面 ：\n>\n> 定义了命名语法和规范，以利于通过名称委派域名权限。基本语法是： local.group.site； 定义了如何实现一个[分布式计算机系统](https://baike.baidu.com/item/分布式计算机系统)，以便有效地将域名转换成 IP 地址\n>\n> 在 DNS 命名方式中，采用了分散和分层的机制来实现域名空间的委派授权以及域名与地址相转换的授权。通过使用 DNS 的命名方式来为遍布全球的[网络设备](https://baike.baidu.com/item/网络设备)分配域名，而这则是由分散在世界各地的服务器实现的。\n>\n> 理论上， DNS 协议中的域名标准阐述了一种可用任意标签值的分布式的抽象域名空间。任何组织都可以建立域名系统，为其所有分布结构选择标签，但大多数 DNS 协议用户遵循官方因特网域名系统使用的分级标签。常见的顶级域是： COM 、 EDU 、 GOV 、 NET 、 ORG 、 BIZ ，另外还有一些带国家代码的顶级域。\n>\n> DNS 的分布式机制支持有效且可靠的名字到 IP 地址的映射。多数名字可以在本地映射，不同站点的服务器相互合作能够解决大网络的名字与 IP 地址的映射问题。单个服务器的故障不会影响 DNS 的正确操作。 DNS 是一种通用协议，它并不仅限于网络设备名称。\n>\n> ## 域名系统\n>\n> 域名系统（Domain Name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n>\n> 域名系统(Domain Name System,DNS)是Internet上解决网上机器命名的一种系统。就像拜访朋友要先知道别人家怎么走一样，Internet上当一台主机要访问另外一台主机时，必须首先获知其地址，TCP/IP中的IP地址是由四段以“.”分开的数字组成，记起来总是不如名字那么方便，所以，就采用了域名系统来管理名字和IP的对应关系。\n\n### 10.内存\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200330225104.png)\n\n#### 2.题目解析\n\n> 本题考查计算机组成基础知识。<br>\n> 本题是按**字节编址**，因此一个存储单元容量为1B，直接计算16进制地址包含的存储单元个数即可。<br>\n> DABFFH-B3000H+1=27C00H=12*16<sup>2</sup>+7*16<sup>3</sup>+2*16<sup>4</sup>=159K，按字节编址，故此区域的存储容量为159KB。<br>\n>                      \n\n####  \n\n","tags":["软件设计师考题"]},{"title":"2020年02月15日软件设计师每日一练","url":"/2020/03/28/2020年02月15日软件设计师每日一练/","content":"\n### 1.开发模型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328181826.png)\n\n#### 2.解析\n\n> **增量模型**又称为**渐增模型**，也称为有计划的产品改进模型，\n>\n> 它从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入更多的需求，依此类推，直到系统完成。每个中间版本都要执行必需的过程、活动和任务。\n>\n> - 增量模型是瀑布模型和原型进化模型的综合，它对软件过程的考虑是：\n> - 在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；\n> - 但在软件的实际创建中，则将软件系统按功能分解为许多增量构件，并以构件为单位逐个地创建与交付，\n> - 直到全部增量构件创建完毕，并都被集成到系统之中交付用户使用。\n> - 比较瀑布模型、原型进化模型，增量模型具有非常显著的优越性。\n>\n> 但增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的**开放性与稳定性**，能够顺利地实现构件的集成。增量模型有以下不足之处：如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；如果需要不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力。一开始需求不清晰，会影响开发的进度，D选项错误。\n\n### 2.开发模型\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328182147.png)\n\n#### 2.解析\n\n> 1.  **瀑布模型**具有可强迫开发人员采用规范的方法；严格规定了各阶段必须提交的文档；要求每个阶段结束后，都要进行严格的评审等优点。但瀑布模型过于理想化，而且缺乏灵活性，无法在开发过程中逐渐明确用户难以确切表达或一时难以想到的需求。\n> 2.  **原型模型**一般是基于需求不容易明确这一事实：并非所有的需求在系统开发之前都能准确地说明和定义。因此，它不追求也不可能要求对需求的严格定义，而是采用了动态定义需求的方法。快速原型法适用于需求不够明确的项目。\n> 3.  **V模型**一种典型的测试模型，该模型强调开发过程中测试贯穿始终。\n> 4.  **螺旋模型**综合了瀑布模型和演化模型的优点，并在此基础上还增加了风险分析。采用螺旋模型时，软件开发沿着螺旋线自内向外旋转，每转一圈都要对风险进行识别和分析，并采取相应的对策。\n> 5.  本题描述的是一个大型项目，那么对文档的要求应该相应较高，而且具备了相关领域及类似规模系统的开发经验，那么系统的需求应该较明确，综合考虑，应该采用瀑布模型。\n\n### 3.软件开发人员管理\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328190934.png)\n\n#### 2.解析\n\n>   本题考查的是项目管理的人力资源方面的问题，在团队组建时，需要考虑企业的事业环境因素对项目的影响。<br>\n> 在项目中由于分工不同，\n>\n> 每个团队人员不需要充分参与开发过程的所有阶段，并且在软件项目中，\n>\n> 开发只是其中一个阶段，所有不能仅根据开发人员的能力来组织团队，当进度滞后时，增加开发人员不一定能加快开发速度，并且，由于加入新的团队成员，已经成熟的团队会回到磨合期，可能会造成进度更加滞后。<br>\n> 综上，本题只有A选项是正确的。\n\n### 4.网络攻击\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328191055.png)\n\n\n\n#### 2.知识引申\n\n> ## 攻击分类\n>\n> ### 主动攻击\n>\n> 主动攻击会导致某些数据流的篡改和虚假数据流的产生。这类攻击可分为篡改、伪造消息数据和终端（拒绝服务）。\n>\n> （1）篡改消息\n>\n> 篡改消息是指一个合法消息的某些部分被改变、删除，消息被延迟或改变顺序，通常用以产生一个未授权的效果。如修改传输消息中的数据，将“允许甲执行操作”改为“允许乙执行操作”。\n>\n> （2）伪造\n>\n> 伪造指的是某个实体（人或系统）发出含有其他实体身份信息的数据信息，假扮成其他实体，从而以欺骗方式获取一些合法用户的权利和特权。\n>\n> （3）拒绝服务\n>\n> 拒绝服务即常说的DoS（Deny of Service），会导致对通讯设备正常使用或管理被无条件地中断。通常是对整个网络实施破坏，以达到降低性能、终端服务的目的。这种攻击也可能有一个特定的目标，如到某一特定目的地（如安全审计服务）的所有数据包都被阻止。\n>\n> ### 被动攻击\n>\n> 被动攻击中攻击者不对数据信息做任何修改，截取/窃听是指在未经用户同意和认可的情况下攻击者获得了信息或相关数据。通常包括窃听、流量分析、破解弱加密的数据流等攻击方式。\n>\n> （1）流量分析\n>\n> 流量分析攻击方式适用于一些特殊场合，例如敏感信息都是保密的，攻击者虽然从截获的消息中无法的到消息的真实内容，但攻击者还能通过观察这些数据报的模式，分析确定出通信双方的位置、通信的次数及消息的长度，获知相关的敏感信息，这种攻击方式称为流量分析。\n>\n> （2）窃听\n>\n> 窃听是最常用的手段。应用最广泛的[局域网](https://baike.baidu.com/item/局域网)上的数据传送是基于广播方式进行的，这就使一台主机有可能受到本子网上传送的所有信息。而计算机的网卡工作在杂收模式时，它就可以将网络上传送的所有信息传送到上层，以供进一步分析。如果没有采取加密措施，通过协议分析，可以完全掌握通信的全部内容，窃听还可以用无限截获方式得到信息，通过高灵敏接受装置接收网络站点辐射的电磁波或网络连接设备辐射的电磁波，通过对电磁信号的分析恢复原数据信号从而获得网络信息。尽管有时数据信息不能通过电磁信号全部恢复，但可能得到极有价值的情报。\n>\n> 由于被动攻击不会对被攻击的信息做任何修改，留下痕迹很好，或者根本不留下痕迹，因而非常难以检测，所以抗击这类攻击的重点在于预防，具体措施包括虚拟专用网[VPN](https://baike.baidu.com/item/VPN)，采用加密技术保护信息以及使用交换式网络设备等。被动攻击不易被发现，因而常常是主动攻击的前奏。\n>\n> 被动攻击虽然难以检测，但可采取措施有效地预防，而要有效地防止攻击是十分困难的，开销太大，抗击主动攻击的主要技术手段是检测，以及从攻击造成的破坏中及时地恢复。检测同时还具有某种威慑效应，在一定程度上也能起到防止攻击的作用。具体措施包括自动审计、入侵检测和完整性恢复等。\n>\n> ## 攻击层次 \n>\n> 从浅入深的分为以下几个层次：\n>\n> （1）简单拒绝服务。\n>\n> （2）[本地用户](https://baike.baidu.com/item/本地用户)获得非授权读权限。\n>\n> （3）本地用户获得非授权写权限。\n>\n> （4）[远程用户](https://baike.baidu.com/item/远程用户)获得非授权账号信息。\n>\n> （5）远程用户获得特权文件的读权限。\n>\n> （6）远程用户获得特权文件的写权限。\n>\n> （7）远程用户拥有了[系统管理员](https://baike.baidu.com/item/系统管理员)权限。\n>\n> ## 攻击方法\n>\n> ### 口令入侵\n>\n> 所谓口令入侵是指使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动。这种方法的前提是必须先得到该主机上的某个合法用户的账号，然后再进行合法用户口令的破译。获得普通用户账号的方法非常多，如\n>\n> 利用目标主机的Finger功能：当用Finger命令查询时，[主机系统](https://baike.baidu.com/item/主机系统)会将保存的用户资料（如用户名、登录时间等）显示在[终端](https://baike.baidu.com/item/终端)或计算机上；\n>\n> 利用目标主机的X.500服务：有些主机没有关闭X.500的目录查询服务，也给攻击者提供了获得信息的一条简易途径；\n>\n> 从[电子邮件地址](https://baike.baidu.com/item/电子邮件地址)中收集：有些用户电子邮件地址常会透露其在目标主机上的账号；\n>\n> 查看主机是否有习惯性的账号：有经验的用户都知道，非常多系统会使用一些习惯性的账号，造成账号的泄露。\n>\n> ### 特洛伊木马\n>\n> 放置特洛伊木马程式能直接侵入用户的计算机并进行破坏，他常被伪装成工具程式或游戏等诱使用户打开带有特洛伊木马程式的邮件附件或从网上直接下载，一旦用户打开了这些邮件的附件或执行了这些程式之后，他们就会像古特洛伊人在敌人城外留下的藏满士兵的木马相同留在自己的计算机中，并在自己的[计算机系统](https://baike.baidu.com/item/计算机系统)中隐藏一个能在[Windows](https://baike.baidu.com/item/Windows/165458)启动时悄悄执行的程式。当你连接到因特网上时，这个程式就会通知攻击者，来报告你的IP地址及预先设定的端口。攻击者在收到这些信息后，再利用这个潜伏在其中的程式，就能任意地修改你的计算机的参数设定、复制文件、窥视你整个硬盘中的内容等，从而达到控制你的计算机的目的。\n>\n> ### WWW欺骗\n>\n> 在网上用户能利用IE等[浏览器](https://baike.baidu.com/item/浏览器)进行各种各样的WEB站点的访问，如阅读新闻组、咨询产品价格、订阅报纸、电子商务等。然而一般的用户恐怕不会想到有这些问题存在：正在访问的网页已被[黑客](https://baike.baidu.com/item/黑客)篡改过，网页上的信息是虚假的！例如黑客将用户要浏览的网页的URL改写为指向黑客自己的服务器，当用户浏览目标网页的时候，实际上是向黑客服务器发出请求，那么黑客就能达到欺骗的目的了。\n>\n> 一般Web欺骗使用两种技术手段，即URL地址重写技术和相关信关信息掩盖技术。利用URL地址，使这些地址都指向攻击者的Web服务器，即攻击者能将自己的Web地址加在所有URL地址的前面。这样，当用户和站点进行安全链接时，就会毫不防备地进入攻击者的服务器，于是用记的所有信息便处于攻击者的监视之中。但由于浏览器材一般均设有[地址栏](https://baike.baidu.com/item/地址栏)和状态栏，当浏览器和某个站点边接时，能在地址栏和状态样中获得连接中的Web站点地址及其相关的传输信息，用户由此能发现问题，所以攻击者往往在URL地址重写的同时，利用相关信息排盖技术，即一般用JavaScript程式来重写地址样和状枋样，以达到其排盖欺骗的目的。\n>\n> ### 电子邮件\n>\n> 电子邮件是互联网上运用得十分广泛的一种通讯方式。攻击者能使用一些[邮件炸弹](https://baike.baidu.com/item/邮件炸弹)软件或CGI程式向目的邮箱发送大量内容重复、无用的[垃圾邮件](https://baike.baidu.com/item/垃圾邮件)，从而使目的邮箱被撑爆而无法使用。当垃圾邮件的发送流量特别大时，更有可能造成[邮件系统](https://baike.baidu.com/item/邮件系统)对于正常的工作反映缓慢，甚至瘫痪。相对于其他的攻击手段来说，这种攻击方法具有简单、见效快等好处。\n>\n> ### 节点攻击\n>\n> 攻击者在突破一台主机后，往往以此主机作为根据地，攻击其他主机（以隐蔽其入侵路径，避免留下蛛丝马迹）。他们能使用[网络监听](https://baike.baidu.com/item/网络监听)方法，尝试攻破同一网络内的其他主机；也能通过IP欺骗和主机信任关系，攻击其他主机。\n>\n> 这类攻击非常狡猾，但由于某些技术非常难掌控，如TCP/IP欺骗攻击。攻击者通过外部计算机伪装成另一台合法机器来实现。他能磙坏两台机器间通信链路上的数据，其伪装的目的在于哄骗网络中的其他机器误将其攻击者作为合法机器加以接受，诱使其他机器向他发送据或允许他修改数据。TCP/IP欺骗能发生TCP/IP系统的所有层次上，包括[数据链路层](https://baike.baidu.com/item/数据链路层)、[网络层](https://baike.baidu.com/item/网络层)、[运输层](https://baike.baidu.com/item/运输层)及[应用层](https://baike.baidu.com/item/应用层)均容易受到影响。如果底层受到损害，则应用层的所有协议都将处于危险之中。另外由于用户本身不直接和底层相互相交流，因而对底层的攻击更具有欺骗性。\n>\n> ### 网络监听\n>\n> [网络监听](https://baike.baidu.com/item/网络监听)是[主机](https://baike.baidu.com/item/主机)的一种工作模式，在这种模式下，主机能接收到本[网段](https://baike.baidu.com/item/网段)在同一条物理通道上传输的所有信息，而不管这些信息的发送方和接收方是谁。因为系统在进行密码校验时，用户输入的密码需要从用户端传送到服务器端，而攻击者就能在两端之间进行数据监听。此时若两台主机进行通信的信息没有加密，只要使用某些网络监听工具（如NetXRay for 视窗系统95/98/NT、Sniffit for Linux、Solaries等）就可轻而易举地截取包括口令和账号在内的信息资料。虽然网络监听获得的用户账号和口令具有一定的局限性，但监听者往往能够获得其所在网段的所有用户账号及口令。\n>\n> ### 黑客软件\n>\n> 利用黑客软件攻击是互连网上比较多的一种攻击手法。Back Orifice2000、冰河等都是比较著名的[特洛伊木马](https://baike.baidu.com/item/特洛伊木马)，他们能非法地取得用户计算机的终极用户级权利，能对其进行完全的控制，除了能进行文件操作外，同时也能进行对方[桌面](https://baike.baidu.com/item/桌面)[抓图](https://baike.baidu.com/item/抓图)、取得密码等操作。这些黑客软件分为服务器端和用户端，当黑客进行攻击时，会使用用户端程式登陆上已安装好服务器端程式的计算机，这些服务器端程式都比较小，一般会随附带于某些软件上。有可能当用户下载了一个小游戏并运行时，黑客软件的服务器端就安装完成了，而且大部分黑客软件的重生能力比较强，给用户进行清除造成一定的麻烦。特别是一种TXT文件欺骗手法，表面看上去是个TXT文本文件，但实际上却是个附带黑客程式的可执行程式，另外有些程式也会伪装成图片和其他格式的文件。\n>\n> ### 安全漏洞\n>\n> 许多系统都有这样那样的安全漏洞（Bugs）。其中一些是操作系统或应用软件本身具有的。如[缓冲区溢出攻击](https://baike.baidu.com/item/缓冲区溢出攻击)。由于非常多系统在不检查程式和缓冲之间变化的情况，就任意接受任意长度的数据输入，把溢出的数据放在[堆栈](https://baike.baidu.com/item/堆栈)里，系统还照常执行命令。这样攻击者只要发送超出缓冲区所能处理的长度的指令，系统便进入不稳定状态。若攻击者特别设置一串准备用作攻击的字符，他甚至能访问根目录，从而拥有对整个网络的绝对控制权。另一些是利用协议漏洞进行攻击。如攻击者利用POP3一定要在根目录下运行的这一漏洞发动攻击，破坏的根目录，从而获得终极用户的权限。又如，ICMP协议也经常被用于发动[拒绝服务攻击](https://baike.baidu.com/item/拒绝服务攻击)。他的具体手法就是向目的服务器发送大量的[数据包](https://baike.baidu.com/item/数据包)，几乎占取该服务器所有的网络宽带，从而使其无法对正常的服务请求进行处理，而导致网站无法进入、网站响应速度大大降低或服务器瘫痪。常见的[蠕虫病毒](https://baike.baidu.com/item/蠕虫病毒)或和其同类的病毒都能对服务器进行[拒绝服务攻击](https://baike.baidu.com/item/拒绝服务攻击)的进攻。他们的繁殖能力很强，一般通过Microsoft的Outlook软件向众多邮箱发出带有病毒的[邮件](https://baike.baidu.com/item/邮件)，而使[邮件服务器](https://baike.baidu.com/item/邮件服务器)无法承担如此庞大的数据处理量而瘫痪。对于个人上网用户而言，也有可能遭到大量数据包的攻击使其无法进行正常的网络操作。\n>\n> ### 端口扫描\n>\n> 所谓端口扫描，就是利用Socket编程和目标主机的某些端口建立TCP连接、进行[传输协议](https://baike.baidu.com/item/传输协议)的验证等，从而侦知目标主机的扫描端口是否是处于激活状态、主机提供了哪些服务、提供的服务中是否含有某些缺陷等等。常用的扫描方式有：Connect扫描、Fragmentation扫描。 \n>\n> ## 攻击位置\n>\n> ### 远程攻击\n>\n> 指外部攻击者通过各种手段，从该[子网](https://baike.baidu.com/item/子网)以外的地方向该子网或者该子网内的系统发动攻击。\n>\n> ### 本地攻击\n>\n> 指本单位的内部人员，通过所在的局域网，向本单位的其他系统发动攻击，在本级上进行非法越权访问。\n>\n> ### 伪远程攻击\n>\n> 指内部人员为了掩盖攻击者的身份，从本地获取目标的一些必要信息后，攻击过程从外部远程发起，造成外部入侵的现象。\n>\n> ## 攻击工具\n>\n> ### DOS攻击\n>\n> DOS攻击例如：WinNuke通过发送OOB漏洞导致系统蓝屏；Bonk通过发送大量伪造的UDP数据包导致系统重启；TearDrop通过发送重叠的IP碎片导致系统的TCP/IP栈崩溃；WinArp通过发特别数据包在对方机器上产生大量的窗口；Land通过发送大量伪造源IP的基于SYN的TCP请求导致系统重启动；FluShot通过发送特定IP包导致系统凝固；Bloo通过发送大量的ICMP数据包导致系统变慢甚至凝固；PIMP通过IGMP漏洞导致系统蓝屏甚至重新启动；Jolt通过大量伪造的ICMP和UDP导致系统变得非常慢甚至重新启动。\n>\n> ### 木马程式\n>\n> （1）BO2000（BackOrifice）：他是功能最全的TCP/IP构架的攻击工具，能搜集信息，执行系统命令，重新设置机器，重新定向网络的[客户端](https://baike.baidu.com/item/客户端)/服务器应用程式。BO2000支持多个[网络协议](https://baike.baidu.com/item/网络协议)，他能利用TCP或UDP来传送，还能用XOR[加密算法](https://baike.baidu.com/item/加密算法)或更高级的3DES加密算法加密。感染BO2000后机器就完全在别人的控制之下，[黑客](https://baike.baidu.com/item/黑客)成了终极用户，你的所有操作都可由BO2000自带的“秘密摄像机”录制成“录像带”。\n>\n> （2）“冰河”：冰河是个国产木马程式，具有简单的中文使用界面，且只有少数流行的反病毒、[防火墙](https://baike.baidu.com/item/防火墙)才能查出冰河的存在。冰河的功能比起国外的木马程式来一点也不逊色。他能自动跟踪目标机器的屏幕变化，能完全模拟键盘及鼠标输入，即在使被控端屏幕变化和监视端产生同步的同时，被监视端的一切键盘及鼠标操作将反映在控端的屏幕。他能记录各种口令信息，包括开机口令、屏保口令、各种共享资源口令及绝大多数在对话框中出现过的口令信息；他能获取系统信息；他还能进行注册表操作，包括对主键的浏览、增删、复制、[重命名](https://baike.baidu.com/item/重命名)和对键值的读写等所有注册表操作。\n>\n> （3）NetSpy：能运行于视窗系统95/98/NT/2000等多种平台上，他是个基于TCP/IP的简单的文件传送软件，但实际上你能将他看作一个没有权限控制的增强型FTP服务器。通过他，攻击者能神不知鬼不觉地下载和上传目标机器上的任意文件，并能执行一些特别的操作。\n>\n> （4）Glacier：该程式能自动跟踪目标计算机的屏幕变化、获取目标计算机登录口令及各种密码类信息、获取目标[计算机系统](https://baike.baidu.com/item/计算机系统)信息、限制目标计算机系统功能、任意操作目标[计算机文件](https://baike.baidu.com/item/计算机文件)及目录、远程关机、发送信息等多种监视功能。类似于BO2000。\n>\n> （5）KeyboardGhost：视窗系统是个以[消息循环](https://baike.baidu.com/item/消息循环)（[MessageLoop](https://baike.baidu.com/item/MessageLoop)）为基础的操作系统。系统的核心区保留了一定的字节作为键盘输入的缓冲区，其数据结构形式是队列。键盘幽灵正是通过直接访问这一队列，使键盘上输入你的电子邮箱、代理的账号、密码Password（显示在[屏幕](https://baike.baidu.com/item/屏幕)上的是星号）得以记录，一切涉及以星号形式显示出来的密码窗口的所有符号都会被记录下来，并在系统根目录下生成一文件名为KG.DAT的隐含文件。\n>\n> （6）[ExeBind](https://baike.baidu.com/item/ExeBind)：这个程式能将指定的攻击程式捆绑到所有一个广为传播的热门软件上，使宿主程式执行时，寄生程式也在后台被执行，且支持多重捆绑。实际上是通过多次分割文件，多次从[父进程](https://baike.baidu.com/item/父进程)中调用子进程来实现的。\n>\n> ## 应对策略\n>\n> 在对网络攻击进行上述分析和识别的基础上，我们应当认真制定有针对性的策略。明确安全对象，设置强有力的安全保障体系。有的放矢，在网络中层层设防，发挥网络的每层作用，使每一层都成为一道关卡，从而让攻击者无隙可钻、无计可使。还必须做到未雨绸缪，预防为主，将重要的数据备份并时刻注意系统运行状况。以下是针对众多令人担心的[网络安全](https://baike.baidu.com/item/网络安全)问题，提出的几点建议\n>\n> ### 提高安全意识\n>\n> （1）不要随意打开来历不明的[电子邮件](https://baike.baidu.com/item/电子邮件)及文件，不要随便运行不太了解的人给你的程式，比如“特洛伊”类[黑客](https://baike.baidu.com/item/黑客)程式就需要骗你运行。\n>\n> （2）尽量避免从Internet下载不知名的软件、游戏程式。即使从知名的网站下载的软件也要及时用最新的病毒和木马查杀软件对软件和系统进行扫描。\n>\n> （3）密码设置尽可能使用字母数字混排，单纯的英文或数字非常容易穷举。将常用的密码设置不同，防止被人查出一个，连带到重要密码。重要密码最佳经常更换。\n>\n> （4）及时下载安装[系统补丁](https://baike.baidu.com/item/系统补丁)程式。\n>\n> （5）不随便运行[黑客](https://baike.baidu.com/item/黑客)程式，不少这类程式运行时会发出你的个人信息。\n>\n> （6）在支持HTML的BBS上，如发现提交警告，先看原始码，非常可能是骗取密码的陷阱。\n>\n> ### 防火墙软件\n>\n> 使用防毒、防黑等防火墙软件。[防火墙](https://baike.baidu.com/item/防火墙)是个用以阻止网络中的黑客访问某个机构网络的屏障，也可称之为控制进/出两个方向通信的门槛。在[网络边界](https://baike.baidu.com/item/网络边界)上通过建立起来的相应[网络通信](https://baike.baidu.com/item/网络通信)监视系统来隔离内部和外部网络，以阻挡外部网络的侵入。\n>\n> ### 代理服务器\n>\n> 设置代理服务器，隐藏自己IP地址。保护自己的IP地址是非常重要的。事实上，即便你的机器上被安装了木马程式，若没有你的IP地址，攻击者也是没有办法的，而保护IP地址的最佳方法就是设置[代理服务器](https://baike.baidu.com/item/代理服务器)。代理服务器能起到外部网络申请访问内部网络的中间转接作用，其功能类似于一个数据转发器，他主要控制哪些用户能访问哪些服务类型。当外部网络向内部网络申请某种网络服务时，代理服务器接受申请，然后他根据其服务类型、服务内容、被服务的对象、服务者申请的时间、申请者的域名范围等来决定是否接受此项服务，如果接受，他就向内部网络转发这项请求。\n>\n> ### 其他策略\n>\n> 将防毒、防黑当成日常例性工作，定时更新防毒组件，将防毒软件保持在常驻状态，以完全防毒；\n>\n> 由于黑客经常会针对特定的日期发动攻击，计算机用户在此期间应特别提高警戒；\n>\n> 对于重要的个人资料做好严密的保护，并养成资料备份的习惯。\n\n### 5.面向对象的基本概念\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328191420.png)\n\n#### 2.解析\n\n> 多态分为两种：**通用的多态和特定的多态**。两者的区别是前者对工作的类型不加限制，允许对不同类型的值执行相同的代码；后者只对有限数量的类型有效，而且对不同类型的值可能要执行不同的代码。 \n>\n> 通用的多态又分为参数多态（parametric）和包含多态（inclusion）；特定的多态分为过载多态（overloading）和强制多态（coercion）。 \n>\n> 强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。程序设计语言中基本类型的大多数操作符，在发生不同类型的数据进行混合运算时，编译程序一般都会进行强制多态。程序员也可以显示地进行强制多态的操作(Casting)。举个例子，比如，int+double，编译系统一般会把int转换为double，然后执行double+double运算，这个int-》double的转换，就实现了强制多态，即可是隐式的，也可显式转换。 \n>\n> 过载（overloading）多态：同一个名（操作符﹑函数名）在不同的上下文中有不同的类型。程序设计语言中基本类型的大多数操作符都是过载多态的。通俗的讲法，就是c++中的函数重载。在此处中“overload”译为“过载”，其实就是所谓的“重载”，也许“overload”就应翻译为“过载，重载”吧，那“override”就只能是“覆盖”了。 \n>\n> 参数多态：采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。 \n>\n> 包含多态：同样的操作可用于一个类型及其子类型。（注意是子类型，不是子类。）包含多态一般需要进行运行时的类型检查。\n\n\n\n### 6.COCOMO ||\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328192347.png)\n\n#### 2.解析\n\n> COCOMOII模型也需要使用规模估算信息，在模型层次结构中有3种不同规模估算选择，即：对象点、功能点和代码行。\n\n### 7.多种程序语言的特点\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328192451.png)\n\n#### 2.解析\n\n> 变量是内存单元的抽象，用于在程序中表示数据。当变量存储的是内存单元地址时，称为指针变量，或者说指针变量指向了另一个变量。指针变量可以定义在函数或复合语句内，也可以定义在所有的函数之外，即可以是全局变量，也可以是局部变量。需要区分指针变量与指针所指向的变量，无论指针变量指向何种变量，其存储空间大小都是一样的。当指针变量指向数组中的一个元素时，对指针变量进行算术运算可以使其指向同一个数组中的其他元素。\n\n### 8.文法\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200328192645.png)\n\n#### 2.解析\n\n> 上下文无关文法：形式语言理论中一种重要的变换文法，用来描述上下文无关语言，在乔姆斯基分层中称为2型文法。由于程序设计语言的语法基本上都是上下文无关文法，因此应用十分广泛。                                                                              ","tags":["软件设计师考题"]},{"title":"2020年02月14日软件设计师每日一练","url":"/2020/03/27/2020年02月14日软件设计师每日一练/","content":"\n### **1.拓扑排序**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327204350.png)\n\n答案：A\n\n我的答案：C\n\n#### 2.题目解析\n\n>  本题考查图数据结构。 \n> 　　对有向图进行拓扑排序的方法如下： \n> 　　（1）在AOV网中选择一个入度为0（没有前驱）的顶点且输出它。 \n> 　　（2）从网中删除该顶点及其与该顶点有关的所有边。 \n> 　　（3）重复上述两步，直至网中不存在入度为0的顶点为止。 \n> 　　执行的结果会有两种情况：一种是所有顶点己输出，此时整个拓扑排序完成，说明网中不存在回路；另一种是尚有未输出的顶点，剩余的顶点均有前驱顶点，表明网中存在回路，拓扑排序无法进行下去。 \n\n### **2.容量的计算**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327204644.png)\n\n#### 2.题目解析\n\n> 本题考查内存容量的计算。<br>\n> 给定起、止地址码的内存容量=终止地址-起始地址+1。<br>\n>\n> 将终止地址加1等于E000H，再减去起始地址，即E0000H-A0000H=40000H。十六进制的（40000）<sub>16</sub>=2<sup>18</sup> \n>  　　组成内存储器的芯片数量=内存储器的容量/单个芯片的容量。 答案：C\n\n### **3.数字证书**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205318.png)\n\n#### 2.题目解析\n\n>  `数字证书`就是互联网通讯中标志通讯各方身份信息的一系列数据，就好比日常生活中个人身份证一样。\n>\n> 数字证书是由一个权威机构证书授权中心（CA）发行的。\n>\n> 最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。\n>\n> 其中证书授权中心的数字签名是用它自己的私钥完成的，而它的公钥也是公开的，大家可以通过它的公钥来验证该证书是否是某证书授权中心发行的，以达到验证数字证书的真实性。因此本题答案选C。\n\n### **4.程序语言**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205423.png)\n\n#### 2.题目解析\n\n> 程序设计语言的基本成分包括\n>\n> 数据、运算、控制和传输等。\n>\n> 程序设计语言的控制成分包括**顺序、选择和循环3种结构**。\n> 所以本题选择A选项。 \n\n### **5.软件测试**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205555.png)\n\n#### 2.题目解析\n\n> 本题考查系统测试中的确认测试。\n>\n> 确认测试首先要进行有效性测试以及软件配置审查，然后进行验收测试和安装测试。\n>\n> 其中有效性测试，就是在模拟环境下，通过黑盒测试检验所开发的软件是否与需求规格说明书一致。\n\n### **6.数据表示**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205704.png)\n\n#### 2.题目解析\n\n> 本题考查计算机系统**数据编码基础知识**。<br>\n> \t　　设机器字长为n（即采用n个二进制位表示数据），最高位是符号位，0表示正号，1表示负号。<br>\n> \t　　原码表示方式下，除符号位外，n-1位表示数值的绝对值。因此，n为8时，[+0]原=0 0000000，[-0]原=1 0000000。<br>\n> \t　　正数的反码与原码相同，负数的反码则是其绝对值按位求反。n为8时，数值0的反码表示有两种形式：[+0]反=0 0000000，[-0]反=11111111。<br>\n> \t　　正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。在补码表示中，0有唯一的编码：[+0]补=0 0000000，[-0]补=00000000。<br>\n> \t　　移码表示法是在数X上增加一个偏移量来定义的，常用于表示浮点数中的阶码。机器字长为n时，在偏移量为2<sup>n-1</sup>的情况下，只要将补码的符号位取反便可获得相应的移码表示。\n\n### **7.传址与传值**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327205856.png)\n\n答案：D\n\n我的：A\n\n#### 2.题目解析\n\n> 传值调用中，形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变；而引用（传址）调用中，形参取的是实参的地址，即相当于实参存储单元的地址引用，因此其值的改变同时就改变了实参的值。<br>\n> x = 2*10-1=19；<br>\n> a是引用传递，所以a=a+x=10+19=29，结果为29。\n\n### **8.运算器和控制器**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327210006.png)\n\n#### 2.题目解析\n\n> CPU是一台计算机的**运算核心**和**控制核心**，\n>\n> 其由**运算器、控制器、寄存器**及实现它们之间联系的数据、控制及状态的总线构成。其中\n>\n> - 运算器负责相关的逻辑、算术运算，\n> - 寄存器用来存放一些相关的数据，而\n> - 内部总线负责各部件间信息的传递，而\n> - 控制器不仅要保证指令的正确执行，还要能够处理异常事件。\n\n### **9.面向对象的基本概念**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200327210157.png)\n\n#### 2.题目解析\n\n>  `多态`：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。也就是说客户类其实在调用方法时，并不需要知道特定子类的实现，都会用统一的方式来调用。\n\n####  ","tags":["软件设计师考题"]},{"title":"2020年02月13日软件设计师每日一练","url":"/2020/03/26/2020年02月13日软件设计师每日一练/","content":"\n### **1.编译与解释**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326182818.png)\n\n#### 2.题目解析\n\n> ​    死循环错误属于典型的**语义错误**，但静态的语义错误可被编译器发现，到程序真正陷入死循环说明编译器并未发现，所以属于动态语义错误。\n\n### **2.软件维护类型**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326182938.png)\n\n#### 2.题目解析\n\n>  软件维护的内容一般包括\n>\n> 准确性维护》适应性维护》完善性维护》预防性维护。\n>\n> - 正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。\n> - 适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。\n> - 完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。\n> - 预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。\n\n### **3.软件测试**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183158.png)\n\n#### 2.题目解析\n\n> 软件测试方法分为静态测试和动态测试。\n>\n> - 静态测试是被测试程序不在机器上运行而采用人工检测和计算机辅助静态分析手段对程序进行检测。\n> - 动态测试是通过运行程序发现错误，对软件产品进行动态测试时可以采用黑盒测试和白盒测试法。\n>\n> 黑盒测试法在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。对于无法获得源代码的第三方组件，可采用黑盒对组件进行测试。基本路径覆盖、分支覆盖和环路覆盖需要根据程序的内部结构和逻辑进行测试。\n\n### **4.银行家算法**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183617.png)\n\n#### 2.题目解析\n\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183719.png)\n\n### **5.UML**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183749.png)\n\n#### 2.题目解析\n\n>  **部署图**展现了运行处理节点以及其中的构件的配置。\n>\n> 部署图给出了体系结构的静态实施视图。它与构件视图相关，通常一个结点包含一个或多个构件。部署图一般描述的是代码或系统在实施中的物理节点分布，组件之间的依赖关系类似于包依赖。\n\n### **6.总线系统**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326183909.png)\n\n#### 2.题目解析\n\n> ​\t总线是在计算机中连接两个或多个功能部件的一组共享的**信息传输线**，它的主要特征就是多个部件共享传输介质。它是构成计算机系统的骨架，是各个功能部件之间进行信息传输的公共通道，借助总线的连接，计算机各个部件之间可以传送地址、数据和各种控制信息。\n>\n> 在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以有效减少信息传输线的数量。\n\n### **7.树与二叉树**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184026.png)\n\n#### 2.题目解析\n\n> 1. 先序遍历即先根后左子树再右子树，\n> 2. 中序遍历为先左子树后跟再右子树。\n>\n> 先序遍历的最开始结点A即为整棵树的根，结合中序遍历，A结点左侧B即为根节点A的左子树，右侧DCFE则为A的右子树，同理可以得出C为A的右子树的根节点,D为C的左子树，EF为C的右子树，F为E的左子树。可以得到如下图，所以该二颗树的高度为4。\n>\n> ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184114.png)\n\n### **8.正规式**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184210.png)\n\n#### 2.题目解析\n\n>  \t根据图中展示，其正规式应以a开头，a结尾，b可以出现0次或多次，所以是 ab*a，基本上可以排除BCD三项，答案为A。\n\n### **9.操作系统**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200326184259.png)\n\n#### 2.题目解析\n\n>  本题考查的是操作系统中文件管理的基本知识。<br>\n>\n> 在使用已经存在的文件之前，要通过“打开(open )”文件操作建立起文件和用户之间的联系，目的是把文件的**控制管理信息从辅存读到内存**。打开文件应完成如下功能：<br> \n>\n> -  在内存的管理表中申请一个空表目，用来存放该文件的文件目录信息。<br>\n> - 根据文件名在磁盘上查找目录文件。将找到的文件目录信息复制到内存的管理表中。如果打开的是共享文件，则应进行相关处理，如共享用户数加t。<br>\n> - 文件定位，卷标处理。<br>\n> - 文件一旦打开，可被反复使用直至文件关闭。这样做的优点是减少查找目录的时间，加快文件存取速度，提高系统的运行效率。因此，本题的正确答案为B。","tags":["软件设计师考题"]},{"title":"2020年02月12日软件设计师每日一练","url":"/2020/03/25/2020年02月12日软件设计师每日一练/","content":"\n### **1.软件保护期限**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213244.png)\n\n#### 2.题目解析\n\n>  我国《著作权法》对著作权的保护期限作了如下规定: (1)著作权中的署名权、修改权、保护作品完整权的保护期不受限制。\n\n### **2.专业英语**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213355.png)\n\n#### 2.题目解析\n\n> 不变只是愿望，变化才是永恒。—SWIFT<br>\n>\n> ​\t\t一个接一个的软件项目都是一开始设计算法，然后将算法应用到待发布的软件中，接着根据时间进度把第一次开发的产品发布给客户。<br>\n>\n> ​\t\t对于大多数项目，第一个开发的系统并不适用。它可能太慢、太大、难以使用，或者三者兼有。要解决所有的问题，除了重新开始以外，没有其他的办法—即开发一个更灵巧或者更好的系统。系统的丢弃和重新设计可以一步完成，也可以一块块地实现。所有大型系统的经验都显示，这是必须完成的步骤。而且，新的系统概念或新技术会不断出现，因此开发的系统必须被抛弃，但即使是最优秀的项目计划也不能无所不知地在最开始就解决这些问题。<br>\n>\n> ​\t\t因此，管理上的问题不再是“是否构建一个实验性的系统，然后抛弃它”，你必须这样做。现在的问题是“是否预先计划抛弃原型的开发，或者是否将该原型发布给用户”。从这个角度看待问题，答案更加清晰。将原型发布给用户，虽然可以获得时间，但是其代价高昂—对于用户，使用极其痛苦；对于重新开发的人员，分散了精力；对于产品，影响了声誉，即使是最好的再设计也难以挽回名声。<br>\n> 因此，为舍弃而计划，无论如何，你一定要这样做。<br>\n> ​           \n\n### **3.颜色深度**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325213520.png)\n\n#### 2.题目解析\n\n>  `颜色深度`是表示位图图像中单个像素的颜色或灰度所占的位数，8位的颜色深度，表示每个像素有8位颜色位，可表示256种不同的颜色。存储位图图像的数据量与图像大小有关。而位图图像的大小与分辨率、颜色深度有关。本题图像的垂直方向分辨率为640像素，水平方向分辨率为480，颜色深度为8位，则该图像所需存储空间为（640×480× 8 ）/8 （Byte） = 307200（Byte）。经5：1压缩后，该图像所需存储空间为307200/5 =61440（Byte）。\n\n### **4.Gant 和Pert图**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214024.png)\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214105.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214129.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214153.png)\n\n#### 2.题目解析\n\n>  在软件项目的活动图中，从开始结点到结束结点，**耗时最长的一条路径称为关键路径**。在本题中，关键路径为：A-C-G-J-K。所以备选答案中的C是属于关键路径上的里程碑。\n>\n>  题目中提到“活动AD在活动AC开始3天后才开始，而完成活动DG过程中，由于有临时事件发生，实际需要15天才能完成”，所以可以将AD活动由原来的10天延长至13天，而DG活动由原来的10天延长至15天，此时计算出来的关键路径比原来长了3天，所以整个项目的最短工期会延长3天。\n\n### **5.广义表**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214314.png)\n\n#### 2.题目解析\n\n>\n>  本题考查数据结构基础知识。 \n>\n>  链表是**最灵活的存储结构**，它允许同一个表中的结点类型可以不一致。静态数组是固定长度的数组，动态数组允许扩容，但是数组中的元素必须是相同类型的，这不适用于广义表。散列表的特点是元素的存储位置与其关键字值相关。 \n\n### **6.面向对象的基本概念**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214504.png)\n\n#### 2.题目解析\n\n>  本题考查面向对象基本概念中对象类之间的关系。泛化概化关系表示把几类对象类的公共属性和行为抽象成超类，然后其属性和方法被那些子类继承；聚合关系表示一个较大的“整体”类包含一个或多个较小的“部分”类；合成关系则表示关系中“整体”负责其“部分”的创建和销毁，如果“整体”不存在了，“部分”也将不存在。\n\n### **7.程序设计思维**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214610.png)\n\n#### 2.题目解析\n\n> 一个模块的独立度通常使用聚合和祸合程度来度量。聚合衡量模块内部各元素结合的紧密程度：祸合度量不同模块间互相依赖的程度。提高聚合程度，降低模块之间的祸合程度是模块设计应该遵循的最重要的两个原则。聚合与祸合是相辅相成的两个设计原则，模块内的高聚合往往意味着模块之间的松祸合。而要想提高模块内部的聚合性，必须减少模块之间的联系。 \n\n### **8.文法（重点）**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214707.png)\n\n#### 2.题目解析\n\n> <p>\n>  &nbsp;&nbsp;&nbsp; 本题考查语言结构的文法表示。<br>\n>  &nbsp;&nbsp;&nbsp; 推导就是用产生式的右部替换产生式左部符号。从文法的开始符号出发，不能推导出“（（a，f）） ”、“（abc）”、 “（c，（da））”，产生符号串“（（fac，bb），g）”的最左推导过程如下：<br>\n>  　　S=&gt;（S，M）=&gt;（（S，M），M）=&gt;（（M，M），M）=&gt;（（MP，M）， M）=&gt;（（MPP， M），M ）<br>\n>  　　&nbsp;=&gt; （（PPP， M）， M）=&gt;（（fPP， M）， M）=&gt;（（faP， M）， M）”（（fac， M， M）=&gt;（（fac， MP），M）<br>\n>  　　&nbsp;=&gt; （（faa， PP）， M） =&gt; （（fac， bP）， M）=&gt;（（fac， bb）， M）=&gt;（（fac，bb），g））</p>\n\n### **9.侵权判断**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214818.png)\n\n#### 2.题目解析\n\n> 本题考查知识产权中关于软件著作权方面的知识。<br>\n> \t&nbsp;&nbsp;&nbsp; 著作权因作品的完成而自动产生，不必履行任何形式的登记或注册手续，也不论其是否已经发表，所以甲对该软件作品享有著作权。乙未经甲的许可擅自使用甲的软件作品的行为，侵犯了甲的软件著作权。\n\n","tags":["软件设计师考题"]},{"title":"2020年02月11日软件设计师每日一练","url":"/2020/03/24/2020年02月11日软件设计师每日一练/","content":"\n### **1.媒体的种类**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325214951.png)\n\n#### 2.题目解析\n\n> - \n>   感觉媒体：指人们接触信息的感觉形式。如：视觉、听觉、触觉、嗅觉和味觉等。 \n> - \n>   表示媒体：指信息的表示形式。如：文字、图形、图像、动画、音频和视频等。 \n>\n> - 显示媒体（表现媒体）：表现和获取信息的物理设备。如：输入显示媒体键盘、鼠标和麦克风等；输出显示媒体显示器、打印机和音箱等。\n>\n> - 存储媒体：存储数据的物理设备，如磁盘、光盘和内存等。 \n>\n> - 传输媒体：传输数据的物理载体，如电缆、光缆和交换设备等。 \n\n### **2.数据库设计**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215311.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215340.png)\n\n#### 2.题目解析\n\n> 答案 BADC\n>\n> 试题（53）的正确选项为B。根据题意，零件P关系的主键为（零件号，供应商）。<br>\n> \t　\n>\n> 试题（54）的正确选项为A，试题（55）的正确选项为D。试题要求查询各种零件的平均单价、最高单价与最低单价之间差距，因此，首先需要在结果列中的空（54）填写“零件名称，AVG（单价），MAX（单价）-MIN（单价）”。其次必须用分组语句按零件号分组，\n>\n> 故空（55）应填写“GROUP BY零件号”。完整的SQL语句为：<br>\n> \t　　　　　SELECT 零件号，零件名称，AVG（单价），MAX（单价）-MIN（单价）<br>\n> \t&nbsp;　　　　 FROM P<br>\n> \t&nbsp; 　　　　GROUP BY零件号；<br>\n> \t　\n>\n> 试题（56）的正确选项为C。为了解决关系P存在冗余以及插入异常和删除异常等问题，需要将零件关系P分解。选项A、选项B和选项D是有损连接的，且不保持函数依赖故分解是错误的，例如，分解为选项A、选项B和选项D后，用户无法查询某零件由哪些供应商供应，原因是分解是有损连接的，且不保持函数依赖。</p>\n\n### **3.编译与解释**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325215559.png)\n\n#### 2.题目解析\n\n> 答案 A\n>\n> **词法分析阶段**，其任务是从左到右逐个字符地读入源程序，对构成源程序的**字符流**进行扫描和分解，从而识别出一个个单词（也称单词符号或符号）。这里所谓的单词是指逻辑上紧密相连的一组字符，这些字符组合在一起才表示某一含义。\n>\n> 词法分析过程依据的是语言的**词法规则**，即描述“单词” 分析构成程序的字符及由字符按照构造规则构成的符号是否符合程序语言的规定 ”是对单词的检查。\n>\n> **语法分析的任务**是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位，如“表达式”“语句”和“程序”等。语法规则就是各类语法单位的构成规则。\n>\n> **语义分析阶段**分析各语法结构的含义，检查源程序是否包含静态语言错误，并收集类型信息供后面的代码生成阶段使用。\n\n### **4.UML**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220031.png)\n\n#### 2.题目解析\n\n>  在UML中，关联的多重度是指一个类的实例能够与另一个类的多少个实例**相关联**。它又称为**重复度**。多重度表示为一个整数范围n..m，整数n定义所连接的最少对象的数目，而m则为最多对象数（当不知道确切的最大数时，最大数用*号表示）。最常见的多重性有0..1、0..*、1..1和1..*。\n\n### **5.McCabe度量法**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220151.png)\n\n#### 2.题目解析\n\n> ​\t本题考查McCabe度量法。McCabe度量法是通过定义**环路复杂度**，建立程序复杂性的度量，它基于一个程序模块的程序图中环路的个数。\n>\n> 画图法 》 E 、G 自环  （C D E F  环） （ B C E F 环） 添一条起点 终点环  》环数 5 \n>\n> 计算有向图G的环路复杂性的公式为V(G)=m-n+2，\n>\n> 其中V(G)是有向图G中的环路个数，m是G中的**有向弧数**（两节点之间的连线），n是G中的节点数。要采用McCabe度量法度量程序复杂度，需要先画出程序图，识别有向图中节点数n=7和有向弧数m=10，然后利用环路复杂性计算公式V(G)=m-n+2进行计算，得到图中程序图的程序复杂度是5。\n\n### **6.软件过程改进**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325220740.png)\n\n#### 2.题目解析\n\n> 《软件设计师教程（第5版）》P247页： \n>\n> - CL0（未完成的）：过程域未执行或未得到CL1中定义的所有目标。<br>\n> - CL1（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。<br>\n> - CL2（已管理的）：其共性目标是集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制、和评审。<br>\n> - CL3（已定义级的）：其共性目标集中于已定义的过程的制度化。过程是按照组织的裁剪指南从组织的标准过程中裁剪得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。<br>\n> - CL4（定量管理的）：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的质量目标作为管理准则。<br>\n> - CL5（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户的改变和持续改进计划中的过程域的功效。<br>\n\n#### 3.CMMI 知识引申\n\n> CMMI的全称为Capability Maturity Model Integration，即能力成熟度模型集成。CMMI是CMM模型的最新版本。早期的CMMI（CMMI-SE/SW/IPPD），SEI在部分国家和地区开始推广和试用。随着应用的推广与模型本身的发展，演绎成为一种被广泛应用的综合性模型。 [1]\n>\n> **级别**\n>\n> - CMMI共有5个级别，代表软件团队能力成熟度的5个等级，数字越大，成熟度越高，高成熟度等级表示有比较强的软件综合开发能力。\n> - CMMI一级，执行级。在执行级水平上，软件组织对项目的目标与要做的努力很清晰，项目的目标可以实现。但是由于任务的完成带有很大的偶然性，软件组织无法保证在实施同类项目时仍然能够完成任务。项目实施能否成功主要取决于实施人员。\n> - CMMI二级，管理级。在管理级水平上，所有第一级的要求都已经达到，另外，软件组织在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对项目相关的实施人员进行了相应的培训，对整个流程进行监测与控制，并联合上级单位对项目与流程进行审查。二级水平的软件组织对项目有一系列管理程序，避免了软件组织完成任务的随机性，保证了软件组织实施项目的成功率。\n> - CMMl三级，明确级。在明确级水平上，所有第二级的要求都已经达到，另外，软件组织能够根据自身的特殊情况及自己的标准流程，将这套管理体系与流程予以制度化。这样，软件组织不仅能够在同类项目上成功，也可以在其他项目上成功。科学管理成为软件组织的一种文化，成为软件组织的财富。\n> - CMMI四级，量化级。在量化管理级水平上，所有第三级的要求都已经达到，另外，软件组织的项目管理实现了数字化。通过数字化技术来实现流程的稳定性，实现管理的精度，降低项目实施在质量上的波动。\n> - CMMI五级，优化级。在优化级水平上，所有第四级的要求都已经达到，另外，软件组织能够充分利用信息资料，对软件组织在项目实施的过程中可能出现的次品予以预防。能够主动地改善流程，运用新技术，实现流程的优化。\n>\n> 由上述的5个级别可以看出，每一个级别都是更高一级的基石。要上高层台阶必须首先踏上所有下层的台阶\n>\n> **作用**\n>\n> 很多软件企业纷纷实施CMMI管理模式，不少企业如：东软、托普、华为等企业通过了三级或四级评估。这一方面反映了我国企业在进入WTO后的危机意识，以及与世界接轨的迫切愿望。另一方面则反映出我国软件企业在改进管理方法上所作的努力。但是CM-MI到底能够为我们做什么呢？实际上这个问题对不同的人有不同的答案。对采购部门的人员来说，掌握了CMMI技术可以有目的地考察项目实施人员或公司的实施能力，从而保证所采购的项目能够顺利完成。对于项目经理来说，掌握CMMl技术能够提高自己的项目管理能力，从而能够使项目高质量、低成本、按期限地完成。对于企业领导人来说，CMMI技术不仅能够提升企业的管理水平，还能够引入科学的管理理念，提升企业的整体管理水平。\n>\n> 在美国，很多企业通过CMMI评估一方面为了满足承包国防工程或一些大企业的工程的要求，另一方面也是为了提高企业自身的管理能力。美国政府的工程项目，绝大多数都要求承包商具有一定的CMMI级别作为参加投标的资格。越来越多的大型企业业开始要求其工程承包商具有一定的CMMl级别。级别高的企业在赢得项目的竞标中具有一定的优势。因此，如果没有CMMI的等级评估，企业就会失去很多商机\n>\n> **应用**\n>\n> CMMI是一个庞大的过程元模型，自发布以来在世界软件界产生了巨大的影响。CMMI等级评估已经成为业界公认的标准，CMMI的证书成了一个企业或组织能力和形象的标志，没有这个证书不仅难以获得国外项目，甚至也难以在国内一些项目的竞标中获胜。CMMI适合企业操作，避免了某些管理体系只重理论而忽视实践的缺陷。在我国，随着媒体的宣传和政府的支持，许多企业引入了CMMI咨询和认证，对于整个软件行业的管理提升及研发效率提高起到了很大的帮助作用。但也有一些企业引入CMMI体系后，只留下一些形式上的开发流程和文档模板，在管理上并无实质性改进。对于CMMI，业界一直存在着两种声音，有人认为CMMI执行过度，得不偿失；也有人说它过于通用，实用价值不大；但多数人还是认同它，并根据需要加以应用。 [3]\n\n### **7.后缀表达式**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325221240.png)\n\n#### 2.题目解析\n\n>  后缀表示也称为表达式的逆波兰表示。在这种表示方法中，将运算符号写在运算对象的后面，表达式中的运算符号按照计算次序书写。\n>\n> 对于表达式x-(y+c)*8，先计算y与c的和，再乘以8，最后用x减去这个这个计算，因此其后缀式为xyc+8*-。\n\n### **8.编译与解析**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200325221347.png)\n\n#### 2.题目解析\n\n> 对C源程序进行编译时，\n>\n> 1. 需建立符号表，其作用是记录源程序中各个符号（变量等）的必要信息，\n> 2. 以辅助语义的正确性检查和代码生成，\n> 3. 在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。\n> 4. 符号表的建立可以始于**词法分析阶段**，也可以放到**语法分析和语义分析阶段**，但符号表的使用有时会延续到目标代码的运行阶段。\n\n#### \n\n","tags":["软件设计师考题"]},{"title":"后缀表达式算法","url":"/2020/03/23/后缀表达式算法/","content":"\n### **1.概念解析**\n\n​\t实现逆波兰式的算法，难度并不大，但为什么要将看似简单的中序[表达式](https://baike.baidu.com/item/表达式)转换为复杂的逆波兰式？原因就在于这个简单是相对人类的思维结构来说的，对计算机而言中序表达式是非常复杂的结构。相对的，逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的内存结构是栈式结构，它执行先进后出的顺序。\n\n### **2.实现算法**\n\n1.算法一\n\n> 1) 初始化两个栈：运算符栈s1和储存中间结果的栈s2；\n> 2) 从左至右扫描中缀表达式；\n> 3) 遇到操作数时，将其压s2；\n> 4) 遇到运算符时，比较其与s1栈顶运算符的优先级：\n> \t1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；\n> \t2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；\n> \t3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；\n> 5) 遇到括号时：\u000b(1) 如果是左括号“(”，则直接压入s1\u000b(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃\n> 6) 重复步骤2至5，直到表达式的最右边\n> 7) 将s1中剩余的运算符依次弹出并压入s2\n> 8)  依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式\n\n2.算法2\n\n> 将一个普通的中序[表达式](https://baike.baidu.com/item/表达式)转换为[逆波兰表达式](https://baike.baidu.com/item/逆波兰表达式)的一般算法是：\n>\n> 首先需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：\n>\n> （1）若取出的字符是[操作数](https://baike.baidu.com/item/操作数)，则分析出完整的运算数，该操作数直接送入S2栈\n>\n> （2）若取出的字符是[运算符](https://baike.baidu.com/item/运算符)，则将该运算符与S1栈栈顶元素比较，如果该[运算符优先级](https://baike.baidu.com/item/运算符优先级)(不包括括号运算符)大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，最后将该运算符送入S1栈。\n>\n> （3）若取出的字符是“（”，则直接送入S1栈顶。\n>\n> （4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个[出栈](https://baike.baidu.com/item/出栈)，依次送入S2栈，此时抛弃“（”。\n>\n> （5）重复上面的1~4步，直至处理完所有的输入字符\n>\n> （6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。\n>\n> 完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算了！\n\n### **3.Java 代码实现**\n \n      \n  \t\t\n\n\t\tpackage DataStructures.Stack;\n\n        import java.util.Stack;\n\n        /**\n         * @author yichangkong\n         * @create 2020-03-21-22:47\n         * 中缀表达式转后缀表达式\n         */\n        public class PolandNotaion {\n\n            public static void main(String[] args) {\n\n                //初始化两栈 S1 S2\n                Stack<String> operatStack = new Stack();//；零时存取运算符\n                Stack<String> polanStack = new Stack();//逆波兰表达式\n\n\n                //测试案例\n                String expersstion = \"1 + ( ( 2 + 3 ) * 4 ) - 5\";\n\n                String[] arrayStr = expersstion.split(\" \");//转换为字符串数组进行从左至右遍历扫描\n\n                int size = arrayStr.length;//11\n\n                System.out.println(size);\n\n                boolean flag = true;\n\n\n                for (int index = 0; index < size; index++) {\n\n                    String str = arrayStr[index];\n\n                    //遇到操作数\n                    if (isNum(str)) {\n\n                        polanStack.push(str);\n\n                    } else {//如果是操作符\n                        if (operatorLevel(str) == 1) {\n                            //(1) 如果是左括号“(”，则直接压入s1\u000b\n                            if (str.equals(\"(\")) {\n                                operatStack.push(str);\n                            } else {\n                                //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃\n                                boolean f1 = true;\n                                while (f1) {\n\n                                    String s = operatStack.peek();\n                                    if (s.equals(\"(\")) {\n                                        operatStack.pop();\n                                        f1 = false;\n                                    } else {\n                                        polanStack.push(operatStack.pop());\n                                    }\n                                }\n                            }\n                        } else {\n                            flag = true;\n                            while (flag) {\n                                if (operatStack.size() == 0 || operatStack.peek().equals(\"(\")) {//如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈\n                                    //直接入S1\n                                    operatStack.push(str);\n                                    flag = false;\n                                } else {\n                                    int L1 = operatorLevel(str);\n                                    int L2 = operatorLevel(operatStack.peek());\n                                    //2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；\n                                    if (L1 < L2) {\n                                        operatStack.push(str);\n\n                                        System.out.println(\"L!\");\n                                        flag = false;\n                                    } else { //3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较\n                                        polanStack.push(operatStack.pop());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                while (operatStack.size() != 0) {\n                    polanStack.push(operatStack.pop());\n                }\n                System.out.println(polanStack);\n            }\n\n\n            //判断方法 检验输入的符号是否为数\n            static public boolean isNum(String string) {\n\n                if (operatorLevel(string) > 4) {\n\n                    int num = Integer.parseInt(string);\n\n                    if (num <= 9 || num >= 0) {\n                        return true;//是数字\n                    }\n                }\n                return false;//符号\n\n            }\n\n\n            //优先级 运算符 1 > 2 > 3 >4\n            static public int operatorLevel(String string) {\n\n                switch (string) {\n                    case \"(\":\n                        return 1;\n                    case \")\":\n                        return 1;\n\n                    case \"+\":\n                        return 3;\n                    case \"-\":\n                        return 3;\n                    case \"*\":\n                        return 2;\n                    case \"/\":\n                        return 2;\n                    case \"#\":\n                        return 4;\n                    default:\n                        return 5;\n                }\n\n            }\n        }\n ","tags":["数据结构算法"]},{"title":"2020年02月10日软件设计师每日一练","url":"/2020/03/23/2020年02月10日软件设计师每日一练/","content":"\n### **1.软件的可维护性**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210023.png)\n\n2.题目解析\n\n 本题考查系统的可维护性评价指标。系统的可维护性可以定性地定义为:维护人员理解、改正、改动和改进这个软件的难易程度，其评价指标包括可`理解性`、`可测试性`和`可修改性`。\n\n### **2..数据的表示**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210127.png)\n\n2.题目解析 \n\n答案 D\n\n 在计算机中，n位补码（表示数据位），表示范围是-2<sup>n-1</sup>~+2<sup>n-1</sup>-1，其中最小值为人为定义，以n=8为例，其中-128的补码是人为定义的1000 0000。<br>\n\n### **3.常用命令**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210258.png)\n\n2.题目解析\n\nipconfig/all能为DNS和WINS服务器显示它已配置且所要使用的附加信息（如IP地址等），并且显示内置于本地网卡中的物理地址。<br>\nipconfig/release也只能在向DHCP服务器租用其IP地址的计算机上起作用。如果你输入ipconfig /release，那么所有接口的租用IP地址便重新交付给DHCP服务器。<br>\n/reset和/reload为干扰项，ipconfig不支持这两个参数。<br>\n\n### **4.保护范围和对象**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210448.png)\n\n2.题目解析\n\n根据我国《著作权法》的规定，有三种类型的作品不受法律保护。 第一种是依法禁止出版、传播的作品。 第二种是不适用于《著作权法》的作品。它们包括下列作品：</div>\n<div>\n\t（1）法律、法规，国家的决议、决定、命令和其他具有立法、行政、司法性质的文件，极其官方正式译文；</div>\n<div>\n\t（2）时事新闻；</div>\n<div>\n\t（3）历法、通用数表、通用表格和公式。</div>\n<div>\n\t国务院颁布的《计算机软件保护条例》属于法律法规，所以不受著作权法保护。</div>\n\n### **5.软件测试**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210546.png)\n\n2.题目解析\n\n&nbsp;在单元测试开始时，应该对通过所有被测模块的数据流进行测试。<br>\n\t①输入参数是否与形式参数是否一致。<br>\n\t②调用模块的实参与被调用模块形参是否一致。<br>\n\t③全局变量在各模块中的定义和用法是否一致<br>\n\t④外部输入、输出等等。\n\n### **6.软件测试**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210637.png)\n\n2.题目解析\n\n 根据等价类划分的原则，如果规定了输入数据的范围，则可划分为1个有效等价类和2个无效等价类。学生年龄的输入范围为16~40，则有效等价类为16≤年龄≤40，两个无效等价类为年龄&gt;40或年龄&lt;16。\n\n### **7.面向对象的基本概念**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323210922.png)\n\n2.题目解析\n\n 面向对象系统中的封装单位是对象，对象之间只能通过接口进行信息交流，对象外部不能对对象中的数据随意地进行访问。封装是一种信息隐藏技术，目的是使对象的定义和实现分离，这样，就能减少耦合，类内部的实现可以自由改变而不会影响其他的类或对象。\n\n### **8.校验码**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211037.png)\n\n2.题目解析\n\n采用模二除法运算的只有循环冗余检验CRC。\n\n#### 3.校验方法\n\n> 常用的几种数据校验方式有奇偶校验、CRC校验、LRC校验、格雷码校验、和校验、异或校验等\n>\n> 一、奇偶校验\n>\n> 1. 定义\n>\n> 根据被传输的一组二进制代码中“1”的个数是奇数或偶数来进行校验。\n>\n> 使用：通常专门设置一个奇偶校验位，存放代码中“1”的个数为奇数还是偶数。若用奇校验，则奇偶校验位为奇数，表示数据正确。若用偶校验，则奇偶校验位为偶数，表示数据正确。\n>\n> 2. 应用\n>\n> eg.  数据位为 10001100 （1）  -> 最后一位为校验位\n>\n> 此时若约定好为奇校验，那么数据表示为正确的，若为偶校验，那么数据传输出错了。\n>\n> 二、CRC校验（循环冗余校验码）\n>\n> 1. 定义\n>\n> CRC校验是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。\n>\n> 2. 计算过程： \n> a> 设置CRC寄存器，并给其赋值FFFF(hex)。 \n> b> 将数据的第一个8-bit字符与16位CRC寄存器的低8位进行异或，并把结果存入CRC寄存器。 \n> c> CRC寄存器向右移一位，MSB补零，移出并检查LSB。 \n> d> 如果LSB为0，重复第三步；若LSB为1，CRC寄存器与多项式码相异或。\n>\n> e> 重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。\n>\n> f> 重复第2至第5步直到所有数据全部处理完成。\n>\n> g> 最终CRC寄存器的内容即为CRC值。\n>\n> 常用的CRC循环冗余校验标准多项式如下：   CRC(16位) = X16+X15+X2+1   CRC(CCITT) = X16+X12 +X5+1 \n> CRC(32位) = X32+X26+X23+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1 \n> 以CRC(16位)多项式为例，其对应校验二进制位列为1 1000 0000 0000 0101。 \n>\n> 3. 应用：在发送端根据要传送的k位二进制码序列，以一定的规则产生一个校验用的r位监督码(CRC码)，附在原始信息后边，构成一个新的二进制码序列数共k+r位，然后发送出去。在接收端，根据信息码和CRC码之间所遵循的规则进行检验，以确定传送中是否出错。\n>\n> 三、LRC校验\n>\n> 1. 定义：LRC校验用于ModBus协定的ASCII模式，这各校验比较简单，通讯速率较慢，它在ASCII协议中使用，检测了消息域中除开始的冒号及结束的回车换行号外的内容。它仅仅是把每一个需要传输的数据字节迭加后取反加1即可。\n>\n> 2. 应用\n>\n> eg. 5个字节：01H+03H+21H+02H+00H+02H = 29H，然后取2的补码=D7H。\n>\n> 四、格雷码校验\n>\n> 1. 定义\n>\n> 格雷码是一种无权码，也是一种循环码。是指任意两组相邻的代码之间只有一位不同，其余为都相同。\n>\n> 如：5的二进制为0101    6的二进制为0110\n>\n>         5的格雷码为0111    6的二进制为0101\n>\n> 五、校验和\n>\n> 1. 定义\n>\n> 校验一组数据项的和是否正确。通常是以十六进制为数制表示的形式。如果校验和的数值超过十六进制的FF，也就是255。\n>\n> 2. 应用\n>\n> eg. 数据01020304的校验和为a。\n>\n> 六、异或校验\n>\n> 1. 定义\n>\n> BCC校验其实是奇偶校验的一种，但也是经常使用并且效率较高的一种。所谓BCC校验法，就是在发送前和发送后分别把BCC以前包括ETX字符的所有字符按位异或后，按要求变换(增加或去除一个固定的值)后所得到的字符进行比较。相等即认为通信无错误，不相等则认为通信出错。\n>\n> 七、MD5校验\n>\n> 1. 定义\n>\n> MD5的实际应用是对一段Message(字节串)产生fingerprint(指纹)，可以防止被篡改。\n>  \n\n### **9.网络攻击**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211614.png)\n\n2.题目解析\n\n1. DoS是`Denial of Service`的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。 \n\n2. 作个形象的比喻来理解DoS。街头的餐馆是为大众提供餐饮服务，如果一群地痞流氓要DoS餐馆的话，手段会很多，比如霸占着餐桌不结账，堵住餐馆的大门不让路，骚扰餐馆的服务员或厨子不能干活，甚至更恶劣…… \n\n3. SYN Flooding攻击便是Dos攻击的典型代表，该攻击以多个随机的源主机地址向目的路由器发送SYN包，而在收到目的路由器的SYN ACK后并不回应，这样，目的路由器就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致路由器崩溃。服务器要等待超时（Time Out）才能断开已分配的资源。\n\n### **10.死锁**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323211851.png)\n\n2.题目解析\n\n本题考查对操作系统死锁方面基本知识掌握的程度。系统中同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m&lt;nw时，可能会引起死锁。<br>\n　　\n\n-  情况a：m=2，n= 1，w=2，系统中有2个资源，1个进程使用，该进程最多要求2个资源，所以不会发生死锁。 \n-  情况b：m=2，n=2，w=1，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，所以不会发生死锁。\n-  情况c：m=2，n=2，w=2，系统中有2个资源，2个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁，这时进程资源图如下图所示。</p>\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323212021.png)\n\n　　情况d：m=4，n=3，w=2，系统中有4个资源，3个进程使用，每个进程最多要求2个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个资源，此时，系统中还剩1个资源，可以使其中的一个进程得到所需资源运行完毕，所以不会发生死锁。 \n　　情况e：m=4，n=3，w=3，系统中有4个资源，3个进程使用，每个进程最多要求3个资源，此时，采用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进程分配1个，第二轮系统先为一个进程分配1个，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生列锁，这时进程资源图如下图所示。 \n\n ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200323212044.png)\n\n因此，情况c和e可能会发生死锁。\n\n第二空发分析如下： \t \n\n对于c情况，若将m加1，则情况c：m=3，n=2，w=2，系统中有3个资源，2个进程使用，每个进程最多要求2个资源，系统先为每个进程分配1个，此时，系统中还剩1个可供分配的资源，使得其中的一个进程能得到所需资源执行完，并释放所有资源使另一个进程运行完；若将w减1，则情况c：m=2，n=2，w=1，系统中有2个资源，2个进程使用，每个进程最多要求1个资源，系统为每个进程分配1个，此时进程都能够运行完成，并释放所有资源，不会发生死锁。对于情况e与c分析同理。 \n\n 因此，当m加1或w减1时，c和e不会发生死锁。","tags":["软件设计师考题"]},{"title":"2020年02月09日软件设计师每日一练","url":"/2020/03/22/2020年02月09日软件设计师每日一练/","content":"\n### **1.逻辑网络设计**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322205126.png)\n\n#### 2.题目解析\n\n 本题考查的是网络系统设计原则，其中答案A不符合其中的实用性原则，\n\n网络方案设计中应把握“`够用`”和“`实用`”原则。网络系统应采用成熟可靠的技术和设备，达到实用、经济和有效的目的。答案B不符合可扩展性原则，网络总体设计不仅要考虑到近期目标，也要为网络的进一步发展留有扩展的余地。\n\n`答案C说法正确`，符合开放性原则。答案D不正确，网络需求分析必须依赖于应用系统的需求分析。故答案选C.\n\n### **2.传值与传址**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322205328.png)\n\n#### 2.题目解析\n\n答案 C\n\n  传值调用最显著的特征就是被调用的函数内部对形参的修改不影响实参的值。引用调用是将实参的地址传递给形参，使得形参的地址就是实参的地址，函数中对形参的修改会导致原实参值的改变，因此可以实现实参与形参之间数据的双向传递。 在传值调用中，实参可以是变量，也可以是常量和表达式，而在传址调用中，实参不能是常量。\n\n### **3.树与二叉树**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210043.png)\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210137.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210225.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210251.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210354.png)\n\n#### 2.题目解析\n\n&nbsp;&nbsp;&nbsp; 本题考查哈夫曼树。<br>\n\t&nbsp;&nbsp;&nbsp; 构造最优二叉树的哈夫曼算法如下。<br>\n\t&nbsp;&nbsp;&nbsp; ① 根据给定的n个权值｛w1， w2，…，Wn｝构成n棵二叉树的集合F= {T1.T2，…，Tn}，其中每棵树T;中只有一个带权为w;的根结点，其左右子树均空。<br>\n\t&nbsp;&nbsp;&nbsp; ② 在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，置新构造二叉树的根结点的权值为其左、右子树根结点的权值之和。<br>\n\t&nbsp;&nbsp;&nbsp; ③从F中删除这两棵树，同时将新得到的二叉树加入到F中。<br>\n\t&nbsp;&nbsp;&nbsp; 重复②、③，直到F中只含一棵树时为止。这棵树便是最优二叉树（哈夫曼树）。从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度是从树根到每一个结点的路径长度之和。树的带权路径长度为树中所有叶子结点的带权路径长度之和。<br>\n\t&nbsp;&nbsp;&nbsp; 因此，C为最优二叉树，其带权路径长度（12+6）*3+15*2+23*2+29*2=188。<br>\n ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210849.png)\n\n### **4.多媒体技术概念**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322210925.png)\n\n#### 2.题目解析\n\n 通过话筒传入计算机的是我们人类的声音，而这种声音信号是一种连续的`模拟信号`，而非离散的数字信号，在接收到模拟信号以后，经过采样、量化等工作将模拟信号转换为数字信号在计算机中处理。\n\n### **5.有限自动机**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211103.png)\n\n#### 2.题目解析\n\n 本题考查程序语言方面的基础知识。\t　　对于题中自动机的状态图，先忽略状态q0的自环（识别若干个0），从初态q0到终态q1，该自动机可识别的字符串为1、101、10101、…，显然，该自动机识别的0、1串中1不能连续出现。\n\n#### 3.技术引申\n\n[网址](https://blog.csdn.net/lk1822791193/article/details/83343226?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n\n### **6.多媒体技术**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211258.png)\n\n#### 2.题目解析\n\n 　　本题考查计算机音乐信息处理技术的相关知识。WAV格式记录的是对于音乐信号的波形采样数据，它可以使用反映自然声音的信号采样序列来记录和回放声音信息。MIDI格式记录的是采用音乐信息序列交换的标准格式MIDI （ Musical Instrument Digital interface）标准来存贮和表达音乐的演奏信息，这些演奏信息包含每个音符演奏的时间信息、音量信息、长度信息、乐器或音色信息等，MID工消息序列可以间接反映出音乐的曲谱演奏信息。\n\n### **7.ER模型**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211352.png)\n\n#### 2.题目解析\n\n<p>\n\t本题考查的是应试者对数据库系统中E-R模型方面的基础知识。<br>\n\t根据题意，学生S关系中一个学生属于一个院系，一个院系有多个学生，因此学生S和部门院系D之间是一个一对多的联系，故(a)应为1&nbsp; * ；又因为一个学生可以选择多门课程，一门课程可由多名学生选择，所以学生S和课程C关系之间是一个多对多的联系，故(b)应为* &nbsp;* 。<br>\n\t假设一对多联系(a)不转换为一个独立的关系模式，那么按照E-R模型向关系模型转换的规则，应当将一端的主键并入多端。所以，生成的关系模式学生S中应加入关系模式D的主键。</p>\n\n### **8.规范化理论**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200322211524.png)\n\n#### 2.题目解析\n\n答案 D B\n\n1、函数依赖关系为的函数依赖集 F={培训科目→→培训师，（学生，培训科目）→成绩，（时间，教室）→培训科目，（时间，培训师）→教室，（时间，学生）→教室}。可以得出，（时间，学生）→教室 →培训科目 →成绩 ，（时间，学生）→教室 →培训科目 →培训师时间和学生共同组合，可以推导出所有的属性，描述出所有的函数依赖关系。 所以主键是时间和学生的组合键。 \n\n2、存在传递函数依赖，时间和教室—&gt;培训科目； 培训科目→培训师。\n                     ","tags":["软件设计师考题"]},{"title":"简单算法优化","url":"/2020/03/21/简单算法优化/"},{"title":"2020年02月08日软件设计师每日一练","url":"/2020/03/21/2020年02月08日软件设计师每日一练/","content":"\n### **1..数据结构**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321220324.png)\n\n#### 2.题目解析\n\n 在`不考虑字对齐规则`的情况下，C语言中一个结构体变量的存储区大小就是其所有成员所需存储区大小之和，一个联合体变量的存储区大小就是其各成员所需存储区大小中的`最大者`。因此题目中给定的联合体union T变量需要的存储区大小就是存储一个double类型变量的大小（即8字节），struct T类型变量的存储区最小应为int类型成员w存储区大小（4字节）与union T类型成员U的存储区大小之和，即12字节。\n\n### **2.uml**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321220620.png)\n\n#### 2.题目解析\n\n<p>\n\t活动图可以更好地描述出行为的细节，阐明了业务用例实现的工作流程。活动图主要由以下一些元素组成：<br>\n\t（1）初始节点和活动终点。在活动图中有两个特殊的节点，一个用来表示活动的初始节点，它用一个实心圆表示，在一张不包括子图的活动图中有且只有一个初始节点。而另一个则是表示活动处理完成的活动终点，它用一个圆圈内加一个实心圆来表示，在活动图中可能包含多个活动终点。<br>\n\t（2）活动状态。是活动图中最主要的元素之一，它用来表示一个活动，如图中的a11等。<br>\n\t（3）转换。当一个活动结束时，控制流就会马上传递给下一个活动状态，在活动图中称之为转换，用一条带箭头的直线来表示，转移表示各种活动状态的先后顺序。<br>\n\t（4）分支与监护条件。对于任何一个控制流而言，都一定会存在分支、循环等形式的控制流。在活动图中，分支用一个菱形表示，它有一个进入转换（箭头从外指向分支符号），一个或多个离开转换（箭头从分支符号指向外）。而每个离开转换上都会有一个监护条件，用来表示满足什么条件的时候执行该转换。但要注意，在多个离开转换上的监护条件不能有矛盾，否则就会使得流程产生混乱。<br>\n\t（5）分岔与汇合。在实际的控制流中，除了顺序结构、分支结构和循环结构之外，还可能存在并发的事件流。在UML中，可以采用一个同步线来说明这些并行控制流的分岔和汇合。<br>\n\t在本题中，要求出那些活动是可以同时执行的，这就要求他们没有先后关系，显然选项A和C不正确，而对于D选项，a66和a77分别是判定条件连个不同结果下要执行的活动，也不是可以同时执行的活动，因此答案选B。</p>\n\n### **3.软件开发过程基础知识**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221047.png)\n\n#### 2.题目解析\n\n-  本题考查软件开发过程中的风险分析基础知识。\n      风险分析包括风险识别、风险预测、风险评估和风险控制等4个不同活动，\n- ​    在风险识别过程中，要识别潜在的预算、进度、个体、资源、用户和需求等方面的问题以及对整个项目的影响，并建立风险条目检查表，列出所有可能的风险事项。\n- ​    在风险预测过程中，需要建立一个表示风险可能性的参考标准，描述风险条目的结果，估计风险对项目的影响等。\n\n#### 3.知识引申\n\n[软件风险基础知识](https://blog.csdn.net/zhouzuoluo/article/details/102751168)\n\n### **4进程的状态.**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221454.png)\n\n#### 2.题目解析\n\n​               在多线程运行环境中，每个线程自己独有资源很少，只有：程序计数器，寄存器和栈，其它的资源均是共享进程的，所以也只有这些独有资源是不共享的。答案 C\n\n### **5.IP地址与子网划分**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321221646.png)\n\n#### 2.题目\n\n变长子网的可用主机数计算公式为2<sup>n</sup>-2（n为表示主机的位数）/26即主机位为32-26=6，所以可用主机地址为64-2=62。 \n\n用IP地址155.32.80.192与子网掩码进行逻辑与运算得出该IP地址所在的网络号为：155.32.80.192；所在网段的广播地址为：155.32.80.255；所以与该IP地址不在同一网段的是选项D\n       \n\n### **6.文法**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222023.png)\n\n#### 2.题目解析\n\n 本题考查程序语言基础知识。<br>\n 　　推导就是从文法的开始符号S出发，反复使用产生式，将产生式左部的非终结符替换为右部的文法符号序列〔展开产生式用功表示），直到产生一个终结符的序列时为止.从文法G的开始符号出发，能推导出的终结符号序列（句子）的全体称为文法G产生的语言。<br>\n 　　对于上下文无关文法S→11 | 1001|S0|SS，从S出发可推导出11，1001， 110， 1111，11110和10010等，将这些二进制序列转换成对应的十进制数可知，它们都能被3整除。</p>\n\n#### 3.知识引申(编译原理——文法)\n\n[知识博客](https://blog.csdn.net/Helloyongwei/article/details/79638785)\n\n### **7.软件质量保证**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222412.png)\n\n#### 2.题目\n\n ISO/IEC 9126软件质量模型，该模型的质量特性和质量子特性如下：<br>\n\n1.  功能性（适合性、准确性、互用性、依从性、安全性）；\n2. 可靠性（成熟性、容错性、易恢复性）；\n3. 易使用性（易理解性、易学性、易操作性）；\n4. 效率（时间特性、资源特性）；\n5. 可维护性（易分析性、易改变性、稳定性、易测试性）；\n6. 可移植性（适应性、易安装性、一致性、易替换性）。\n7. 安全性是功能特性的子特性。\n\n### **8.后缀表达式**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321222904.png)\n\n#### 2.题目\n\n参考答案 D 我是 C\n\n 本题考查逻辑表达式的计算及程序语言处理基础知识。<br>\n\t&nbsp; “逻辑与运算”的优先级高于“逻辑或运算”。<br>\n\t&nbsp; “逻辑与运算”表达式“x∧Y”的短路求值逻辑是：若x为假，则可知“x∧Y”的值为假，无需&nbsp;&nbsp;&nbsp; 再对y求值，因此只有在x为真时继续对y求值。<br>\n\t&nbsp; “逻辑或运算”表达式“x∨y”的短路求值逻辑是：若x为真，则可知“x∨y”的值为真，无需再对y求值，因此只有在x为假时继续对y求值。<br>\n\t&nbsp;&nbsp;&nbsp; 对于逻辑表达式“a∧b∨c∧（b ∨ x&gt;0）”，从运算符的优先级方面考虑需先对“a∧b”求值，然后对“c∧（b∨ x&gt;0）”求值，最后进行“∨”运算，因此后缀式为“ab∧cbx0&gt;∨∧∨”。</p>\n\n#### 3.算法实现\n\n> 将一个普通的中序[表达式](https://baike.baidu.com/item/表达式)转换为[逆波兰表达式](https://baike.baidu.com/item/逆波兰表达式)的一般算法是：\n>\n> 首先需要分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈），S1栈可先放入优先级最低的运算符#，注意，中缀式应以此最低优先级的运算符结束。可指定其他字符，不一定非#不可。从中缀式的左端开始取字符，逐序进行如下步骤：\n>\n> （1）若取出的字符是[操作数](https://baike.baidu.com/item/操作数)，则分析出完整的运算数，该操作数直接送入S2栈\n>\n> （2）若取出的字符是[运算符](https://baike.baidu.com/item/运算符)，则将该运算符与S1栈栈顶元素比较，如果该[运算符优先级](https://baike.baidu.com/item/运算符优先级)(不包括括号运算符)大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，最后将该运算符送入S1栈。\n>\n> （3）若取出的字符是“（”，则直接送入S1栈顶。\n>\n> （4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个[出栈](https://baike.baidu.com/item/出栈)，依次送入S2栈，此时抛弃“（”。\n>\n> （5）重复上面的1~4步，直至处理完所有的输入字符\n>\n> （6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。\n>\n> 完成以上步骤，S2栈便为逆波兰式输出结果。不过S2应做一下逆序处理。便可以按照逆波兰式的计算方法计算了！\n\n### **9.专业英语**\n\n#### 1.题目\n\n​\t&nbsp; &nbsp; &nbsp; &nbsp;Observe that for the programmer， as for the chef， the urgency of the patron（顾客）may govern the scheduled completion of the task， but it cannot govern the actual completion. An omelette（煎鸡蛋）， promised in two minutes， may appear to be progressing nicely.But when it has not set in two minutes， the customer has two choices—waits or eats it raw.Software customers have had（ &nbsp;）choices.<br>\n\n​\t　　Now I do not think software（ &nbsp;）have less inherent courage and firmness than chefs， nor than other engineering managers. But false（ &nbsp;）to match the patron’s desired date is much more common in our discipline than elsewhere in engineering. It is very（ &nbsp;）to make a vigorous， plausible， and job risking defense of an estimate that is derived by no quantitative method， supported by little data， and certified chiefly by the hunches of the managers.\t　　\n\n​\t\t\tClearly two solutions are needed.We need to develop and publicize productivity figures， bug-incidence figures， estimating rules， and so on. The whole profession can only profit from（ &nbsp;）such data.Until estimating is on a sounder basis， individual managers will need to stiffen their backbones and defend their estimates with the assurance that their poor hunches are better than wish derived estimates.\n\n#### 2.题目翻译\n\n<p>\n\t&nbsp; &nbsp; &nbsp; &nbsp;观察一下编程人员，你可能会发现，同厨师一样，某项任务的计划进度，可能受限于顾客要求的紧迫程度，但紧迫程度无法控制实际的完成情况。就像约好在两分钟内完成一个煎蛋，看上去可能进行得非常好。但当它无法在两分钟内完成时，顾客只能选择等待或者生吃煎蛋。软件顾客的情况类似。<br>\n\t　　我现在并不认为软件经理内在的勇气和坚持不如厨师，或者不如其他工程经理。但为了满足顾客期望的日期而造成的不合理进度安排，在软件领域中却比其他的任何工程领域要普遍得多。而且，非量化方法的采用，少得可怜的数据支特，加上完全借助软件经理的直觉，这样的方式很难生产出健壮可靠和规避风险的估计。<br>\n\t　　显然我们需要两种解决方案。开发并推行生产率图表、缺陷率、估算规则等，整个组织最终会从这些数据的共享上获益。或者在基于可靠基础的估算出现之前，项目经理需要挺直腰杆并坚持他们的估计，确信自己的经验和直觉总比从期望得出的估计要强得多。</p>\n\n### **10.编译与解析**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200321223914.png)\n\n#### 2.题目\n\n1. 目标代码生成阶段应考虑直接影响到目标代码速度的三个问题：\n2. 一是如何生成较短的目标代码；\n3. 二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；\n4. 三是如何充分利用计算机指令系统的特点，以提高目标代码的质量。                                                                              ","tags":["软件设计师考题"]},{"title":"2020年02月07日软件设计师每日一练","url":"/2020/03/20/2020年02月07日软件设计师每日一练/","content":"\n### **1.面向对象的基本概念**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232539.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232729.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232750.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232817.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232842.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232906.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232925.png)\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320232948.png)\n\n#### 2.解析\n\n- `开-闭原则`要求一个软件实体应当对扩展开放，对修改关闭。也就是说，我们在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，换句话说就是，应当可以在不必修改源代码的情况下改变这个模块的行为。<br>\n  \t\n- `里氏代换原则`要求子类型必须能够替换它们的基类型，所以在里氏代换原则中，任何可基类对象可以出现的地方，子类对象也一定可以出现。\n- `依赖倒转原则`是：要依赖于抽象，不要依赖于具体。也就是常说的要针对接口编程，不要针对实现编程。\n\n### **2.排序与查找**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233237.png)\n\n#### 2.解析\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233252.png)\n\n### **3.树与二叉树**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235547.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233412.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235039.png)\n\n#### 2.解析\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233454.png)\n\n### **4.数据库的设计过程.**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233649.png)\n\n#### 2.解析\n\n 软件设计必须依据对软件的需求来进行，结构化分析的结果为结构化设计提供了最基本的输入信息。从分析到设计往往经历以下流程：<br>\n\n（1）研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口。<br>\n（2）根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型。针对两种不同的类型分别进行分析处理。<br>\n（3）由数据流图推导出系统的初始结构图。<br>\n（4）利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止。<br>\n（5）根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计或数据文件的设计。<br>\n（6）在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。<br>\n所以接口设计的主要依据是数据流图，接口设计的任务主要是描述软件与外部环境之间的交互关系，软件内模块之间的调用关系。<br>\n          \n\n### **5.设计模式**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320233939.png)\n\n#### 2.解析\n\n- 享元模式提供支持大量细粒度对象共享的有效方法。\n-  组合模式（Composite）：将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 \n- 迭代器模式（Iterator）：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。<br>\n\n- 备忘录模式（Memento）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。 \n\n### **6.面向对象的基本概念**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234103.png)\n\n#### 2.解析\n\n本题考查面向对象分析与设计的基本概念。<br>\n\t&nbsp;&nbsp;&nbsp; 面向对象分析主要强调理解问题是什么，不考虑问题的解决方案，因此答案A、C是正确的。面向对象设计侧重问题的解决方案，并且需要考虑实现细节问题，因此选项D的说法是不正确的。\n\n### **7.专业英语**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234247.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234330.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234406.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235147.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235227.png)![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320235256.png)\n\n#### 2.解析\n\n 软件实体的尺寸比任何其他人类构造更复杂，因为没有两个部分相同（至少在语句级上）。如果是，我们将两个相似的部分分成一个，一个（71），开放或关闭。在这方面，软件系统与计算机，建筑物或汽车有着深刻的区别，其中重复的元素很多。<br>\n\n数字电脑本身比大多数人理解的很多情况都要更复杂。这使得构思，描述和测试他们非常复杂。软件系统比计算机更多（72）数量级。<br>\n同样地，软件实体的放大不仅仅是较大尺寸的相同元素的重复;必然增加不同要素的数量。在大多数情况下，这些元素以（73）的方式彼此相互作用，并且整体的复杂性比线性增加更多。<br>\n软件的复杂性是（74）的属性，而不是偶然的。因此，消除其复杂性的软件实体的描述往往会抽象出其本质。数学和物理科学通过构建复杂现象的简化模型，从模型中导出属性，并通过实验验证这些属性，在三个世纪以来取得了长足的进步。这是因为模型中被忽略的复杂性（75）不是现象的基本属性。当复杂性是本质时，它不起作用。<br>\n开发软件产品的许多经典问题源于这一重要的复杂性，其非线性随着尺寸而增加。不仅技术问题，管理问题也来自于复杂性。<br>\n\n### **7.计算机指令**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200320234631.png)\n\n#### 2.解析\n\n 指令平均时钟数约为<br>\n 　　　（160000×1+30000×2 +24000×4+16000×8）/（160000+30000+24000+16000）<br>\n &nbsp;&nbsp;&nbsp; =444000/230000≈1.93<br>\n 　　该计算机的运算速度约为","tags":["软件设计师考题"]},{"title":"2020年02月06日软件设计师每日一练","url":"/2020/03/19/2020年02月06日软件设计师每日一练/","content":"\n### **1.面向对象的基本概念**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319195633.png)\n\n#### 2.解析\n\n- 本题考查面向对象的基本知识。 面向对象的4个核心概念是对象、类、继承和消息传递。\n- 其中，对象是基本的运行时的实体，它既包括数据（属性），也包括作用于数据的操作（行为）。所以，一个对象把属性和行为封装为一个整体。类定义了一组大体上相似的对象。\n- 一个类所包含的方法和数据描述一组对象的共同行为和属性。在进行类设计时，有些类之间存在一般和特殊关系，即一些类是某个类的特殊情况，某个类是一些类的一般情况，这就是继承关系。\n- 消息是对象之间进行通信的一种构造，包含要求接收对象去执行某些活动的信息。 \n\n### **2..程序语言**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319212332.png)\n\n#### 2.解析\n\n本题考查程序语言的基础知识。B答案<br>\n\t　　一个文法定义的语言是终结符号串的集合，这些终结符号串应能从文法的起始符号出发推导出来。\n\n### **3.设计模式**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319212559.png)\n\n#### 2.解析\n\n- 观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。本题选择D选项。\n-  A选项描述的是迭代器（Iterator）模式：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。\n-  B选项描述的是中介者（Mediator）模式：用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互。\n-  C选项描述的是备忘录（Memento）模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。\n\n### **4.软件测试**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319212949.png)\n\n#### 2.解析\n\n`所谓等价类`就是某个输入域的集合，对于一个等价类中的输入值来说，它们揭示程序中错误的作用是等效的。也就是说，如果等价类中的一个输入数据能检测出一个错误，那么等价类中的其他输入数据也能检测出同一个错误。\n\n在本题中一个`设计用例`包含两个输入条件，一个是班委，另一个是年龄，从四个选项来看，D选项中的两个输入都不是有效数据，如果用这个用例检测出了一个错误，那么也不能确定是由哪个输入条件引起的，因此其不是一个好的测试用例。\n\n### **5.正规式**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319213158.png)\n\n#### 2.解析\n\n   本题考查程序语言基础知识。 　　闭包运算符“*”将其运算对象进行若干次连接，因此0*表示若干个0构成的串，而（10*1）*则表示偶数个1构成的串。\n\n### **6.排序与查找**\n\n#### 1.题目\n\n#### 2.解析\n\n 本题考查数据结构基础知识。\n\t设查找表的元素存储在一维数组r[1..n]二中，那么在表中的元素己经按关键字递增（或递减）的方式排序的情况下，进行折半查找的方法是:首先将待查元素的关键字（key）值与表r中间位置上（下标为mid ）的记录的关键字进行比较，若相等，则查找成功。若key&gt;r[mid].key，则说明待查记录只可能在后半个子表r[mid+1..n]中，下一步应在后半个子表中再进行折半查找;若key&lt;r[mid].key，说明待查记录只可能在前半个子表r[ 1.mid-1」中，下一步应在r的前半个子表中进行折半查找，这样通过逐步缩小范围，直到查找成功或子表为空时失败为止。\n\t在题中，以中间元素41为界将数组元素分为12， 23， 30， 38和52， 54，76， 85两部分，显然54在后半部分，该部分的中间元素为54（向下取整）或76（向上取整），在52，54构成的子查找表中，向上取整的中间元素为54，因此查找元素54所经历“比较”运算的数据元素依次为41，76，54。 \n\n### **7.开发模型**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319215737.png)\n\n#### 2.解析\n\n- 敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。<br>\n\n- 极限编程是一种轻量级的开发方法，它提出了四大价值观：沟通、简单、反馈、勇气。五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作。<br>\n\n- 水晶法强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。<br>\n\n- 并列争球法的核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件。<br>\n\n- 自适应软件开发的核心是三个非线性的，重迭的开发阶段：猜测、合作、学习。</p>\n\n\n\n### **8.编程语言基础**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319222704.png)\n\n#### 2.解析\n\n本题考查的是面向对象程序设计中的静态成员。在C十十中使用静态成员来解决同一个类的不同对象之间的数据共享问题 \n\n静态成员作为类的一种成员，它被类的所有对象共享，而不是属于某个对象的。静态成员分为静态成员变量和静态方法 \n\n静态成员变量的值可以被更新。只要对静态成员变量的值更新一次，所有对象的该静态成员变量的值都会被更新 \n 静态成员函数可以直接访问静态成员，但不能直接访问非静态成员。 \n\n### **9.系统问题**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319224011.png)\n\n#### 2.解析\n\n \t\t本题考查系统的可维护性评价指标。系统的可维护性可以定性地定义为:维护人员理解、改正、改动和改进这个软件的难易程度，其评价指标包括可理解性、可测试性和可修改性。\n\n### **10.UML**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319224139.png)\n\n#### 2.解析\n\n​\t顺序图（sequence diagram，序列图）。顺序图是一种交互图（interaction diagram），交互图展现了一种交互，它由一组对象或参与者以及它们之间可能发送的消息构成。交互图专注于系统的动态视图。顺序图是强调消息的时间次序的交互图。\n\n​\t本题图示为序列图。序列图展示了1个用例和多个对象的行为","tags":["软件设计师考题"]},{"title":"2020年02月05日软件设计师每日一练","url":"/2020/03/18/2020年02月05日软件设计师每日一练/","content":"\n### **1.其他**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225035.png)\n\n#### 2.解析\n\n  在对软件系统进行评价时，从系统评价对象出发，用户方所关心的是用户需求和运行质量平。\n\n### **2.软件开发**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225133.png)\n\n#### 2.解析\n\n1.  `甘特图`、`PERT`（计划评审技术）图及`CPM`（关键路径法）图是**软件项目管理中常用的管理开发进度的工具**，\n2. 鱼骨图是常用来发现问题根源并提出解决问题的有效办法的工具。在这三种开发进度管理工具图中，\n3. 甘特图能够消晰描述每个任务的开始/结束时间及各任务之间的并行性，也可以动态地反映项目的开发进展情况，但难以反映多个任务之间存在的逻辑关系；\n4. PERT利用项目的网络图和各活动所需时间的估计值（通过加权平均得到的）去计算项目总时间，强调任务之间的先后关系，但不能反映任务之间的并行性，以及项目的当前进展情况；\n5. CPM借助网络图和各活动所需时间，计算每一活动的最早或最迟开始和结束时间。CPM的关键是计算总时差，这样可决定哪一活动有最小时间弹性。PERT利用项目的网络图和各活动所需时间的估计值（通过加权平均得到）去计算项目总时间。\n6. PERT不同于CPM的主要点在于PERT利用期望值而不是最可能的活动所需时间估计（在CPM法中用的）。\n\n### **3.有限自动机**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225310.png)\n\n#### 2.解析\n\n对于该有限自动机，A为初态，C为终态，因此能识别的串一定是a开始b结束的串，可以排除C、D选项。 \n\n\n\n并且，对于该自动机能识别的串，经过初始a到达B状态后，只能识别b字符，因此A选项也错误。 本题只能选择D选项abab，是识别顺序如下图所示：       ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225457.png)\n\n### **4.软件维护类型**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225536.png)\n\n#### 2.解析\n\n1. 软件维护的内容一般包括准确性维护、适应性维护、完善性维护和预防性维护。\n2. 正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。\n3. 适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。\n4. 完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。\n5. 预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。\n\n### **5排序与查找.**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319225645.png)\n\n#### 2.解析\n\n1. 本题考查算法分析的基础知识。\n2. 排序和查找是基本的计算问题。存在很多相关的算法，不同的算法适用于不同的场合。不同的数据输入特点相同的算法也有不同的计算时间。\n3. 若数据基本有序，对插入排序算法而言，则可以在近似线性时间内完成排序。即 O(n)；\n4. 而对于快速排序而言，则是其最坏情况，需要二次时间才能完成排序，即O(n<sup>2</sup>)。两个算法在排序时仅需要一个额外的存储空间，即空间复杂度为常数O(1)。 \n\n### **6.树与二叉树**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319232605.png)\n\n#### 2.解析\n\n本题考查平衡查找树。\n由于平衡二叉树中任一结点的左右子树高度之差不超过1，因此，若在CR中插入一个结点并使得CR的高度增加1，则结点C的左右子树高度之差为-1，同时以C为根的子树高度增加了1，所以结点B的左右子树高度之差变为-1。如此一来，A的左子树的高度为h+2、右子树的高度为h，根据定义，以A为根的子二叉树变为不平衡。 \n\n### **7.Gant图与Pert图**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319231615.png)\n\n#### 2.解析\n\n 甘特图是一种能清晰描述每个任务的开始和截止时间，能有效获得任务并行进行的信息的项目进度管理工具。\n\n### **8.开发模型**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319232640.png)\n\n#### 2.解析\n\n 增量模型是一种非整体开发的模型，该模型具有较大的灵活性，适合于软件需求不明确的一种模型。使用该模型开发产品，一般是尽快构造出可运行的产品，然后在该产品的基础上再增加需要的新的构建，使产品更趋于完善。\n\n### **9.磁盘存取**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319231848.png)\n\n#### 2.解析\n\n1. 本题考查对磁盘调度方面基本知识掌握的程度。\n\n2. 因为先来先服务是谁先请求先满足谁的请求，而最短寻找时间优先是根据当前磁臂到要请求访问磁道的距离，谁短满足谁的请求，故先来先服务和最短寻找时间优先算法可能会随时改变移动臂的运动方向。 \n\n### **10.多媒体相关技术**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200319232041.png)\n\n#### 2.解析\n\n DPI即每英寸的点数，根据题目的描述，我们不难知道（300×600）/（2×4）=150 * 150 。","tags":["软件设计师考题"]},{"title":"2020年02月04日软件设计师每日一练","url":"/2020/03/17/2020年02月04日软件设计师每日一练/","content":"\n### **1.数据库设计过程**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317180424.png)\n\n#### 2.解析\n\n​    \t本题的正确选项为A。 \n`需求分析阶段的任务是：`对现实世界要处理的对象（组织、部门、企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理方法。\n\n`逻辑设计阶段的`任务之一是对关系模式进一步的规范化处理。因为生成的初始关系模式并不能完全符合要求，会有数据冗余、更新异常存在，这就需要根据规范化理论对关系模式进行分解，以消除冗余和更新异常。不过有时根据处理要求，可能还需要增加部分冗余以满足处理要求。逻辑设计阶段的任务就需要作部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。 \n\n### **2.段页式存储**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317180958.png)\n\n#### 2.解析\n\n1. 根据公式 ，可以分别计算段号，页号以及页内地址最大的寻址空间。\n2. 存储管理系统中的地址长度均表示为最大的寻址空间。及页内地址最大的寻址空间。存储管理系统中的地址长度均表示为最大的寻址空间。\n3. 页内地址为13位，即页大小为2<sup>13</sup>=8K；页号地址为11位，即页数最多为2<sup>11</sup>=2048；段号地址为8位，即段数最多为2<sup>8</sup>=256。\n\n#### 3.段页式存储\n\n1. **段页式存储管理方式**即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。右图示出了一个作业的地址空间和地址结构。\n\n   \n\n2. （**基本原理**） 该作业有三个段，页面大小为4 KB。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成，如下图所示。![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317181718.png)\n\n3. （**地址变换过程**）在段页式系统中，为了便于实现地址变换，须配置一个段表[寄存器](https://baike.baidu.com/item/寄存器)，其中存放段表始址和段表长TL。进行地址变换时，首先利用段号S，将它与段表长TL进行比较。若S<TL，表示未越界，于是利用段表始址\n\n   \n\n   和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的[页表](https://baike.baidu.com/item/页表)始址，并利用[逻辑地址](https://baike.baidu.com/item/逻辑地址)中的段内页号P来获得对应页的页表项位置，从中读出该页所在的[物理块](https://baike.baidu.com/item/物理块/12728827)号b，再利用块号b和页内地址来构成[物理地址](https://baike.baidu.com/item/物理地址)。右图示出了段页式系统中的地址变换机构。\n\n   在段页式系统中，为了获得一条指令或数据，须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正从第二次访问所得的地址中，取出指令或数据。\n\n   显然，这使访问[内存](https://baike.baidu.com/item/内存/103614)的次数增加了近两倍。为了提高执行速度，在地址变换机构中增设一个高速缓冲[寄存器](https://baike.baidu.com/item/寄存器)。每次访问它时，都须同时利用段号和页号去检索[高速缓存](https://baike.baidu.com/item/高速缓存)，若找到匹配的表项，便可从中得到相应页的物理块号，用来与页内地址一起形成[物理地址](https://baike.baidu.com/item/物理地址)；若未找到匹配表项，则仍须再三次访问内存。![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317181913.png)\n\n### **3.面向对象**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317182155.png)\n\n#### 2.解析\n\n​\t\t\t 面向对象的分析（OOA）是一种面向对象范型的半形式化描述技术。面向对象的分析包括3个步骤:第1步是用例建模，它决定了如何由产品得到各项计算结果。并以用例图和相关场景的方式展现出来；第2步是类建模，它决定了类及其属性，然后确定类之间的关系和交互；第3步是动态建模，它决定了类或每个子类的行为，并以状态图的形式进行表示。\n\n \t\t\tObject-oriented analysis （OOA） is a semiformal specification technique for the object-oriented paradigm.Object-oriented analysis consists of three steps.The first step is （）.It determines how the various results are computed by the product and presents this information in the form of a （） and associated scenarios.The second is  （） ， which determines the classes and their attributes， then determines the interrelationships and interaction among the classes.The last step is  （） ， which determines the actions performed by or to each class or subclass and presents this information in the form of 　（）.\n\n### **4.对称加密与非对称加密**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317182942.png)\n\n#### 2.解析\n\n本题考查的是信息安全中的加密算法。\n\n​\t\t\t其中：对大量明文进行加密，考虑效率问题，一般采用`对称加密`。\n`RSA`是非对称加密算法；`SHA-1`与`MD5`属于信息摘要算法；`RC-5`属于对称加密算法。这些算法中SHA-1与MD5是不能用来加密数据的，而RSA由于效率问题，一般不直接用于大量的明文加密，适合明文加密的，也就只有RC-5了。\n\n### **5.图**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317183258.png)\n\n#### 2.解析\n\n 在无向图中，一条边连接两个顶点，即如果存在一条边，那么与这条边相关的两个顶点的度都为加1，那么总的度就应该加2，因此，如果图中有n条边，那么所有顶点的度数之和就应该为2e。\n\n#### 3.无向图\n\n​\t无向图的边是没方向的，**即两个相连的顶点可以互相抵达。**\n\n​\t而有向图的边是有方向的，即两个相连的顶点，根据边的方向，**只能由一个顶点通向另一个顶点**。\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317190812.png)\n\n#### 4.[图表算法网址（有关无向图）](https://www.cnblogs.com/mcomco/p/10298021.html)\n\n### **6.侵权判断**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317183913.png)\n\n#### 2.解析\n\n​\t第一空涉及到向客户提供工具软件的复制品，这里侵犯了工具软件的软著权；\n\n​\t第二空，甲公司没有注册商标，并且没有描述商业秘密相关内容，所以不涉及商标权保护和不正当竞争法保护，而著作权是自作品完成之时就开始保护，所以甲公司当软件产品完成之后，该作品就已经受到著作权保护了，乙公司的行为侵犯了著作权。\n\n### **7.操作系统存储**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317191213.png)\n\n#### 2.解析\n\n 本题考查操作系统内存管理方面的基本概念。操作系统内存管理方案有许多种，其中，\n\n分页存储管理系统中的每一页只是存放信息的物理单位，其本身没有完整的意义，因而不便于实现信息的共享，\n\n而段却是信息的逻辑单位，各段程序的修改互不影响，无内碎片，有利于信息的共享。\n\n### **8.时间复杂度和空间复杂度？？？**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317184637.png)\n\n#### 2.解析\n\n1. X、Y的所有子序列都检查过后即可求出X、Y的最长公共子序列。X的一个子序列相应于下标序列1,2，...，n的一个子序列。因此，X共有2<sup>n</sup>个子序列。当然，Y也有2<sup>m</sup>个子序列。判断一个子序列是否也是Y的子序列的时间是n，因此时间复杂度为O(n2<sup>n</sup>)\n2. 动态规划的一个计算最长公共子序列的方法如下，两个序列 X、Y ：<br>\n   设有二维数组 c[i][j] 表示 X 的 i 位和 Y 的 j 位之前的最长公共子序列的长度，则有题干给定的函数表现形式<br>\n   其中，c(i,j)当 X 的第i位与 Y 的第 j 位完全相同时为“1”，否则为“0”。<br>\n   此时，c[i][j]中最大的数便是 X 和 Y 的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。该算法的空间、时间复杂度均为O(n<sup>2</sup>)。\n                                       \n\n### **9.多种程序语言特点**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317185400.png)\n\n#### 2.解析\n\n `可视化程序设计`主要是让程序设计入员利用软件本身所提供的各种控件，像搭积木式地构造应用程序的各种界面。可视化程序设计最大的优点是设计入员可以不用编写或只需编写很少的程序代码，就能完成应用程序的设计，这样就能极大地提高设计入员的工作效率。**在可视化程序设计中，可随时查看程序的运行效果。**\n\n### **10.Gant图Pert图**\n\n#### 1.题型\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200317185922.png)\n\n#### 2.解析\n\n  由于在一个项目中时间最长的活动序列，决定着项目最短工期。而时间最长的是ABDIJL&nbsp; ，需要时间20，所以答案是D。\n\n1. BD活动在AB活动结束之后便可以开始，同时AB是第1天开始，而非第0天开始，所以最早开始时间为4。\n2. HK活动需要在AEGH与ACFH两条路径上的活动均完成之后，才能开始，所以最早开始时间为11。","tags":["软件设计师考题"]},{"title":"2020年02月03日软件设计师每日一练","url":"/2020/03/16/2020年02月03日软件设计师每日一练/","content":"\n### **1. 计算机系统**\n\n#### 1.基础知识\n\n```\n本题考查的是计算机系统方面的基础知识。\n*系统响应时间*是指用户发出完整请求到系统完成任务给出响应的时间间隔。\n*作业吞吐量*是指单位时间内系统完成的任务量。若一个给定系统持续地收到用户提交的任务请求\n，则系统的响应时间将对作业吞吐量造成一定影响。若每个任务的响应时间越短，则系统的空闲资源较多，\n整个系统在单位时间内完成的任务量将越大；反之，若响应时间越长，则系统的空闲资源较少，整个系统在单位时间内完成的任务量将越小。\n```\n\n### **2.树与二叉树**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316170445.png)\n\n#### 2.解析\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316171306.png)\n\n### **3.系统部件可靠性**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316171439.png)\n\n#### 2.解析\n\n 本题考查多部件系统可靠性衡量方法。本题中，两个数据处理部件采用\n\n`并联结构A，算法1- （1- #）×（1- # ）`\n\n`串联算法 A × B =？`\n\n该部分的可靠性为1- （1-0.6）×（1-0.6） =0.84。设数据存储部件可靠性为R，则整个系统的可靠性为0.84×R≥0.66，所以R≥0.66/0.84≈0.79。\n\n### **4.软件工程质量**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316171837.png)\n\n#### 2.解析\n\n本题考查软件的质量度量指标。<br>\n\t&nbsp;&nbsp;&nbsp; 软件维护的工作量比开发阶段的工作量大，通常的估计是，开发阶段的工作量占软件生命期整个工作量的40%，而维护阶段的工作量则占60%，甚至更多。软件的正确性是指软件完成所需功能的程度，尽管这种程度与每千行代码的故障数有关，但不完全等同。软件完整性是指软件在安全方面抗攻击的能力。软件可用性用来度量软件的“用户友好性”，可以从4个方面来测量可用性： \n\n1. 学会操作软件所需的体力/智力\t　　\n2. 对系统的使用达到中等效率所需的时间\t　　\n3. 当系统由一个中等效率的人使用时测量到的生产率增长值\n4. 用户对系统的主观评价\n\n### **5.正规式**\n\n#### 1.题目/解析\n\n#### ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316172502.png)\n\n### **6.设计模式**\n\n#### 1.题目/解析\n\n<p>\n &nbsp;&nbsp;&nbsp; 本题考查设计模式的基本概念。<br>\n &nbsp;&nbsp;&nbsp; 设计模式最根本的目的在于复用相似问题的相同解决方案，从而提高软件在设计层次的复用度和设计的水平与质量。</p>\n\n### **7.综合知识**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316173203.png)\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316173250.png)\n\n#### 2.解析\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316173535.png)\n\n### **8.数据的表示**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316173726.png)\n\n#### 2.解析\n\n<p>\n\t&nbsp;&nbsp;&nbsp; 本题考查数据表示基础知识。<br>\n\t&nbsp;&nbsp;&nbsp; 根据补码定义，数值X的补码记作[X]<sub>补</sub>，如果机器字长为n，则最高位为符号位，0表示正号，1表示负号，正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加1。<br>\n\t&nbsp;&nbsp;&nbsp; 16位补码能表示的数据范围为[-2<sup>15 </sup>，2<sup>15</sup> -1] 。对于整数( 2<sup>16</sup> -1)和(-2<sup>16</sup> +1 )，数据表示需要16位，再加一个符号位，共17位，因此不在16位补码能表示的数据范围之内。<br>\n\t&nbsp;&nbsp;&nbsp; 在补码表示中，0有唯一的编码：[+0]<sub>补</sub>0000000000000000，[-0]<sub>补</sub>0000000000000000，即0000<sub>H</sub>。<br>\n\t&nbsp;&nbsp;&nbsp; [-1]<sub>原</sub>＝1000000000000001，[-1]<sub>反</sub>＝1111111111111110，因此-1的补码为[-1]<sub>补 </sub>=1111111111111111=FFFF。</p>\n\n\n\n#### 3.引申数据表示\n\n[详解网址](https://www.cnblogs.com/fuhaots2009/p/3476502.html)\n\n二进制中的原码、反码、补码 \n\n   对于有符号数而言：\n\n1.    (1)二进制的最高位是符号位：0表示正数，1表示负数\n2.    (2)正数的原码、反码、补码都一样；\n3.    (3)负数的反码 = 它的原码符号位不变，其他位取反（0 ->1 ; 1->0 ）；\n4.    (4)负数的补码 = 它的反码 +1；\n5.    (5)0的反码、补码都是0；\n6.    (6)在计算机运算的时候，都是以补码的方式来运算的；\n\n### **9.网络安全**\n\n#### 1.基础知识\n\n​                HTTPS以保密为目标研发，简单讲是HTTP的安全版。其安全基础是SSL协议，全称`Hypertext Transfer Protocol over Secure Socket Layer。` 它是一个URI scheme，句法类同http:体系。它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个协议的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于互联网上安全敏感的通讯，例如交易支付方面。 SSL极难窃听，对中间人攻击提供一定的合理保护。严格学术表述HTTPS是两个协议的结合，即传输层SSL＋应用层HTTP。\n\n### **10.设计模式**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200316175401.png)\n\n#### 2.解析\n\n图中所示模式为*生成器模式*，该模式适用于当创建复杂对象的算法应该独立于该对象的组成部分及其装配方式时。 \n`抽象工厂模式（Abstract Factory）:`提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类 .\n工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟。\n原型模式（Prototype）：用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象。\n\n\n\n","tags":["软件设计师考题"]},{"title":"2020年02月02日软件设计师每日一练","url":"/2020/03/15/2020年02月02日软件设计师每日一练/","content":"\n### **1.传值与传址**\n\n#### 1.题目\n\n调用引用方式下进行函数调用，是将（）\n\n#### 2.解析\n\n在函数调用时，系统为形参准备空间，并把实参的值赋值到形参空间中，在调用结束后，形参空间将被释放，而实参的值保持不变，这就是传值传递方式。传值传递方式中实参与形参之间的数据传递是单向的，只能由实参传递给形参，因而即使形参的值在函数执行过程中发生了变化，也不会影响到实参值。在C语言中，当参数类型是非指针类型和非数组类型时，均采用传值方式。\n\n传地址方式把实参的地址赋值给形参，这样形参就可以根据地址值访问和更改实参的内容，从而实现双向传递。当参数类型是指针类型或数组类型时，均采用传地址方式。\n\n### **2.数据的表示**\n\n#### 1.题目\n\n 计算机中的浮点数由三部分组成：符号位S，指数部分E（称为阶码）和尾数部分M。在总长度固定的情况下，增加E的位数、减少M的位数可以（  ）。\n\n#### 2.解析\n\n 浮点数的表述形式如下：N=M×r\n\n其中r是浮点数阶码的底，与尾数的基数相同，通常r=2.E和M都是带符号的定点数，E叫做阶码，M叫做尾数。浮点数的一般格式如图所示，浮点数的底是隐含的，在整个机器数中不出现。阶码的符号位为E<sub>s</sub>，阶码的大小反应了在数N中小数点的实际位置；尾数的符号位为M<sub>s</sub>，它也是整个浮点数的符号位，表示了该浮点数的正、负。\n\n![浮点数的一般格式](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315220936.png)\n\n 浮点数的大小由阶码部分决定，而其精度由尾数部分决定，因此增加E的位数、减少M的位数可以扩大可表示的数的范围同时降低精度。\n\n### **3.编译和解析**\n\n#### 1.题目\n\n 以下关于高级程序设计语言翻译的叙述中，正确的是（  ）。\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315221339.png)\n\n2.解析\n\n 在对用高级程序设计语言编写的程序进行执行时，首先是将源代码翻译成目标代码，然后在连接成可执行的二进制代码。因此在翻译阶段，目标代码生成阶段的工作与目标机器的体系结构密切相关。\n\n### **4.协议**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315222005.png)\n\n#### 2.解析\n\n本题考查的是电子邮件协议的基本知识。 　　\n\n常见的电子邮件协议包括SMTP（简单邮件传输协议）、POP3（邮局协议）和IMAP（ Internet邮件访问协议）。这几种协议都是由TCP/IP协议族定义的。SMTP < Simple Mail Transfer Protocol ）主要负责底层的邮件系统如何将邮件从一台机器传至另外一台机器。\n\n### **5.多媒体的基本概念**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315222218.png)\n\n#### 2.解析\n\n   彩色打印的纸张是不能发射光线的，因而彩色打印机使用能够吸收特定的光波而反射其他光波的油墨或颜料来实现。用油墨或颜料进行混合得到的彩色称为相减混色。之所以称为相减混色，是因为减少（吸收）了人眼识别颜色所需要的反射光。根据三基色原理，油墨或颜料的三基色是青（cyan）、品红（magenta）和黄（yellow ）。可以用这三种颜色的油墨或颜料按不同比例混合成任何一种由油墨或颜料表现的颜色，这种彩色表示方法称为CMY彩色空间。\n\n### **6.软件设计**\n\n#### 1.解析\n\n​\t本题考查软件系统设计知识。系统设计为系统制定蓝图，软件设计模型关注新系统总体结构、代码设计、处理过程、数据结构和界面模型等。对项目范围的关注在软件设计之前。\n\n### **7.Cache**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315222448.png)\n\n#### 2.解析\n\n 在程序的执行过程中，Cache与主存的地址映射是由硬件自动完成的。        \n\n#### 3.引申\n\nCache存储器，[电脑](https://baike.baidu.com/item/电脑/124859)中为[高速缓冲存储器](https://baike.baidu.com/item/高速缓冲存储器/9027270)，是位于[CPU](https://baike.baidu.com/item/CPU/120556)和[主存储器](https://baike.baidu.com/item/主存储器/10635399)DRAM（Dynamic Random Access Memory）之间，规模较小，但速度很高的存储器，通常由[SRAM](https://baike.baidu.com/item/SRAM/7705927)（Static Random Access Memory [静态存储器](https://baike.baidu.com/item/静态存储器/6797116)）组成。它是位于CPU与内存间的一种容量较小但速度很高的存储器。CPU的速度远高于内存，当CPU直接从内存中存取数据时要等待一定时间周期，而Cache则可以保存CPU刚用过或循环使用的一部分数据，如果CPU需要再次使用该部分数据时可从Cache中直接调用，这样就避免了重复存取数据，减少了CPU的等待时间，因而提高了系统的效率。Cache又分为L1Cache（一级缓存）和L2Cache（二级缓存），L1Cache主要是集成在CPU内部，而L2Cache集成在主板上或是CPU上。\n\n[详解网址](https://blog.csdn.net/tercel_zhang/article/details/81031476)\n\n### **8.数据结构**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315223337.png)\n\n#### 2.解析\n\n本题考查栈和队列的墓本概念及运算。<br>\n\t`栈是先进后出的线性表，而队列是先进先出的线性表。`若队列的输出元素序列为c、d、b、 a、 e，则进入队列的元素序列也为C， d， b， a， e，这也是从栈中出来的元素序列。<br>\n\t若元素以a、 b、c、d、e的次序进入栈S且得到输出序列c、d、 b、 a、e，则操作系列为a入栈、b入栈、C入栈、C出栈、d入栈、d出栈、b出栈、a出栈、e入栈、e出栈。第一个出栈的元素为c，则c出栈时元素a和b尚在栈中，如下图所示。<br>\n ![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315223523.png)\n栈S的容量至少为3。</p>\n\n### **9.排序与查找**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315223721.png)\n\n#### 2.解析\n\n<p>将有序表放入数组如下：<br>\n根据二分法的查找过程： \n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315223950.png)\n\n（1）第一轮比较对象（0+8）/2=4，即与序号为4的关键字26进行比较；<br>（2）第二轮如果选择左侧较小列，则下一个比较对象应该为（0+3）/2=1（向下取整），即与序号为1的关键字15比较，没有对应的选项；<br>（3）第二轮如果选择右侧较大列，则下一个比较对象应该为（5+8）/2=6（向下取整），即与序号为6的关键字40进行比较。<br>所以应该选择C选项。<br></p>\n\n### **10.线性表**\n\n#### 1.题目\n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200315224129.png)\n\n#### 2.解析\n\n本题考查循环队列长度的求取\n\n根据图示，可以得到长度（Q.rear-Q.front+M），但在此不容忽视的一个问题是，循环队列在进行了多次入队出队操作之后，可能出现超出队列长度溢出的情况，因此需要让其与M进行求模操作，修正位置，故（Q.rear-Q.front+M）%M为队列中的元素个数（即队列长度）","tags":["软件设计师考题"]},{"title":"2020年02月01日软件设计师每日一练","url":"/2020/03/14/2020年02月01日软件设计师每日一练/","content":"### **1.正规式** ### \n\n1. 技术点解析\n\n\t[正规式解释引用网址](https://blog.csdn.net/apollo_miracle/article/details/101829315)\n\t   \n\t**单词的描述工具-正规式** ：多数程序设计语言的单词的语法均可用正规文法来表示。\n\t正规文法 (3型文法) ：任一产生式的形式都为A→aB或A→a，其中A∈VN ，B∈VN ，a∈VT * , 正规文法描述的是VT上的正规集。\n\t\n\t**例：**程序设计语言中几类单词的描述规则：标识符、无符号整数、运算符…。\n\t\n\t**正规式（regular expression也叫正则表达式）**：正规式是定义正规集的数学工具，是说明单词的模式(pattern)的一种表示法，用它描述单词符号时一般比正规文法更简洁。正规式和正规集 (即其描述的语言) 的定义可以用递归的形式给出。\n\n\t**正规式 :**\n\n\t\t设∑是有穷字母表，并定义辅助字母表∑’={Φ, ε, | , . , *, (, )}\n\t\tε,Φ都是∑上的正规式，它们所表示的正规集为{ε}, Φ ;\n\t\t任何a是一个正规式，若a∈∑，它所表示的正规集为{a}；\n\t\t\n\t\t如果R1和R2是正规式，它们表示的正规集分别为L1和L2，则 R1|R2 , R1·R2 , R1* , (R1) 也是正规式，\n \t\t并且它们所表示的正规集分别为L1∪L2 ；L1L2；L1* ； L1\n\t\t仅有有限次使用上述三步骤而定义的表达式才是∑上的正规式，仅有这些正规式表示的字集才是∑上的正规集。\n\t\t\n\t\t注意： 不要混淆Φ和ε，正规表达式ε描述的语言只含一个空字符串ε，而Φ表示的语言不含有任何字符串。\n\t\t程序设计语言的单词都能用正规式来定义。若两个正规式e1,e2表示的正规集相同，则称它们等价。记作:e1=e2\n\n\t\t例 : 令∑={a,b},则∑上的正规式和相应正规集为\n\t\t\n\t\t正规式\t\t正规集\n\t\ta\t\t\t{a}\n\t\ta|b\t\t\t{a,b}\n\t\tab\t\t\t{ab}\n\t\t(a|b)(a|b)\t{aa,ab,ba,bb}\n\t\ta*\t  \t\t{ε ,a,aa, ……任意个a的串}\n\t\t(a|b)*\t\t{ε ,a,aa, ……任意个a的串}{ε ,a,b,aa,ab,bb ……所有由 a和b组成的串}\n\t\t(a|b)* (aa|bb)(a|b)*\t∑上所有含有两个相继的a或两个相继的b组成的串}\n\t\t\n\t\t例 : 令∑={a，d}，其中a代表字母,d代表数字，则∑上的正规式 r=a(a|d) * 定义的正规集为\n\t\t\n\t\t{a,aa,ad,add,……}， 即：字母(字母|数字) * ,它表示的正规集中的每个元素的模式是“字母打头的字母数字串”,也就是多数程序语言中标识符的词法规则.\n \n2. 题型\n\t<p>\n\t以下关于语言L={a<sup>n</sup>b<sup>n</sup>|n&gt;=1}的叙述中，正确的是（ &nbsp;）。</p>\n \n     A.可用正规式“aa*bb*”描述，但不能通过有限自动机识别 <br>  \n     B.可用正规式“a<sup>m</sup>b<sup>m</sup>”表示，但可用有限自动机识别 <br> \n    \n\t C.不能用正规式表示，但可用有限自动机识别 <br>  \n\t D.既不能用正规式表示，也不能通过有限自动机识别<br><br> \n3. 题型解析\n\t                                    \n\t与L语言最接近的正规式为：aa*bb*\n\t与L语言最接近的有限自动机为：\n\n\t![](https://gitee.com/yichangkong/FigureBed/raw/master/img/正规式.jpg)\n\t\n\t但无论如何无法构造出完全等价的正规式，因为在L语言中，n的取值无论为多少，a与b的数量都相等，而aa*bb*无法保障这一点。\n4. 引申正规表达式 》[菜鸟](https://www.runoob.com/regexp/regexp-rule.html)\n\n\t正则表达式 - 语法\n\t正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n       \n\n### **2.网络规划与设计** ### \n\n\t层次化网络设计中各个层次的主要功能包括：<br>\n\t接入层：用户接入、计费管理、MAC地址认证、收集用户信息。<br>\n\t汇聚层：网络访问策略控制、数据包处理、过滤、寻址。<br>\n\t核心层：高速数据交换，常用冗余机制。\n \n### **3.编译与解析** ###\n               \n\t用高级语言编写的程序不能直接被机器执行，而是经过相关的处理后，\n\t将其变成目标程序后才能被机器执行，而这一过程就是一个编译的过程，而实现这个功能的程序就称为编译程序。\n \n\n### **4.多媒体技术基本概念** ###     \n                   \n   \n\tdpi是Donts Per Inch 的缩写，也就是每英寸的像素\n \n\n### **5.计算机硬件基础** ###\n1. 题      \n\n某计算机系统由下图所示的部件构成，假定每个部件的千小时可靠度R均为0.9，则该系统的千小时可靠度约为（）。\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200314204140.png)\n\n2. 解析\n\t<p>\n\t 本题考查系统可靠度的概念。<br>\n\t 串联部件的可靠度=各部件的可靠度的乘积。<br>\n\t 并联部件的可靠度=1－各部件失效率的乘积。<br>\n\t 题目中给出的系统由两个部件分别串联然后并联，\n\t最好将并联的组成再与一个部件串联，要求解这类问题，应该首先计算出并联中的串联，计算结果为&nbsp;0.9*0.9，如何两部分并联，计算结果为（1-（1-0.9*0.9）*（1-0.9*0.9）），最后再串联，计算结果为&nbsp;&nbsp; 0.9*（1-（1-0.9*0.9）*（1-0.9*0.9））=0.867。</p>\n \n\n### **6.颜色深度** ###\n\n\n      颜色深度决定了彩色图像中可出现的最多颜色数，或灰度图像中的最大灰度等级。如一幅图像的图像深度为b位，则该图像的最多颜色数或灰度级为2b种.\n\t显然，表示一个像索颜色的位数越多，它能表达的颜色数或灰度级就越多。一幅彩色图像的每个像素有16位，\n\t则最大颜色数目为216=65 536。就是说像素的深度为16位，每个像素可以是216种颜色中的一种。\n\t表示一个像索的位数越多，它能表达的颜色数目就越多，它的深度就越深。\n \n### **7.数组与矩阵** ###\n\n1.题\n\n\t设某n阶三对角矩阵A<sub>nxn</sub>的示意图如下图所示。若将该三对角矩阵的非零元素\n\t按行存储在一维数组B （1≤k≤3*n-2）中，则k与i、j的对应关系是（ &nbsp;）。</p>  \n\n![](https://gitee.com/yichangkong/FigureBed/raw/master/img/20200314205206.png)\n\n2.解析\n  \n    该题最简单的解题思路是代入法。当i=1,j=1时，k=1。<br>\n\t选项A：k=2i+j-2=2+1-2=1；<br>\n\t选项B：k=2i-j+2=2-1+2=3；<br>\n\t选项C：k=3i+j-1=3+1-1=3；<br>\n\t选项D：k=3i-j+2=3+1+2=4。<br>\n\t此时可以除排B，C，D，直接选A。若用一个例子，不能排除所有错误选项， \n    则而举一个例子来进行代入，排除更多错误选项。<br>\n \n### **8.内存** ###    \n\n \n1.题\n\t若某计算机字长为32位，内存容量为2GB，按字编址，则可寻址范围为（ &nbsp;）。\n2.解析\n \n\t计算机字长为32位，按字编址（即1个字32个位，4个字节），\n\t则总容量为2GB的内存可规划的单元地址数量为：2GB/32bit=2GB/4B=0.5G=512M。 p> \n \n### **9.FM音乐合成** ###\n \n    改变数字载波频率可以改变乐音的音调。<br>\n\t改变它的幅度就可以改变乐音的音高。<br>\n                                        \n                                               ","tags":["软件设计师考题"]},{"title":"Stack","url":"/2020/03/11/Stack/","content":"![](https://gitee.com//yichangkong/FigureBed/raw/master/img/stack.png)\n### 1.简介 ###\n栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n### 2.基本算法 ###\n\n\t1．进栈（PUSH）算法\n\t\t①若TOP≥n时，则给出溢出信息，作出错处理（进栈前首先检查栈是否已满，满则溢出；不满则作②）；\n\t\t②置TOP=TOP+1（栈指针加1，指向进栈地址）；\n\t\t③S(TOP)=X，结束（X为新进栈的元素）；\n\t2．退栈（POP）算法\n\t\t①若TOP≤0，则给出下溢信息，作出错处理(退栈前先检查是否已为空栈， 空则下溢；不空则作②)；\n\t\t②X=S(TOP)，（退栈后的元素赋给X）：\n\t\t③TOP=TOP-1，结束（栈指针减1，指向栈顶）。\n\n### 3.项目实践 ###\n\n\t\tpackage DataStructures.Stack;\n\t\t\n\t\t/**\n\t\t * @author yichangkong\n\t\t * @create 2020-03-10-16:29\n\t\t * <p>用数组模拟栈结构\n\t\t */\n\t\tpublic class ArrayStackDemo {\n\t\t\n\t\t    public static void main(String[] args) {\n\t\t\n\t\t        //测试\n\t\t        //添加数据\n\t\t        ArrayStack stack = new ArrayStack(8);\n\t\t\n\t\t        stack.push(1);\n\t\t        stack.push(2);\n\t\t        stack.push(8);\n\t\t        stack.push(4);\n\t\t        stack.push(5);\n\t\t        stack.list();\n\t\t    }\n\t\t    static class ArrayStack {\n\t\t        private int maxSize;//栈的大小\n\t\t        private int[] stack;//数组模拟栈  测试数据放在数组\n\t\t        private int top = -1;\n\t\t\n\t\t        //构造器\n\t\t        public ArrayStack(int maxSize) {\n\t\t            this.maxSize = maxSize;\n\t\t            stack = new int[this.maxSize];\n\t\t        }\n\t\t\n\t\t\n\t\t        //判断是否栈满\n\t\t        public boolean ifFull() {\n\t\t            return top == maxSize - 1;\n\t\t\n\t\t        }\n\t\t\n\t\t        //判断栈是否为空\n\t\t        public boolean ifEmpty() {\n\t\t\n\t\t            return top == -1;\n\t\t        }\n\t\t\n\t\t        //入栈\n\t\t        public void push(int value) {\n\t\t\n\t\t            //判断是否栈满\n\t\t            if (ifFull()) return;\n\t\t            //添加\n\t\t            top++;\n\t\t            stack[top] = value;\n\t\t\n\t\t        }\n\t\t\n\t\t        //出栈 先入后出\n\t\t        public int pop() {\n\t\t\n\t\t            //判断是否kong\n\t\t            if (ifEmpty()) {\n\t\t                System.out.println(\"栈空 请插入数据进行测试\");\n\t\t                return 0;\n\t\t            }\n\t\t            //try { return stack[top]; } finally { top--; }这个方法着实有些撒比了\n\t\t            //以为 show 和 pop两个之间的top会影响\n\t\t\n\t\t            int cur = top;\n\t\t\n\t\t            int value = stack[top];\n\t\t            top--;\n\t\t            return value;\n\t\t\n\t\t        }\n\t\t        //显示栈的情况 比如栈的size\n\t\t\n\t\t        public void list() {\n\t\t            if (ifEmpty()) {\n\t\t                System.out.println(\"栈空 请插入数据进行测试\");\n\t\t                return;\n\t\t            }\n\t\t            for (int i = top; i > -1; i--) {\n\t\t\n\t\t                System.out.println(stack[i]);\n\t\t\n\t\t            }\n\t\t\n\t\t        }\n\t\t    }\n\t\t\n\t\t}\n\t\t\n\n","tags":["数据结构学习"]},{"title":"position详解","url":"/2020/02/03/position详解/","content":"\n<div style=\"text-align: center;\">\n<img src=\"http://ww1.sinaimg.cn/large/007SCiiVgy1gbj7vr8hu0j30i207d3ym.jpg\"/>\n</div>\n\n# Css 详细解读定位属性 position 以及参数 #\n[参考链接](https://blog.csdn.net/FungLeo/article/details/50056111)\n### **简介** ###\nposition 定位属性，是CSS中非常重要的属性。除了文档流布局，就是定位布局了。\n但是很多人都不清楚position参数。详细解读一下position 以及参数。\n\n### **1.W3c介绍** ###\n\n- 定义和用法\n\t\tposition 属性规定元素的定位类型。\n\t\t\n\t\t说明\n\t\t这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。\n\t\t\n\t\t默认值：\tstatic\n\t\t继承性：\tno\n\t\t版本：\tCSS2\n\t\tJavaScript 语法：\tobject.style.position=\"absolute\"\n\n\n- 可能的值\n\t\t值\t描述\n\t\tabsolute\t\n\t\t生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。\n\t\t\n\t\t元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。\n\t\t\n\t\tfixed\t\n\t\t生成绝对定位的元素，相对于浏览器窗口进行定位。\n\t\t\n\t\t元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。\n\t\t\n\t\trelative\t\n\t\t生成相对定位的元素，相对于其正常位置进行定位。\n\t\t\n\t\t因此，\"left:20\" 会向元素的 LEFT 位置添加 20 像素。\n\t\t\n\t\tstatic\t默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。\n\t\tinherit\t规定应该从父元素继承 position 属性的值。\n\n### **1.基础解释** ###\n\n`static` 默认值，就是没有定位，那就没必要多解释了。`inherit` 继承父元素，基本上这个参数用得相当少，所以也不做过多的解释。\n\n### **2.文档流布局的概念** ###\n什么是文档流布局？我百度了一下相对严谨的解释:\n\n**将窗体自上而下分成一行行， 并在每行中按从左至右的顺序排放元素，即为文档流。 \n每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端。 若当前行容不下， 则另起新行再浮动。\n内联元素也不会独占一行。 几乎所有元素(包括块级，内联和列表元素）均可生成子行， 用于摆放子元素。 \n有三种情况将使得元素脱离文档流而存在，分别是 浮动，绝对定位， 固定定位。 但是在IE6中浮动元素也存在于文档流中。**\n\n关于浮动会脱离文档流，这里我就不解释了。因为我们一般会大力避免这种问题，而使用清除浮动的方法。上面引用的文字中，绝对定位 是指 position:absolute ，而 固定定位 是指 position:fixed。\n\n\n![](http://ww2.sinaimg.cn/mw690/459e195ajw1eye7cznpydj20ee06uwej.jpg)\n如上图所示，这就是正常的文档流布局。一个一个挨着的，到头了，另起一行，接着排布。\n\n理解文档流布局，是理解本文的基础，文档流布局也是css布局最基础的知识。这里就不详细赘述了。\n\n\n### **3.position:relative 相对定位** ###\n\n什么是相对定位？相对什么定位？这是重要的问题。我的回答是——**相对自己文档流中的原始位置定位。它的特点是——不会脱离文档流。**\n\n也就是说，使用position:relative定位，其元素依旧在文档流中，他的位置可以使用 left、right、top、bottom、z-index等定位参数，但是，他的存在，还是会影响文档中紧跟在他周围的元素的。\n\n无论多少文字描述，可能都无法让你理解。下面，我们看一下实际效果。\n\nposition:relative定位效果\n\n如上图的演示，我给test3加上了position:relative定位效果。代码如下：\n\nposition: relative;left: -20px;top: 20px;\n![](http://ww2.sinaimg.cn/large/459e195ajw1eye7u70wnuj20ef06v0t2.jpg)\n\n大家可以清晰的从图上看出来，test3根据CSS参数left: -20px;top: 20px;发生了位移。\n\n但是！但是！但是！重要的事情说三遍，**它的唯一并没有对周围的元素有任何的影响！！\n它依然存在于文档流中。它的位移是根据它在文档流中的原始位置发生的！！**这一点非常非常重要。\n\n通过上面的图片和阐释，我相信大家都对position:relative参数有了深刻的理解了。但这没完。下面我们还有关于它的内容。\n\n\n### **4.position:fixed 相对浏览器定位** ###\n相比而言，这个参数是最好理解的。它相对于浏览器的窗口进行定位。同时——它会脱离文档流\n\n好，还是上图片。\n![](http://ww4.sinaimg.cn/large/459e195ajw1eye84a2kb8j20mm0afdh1.jpg)\n\nposition:fixed相对浏览器定位效果一\n\n代码如下：\n\nposition: fixed;right:20px;top: 20px;\n1\n \t\n这是初始状态，**我们可以看到它的特点：**\n\n- 它脱离了文档流，原来文档流中不存在它的位置，test4好像test3不存在一样的紧贴在了test2的后面。\n- 它的right:20px;top: 20px;参数是相对浏览器窗口定位的。\n\n好，我们再来看一下，当页面发生滚动的效果图。\n![](http://ww2.sinaimg.cn/large/459e195ajw1eye8454x0sj20mm0afq3x.jpg)\n\nposition:fixed相对浏览器定位效果二\n\n当页面发生了滚动，我们可以看到，页面的内容已经根据滚动条的位置发生了位移。但是我们的test3 依旧是在相对于浏览器的位置。\n\n通过上面的图文阐释，我相信，大家对于 position:fixed 参数已经有了深刻的理解了。\n\n其实position:fixed不难理解。\n\n\n### **5.position:absolute 绝对定位** ###\n绝对定位是一个非常牛逼的属性，牛逼到，你不知道会发生什么。\n注意，它的解释是什么——“生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。”\n\n也就是说，它可以相对于各种各样的东西进行定位。除了 static 其他都可以！！！注意！注意！注意！ 是 除了 ！\n\n也正是因为这一牛逼特性，导致很多人对此概念混乱。其实，这个一点也不混乱，我们可以将概念理顺了，分成几个情况来说。\n\n    PS:position:absolute和position:fixed一样是会脱离文档流的。这里就不解释脱离文档流的问题，主要研究它的定位问题。\n\n\n\n### **6.它的所有父元素的属性都是 position:static** ###\n怎么理解这个标题？position:static 是所有html元素默认参数。就是说，这个元素的所有上级元素，你都没有使用过定位方式。\n\n我们通过如下代码模拟一个场景：\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>Document</title>\n\t    <style>\n\t        div {font-size: 15px;color: #fff;}\n\t        .test1 {width: 500px;height: 500px;background: #123;}\n\t        .test2 {width: 400px;height: 400px;background: #234;}\n\t        .test3 {width: 300px;height: 300px;background: #345;position: absolute;right: 20px;top: 20px;}\n\t    </style>\n\t</head>\n\t<body>\n\t    <div class=\"test1\">\n\t        test1\n\t        <div class=\"test2\">\n\t            test2\n\t            <div class=\"test3\">test3</div>\n\t        </div>\n\t    </div>\n\t</body>\n\t</html>\n\n如上，test3是test2的子元素，test1的孙元素。我们来看一下效果图：\n![position:absolute效果一](http://ww2.sinaimg.cn/large/459e195ajw1eye8ok45vuj20o20i50u0.jpg)\n\n\n**如上图所示。我们可以看到，test3既没有相对于父元素定位，也没有相对于爷元素定位。它居然和position:fixed一样！相对于浏览器定位了！！**\n\n！！！这是一个错觉！！\n\n我们来看一下浏览器发生滚动之后的效果，如下图所示：\n\n![position:absolute效果2](http://ww3.sinaimg.cn/large/459e195ajw1eye936bxeyj20o20i5t9t.jpg)\n\n如上图所示，它并非是相对于浏览器定位，而是相对于文档定位。\n\n如果你有一点js基础的话，那么应该很容易理解。$(document)和$(window)的差别（为了看得清楚，用了JQ写法）\n\n相对于文档，就是相对于整个页面来进行布局，而相对于窗口，则是相对于浏览器的可视区域进行定位，这二者有本质的区别的。\n\n这种情况在实际应用中有，但是不多。下面，我们再来看其他情况。\n\n\n### **它的父元素的属性是 position:relative** ###\n上面，我们已经说过了，position:relative是相对于自身原始位置定位，其自身并没有脱离文档流。而它的子元素，使用position:absolute参数是什么效果呢？我们来做个试验。下面是代码：\n\t\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>Document</title>\n\t    <style>\n\t        div {font-size: 15px;color: #fff;}\n\t        .test1 {width: 500px;height: 500px;background: #123;}\n\t        .test2 {width: 400px;height: 400px;background: #234;position: relative;left: 50px;top: 50px;}\n\t        .test3 {width: 300px;height: 300px;background: #345;position: absolute;right: -20px;top: -20px;}\n\t    </style>\n\t</head>\n\t<body>\n\t    <div class=\"test1\">\n\t        test1\n\t        <div class=\"test2\">\n\t            test2\n\t            <div class=\"test3\">test3</div>\n\t        </div>\n\t    </div>\n\t</body>\n\t</html>\n\n我们给test2加上了position:relative属性，并给出了偏移值，然后，再给test3使用绝对定位，使用了为负数的偏移值，我们来看一下效果图，如下：\n\n![](http://ww4.sinaimg.cn/large/459e195ajw1eyechudvxxj20i10hx75a.jpg)\n\n从上图我们可以看到，test2如我们所愿的，相对于自身的位置发生了偏移，而test3则相对于test2发生了偏移。\n\n从这个试验我们可以看出，当一个元素设置了position:absolute属性之后，而它的父元素的属性为position:relative则，**它不再是相对于文档定位，而是相对于父元素定位**。\n\n这一点非常重要。最最重要的是，父元素设置为position:relative并不会脱离文档流，也就是说——利用给父元素设置position:relative属性，再将子元素设置为position:absolute就可以在文档流中实现需要的定位\n\n这一点异常重要，也是非常常用的方法！\n（PS:**基本上焦点图等常见应用，都是使用了这种方式**）\n\n\n### **它的父元素的属性是 position:fixed** ###\n上面，我们说了父元素为position:relative的情况，这种情况比较常见，那么它的父元素为 position:fixed 又是什么情况呢？如果你聪明的话，应该有了答案。我们来做一个试验，来印证一下你的想法。代码如下：\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>Document</title>\n\t    <style>\n\t        div {font-size: 15px;color: #fff;}\n\t        .test1 {width: 500px;height: 500px;background: #123;}\n\t        .test2 {width: 400px;height: 400px;background: #234;position: fixed;right: 20px;top: 20px;}\n\t        .test3 {width: 300px;height: 300px;background: #345;position: absolute;left: -40px;top: 40px;}\n\t    </style>\n\t</head>\n\t<body>\n\t    <div class=\"test1\">\n\t        test1\n\t        <div class=\"test2\">\n\t            test2\n\t            <div class=\"test3\">test3</div>\n\t        </div>\n\t    </div>\n\t</body>\n\t</html>\n\n好，我们可以看到我给test2加上了position: fixed;right: 20px;top: 20px; 它会相对于浏览器窗口定位，而test3作为test2的子元素，我们加上了position: absolute;left: -40px;top: 40px;那么，根据我们的想象，它应该相对于test2作出偏移。那么是不是这个情况呢？我们来看一下效果图：\n![](http://ww2.sinaimg.cn/large/459e195ajw1eyedejrgpbj20la0i6my7.jpg)\n\n\n如上图所示，看到了具体的效果了吧！是不是和你想象的是一样的呢？\n\n\n### **它的父元素的属性是 position:absolute** ###\n好，我们来看一下，如果position:absolute嵌套position:absolute元素将会出现什么情况呢？\n\n写了这么多，其实你应该有了一定的预见性了吧？好，我们来做试验，代码如下：\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>Document</title>\n\t    <style>\n\t        div {font-size: 15px;color: #fff;}\n\t        .test1 {width: 500px;height: 500px;background: #123;}\n\t        .test2 {width: 400px;height: 400px;background: #234;position: absolute;right: 20px;top: 20px;}\n\t        .test3 {width: 300px;height: 300px;background: #345;position: absolute;right: 20px;top: 20px;}\n\t    </style>\n\t</head>\n\t<body>\n\t    <div class=\"test1\">\n\t        test1\n\t        <div class=\"test2\">\n\t            test2\n\t            <div class=\"test3\">test3</div>\n\t        </div>\n\t    </div>\n\t</body>\n\t</html>\n\n如上所示，test2我们使用了position: absolute;right: 20px;top: 20px;参数，那么，它会相对于**文档**作出设定的偏移值。而我们给test3使用了同样的css样式。如果test3也是**相对于文档定位**的话，那么它和test2应该是重叠的。\n\n但是，我们根据上面的解释，test3应该相对于test2定位才对，那么是不是呢？我们看效果图：\n![](http://ww4.sinaimg.cn/large/459e195ajw1eyedktnqnoj20la0i6dgw.jpg)\n\n\n如上图所示，果然，test2相对于文档偏移，而test3相对于test2偏移。 \n\n\n### **position 以及参数总结** ###\n- position: relative;不会脱离文档流，position: fixed;position: absolute;会脱离文档流\n- position: relative; 相对于自己在文档流中的初始位置偏移定位。\n- position: fixed; 相对于浏览器窗口定位。\n- position: absolute; 是相对于父级非position:static 浏览器定位。\n  如果没有任何一个父级元素是非position:static属性，则会相对于文档定位。\n  这里它的父级元素是包含爷爷级元素、祖爷爷级元素、祖宗十八代级元素的。任意一级都可以。\n  如果它的父级元素和爷爷级元素都是非position:static 属性，则，它会选择距离最近的父元素。\n\n","tags":["知识点讲解"]},{"title":"HTML5技术概述","url":"/2020/01/28/HTML5技术概述/","content":"<div style=\"text-align: center;\">\n<img src=\"http://ww1.sinaimg.cn/large/007SCiiVgy1gbcdr3swixj303k03k3ya.jpg\">\n\n</div>\n\n\n## 1. H5概述 ##\n\nHTML5 是定义 HTML 标准的最新的版本。 该术语通过两个不同的概念来表现：\n\n它是一个新版本的HTML语言，具有新的元素，属性和行为，\n它有更大的技术集，允许构建更多样化和更强大的网站和应用程序。这个集合有时称为HTML5和它的朋友们，不过大多数时候仅缩写为一个词 HTML5。\n设计为所有Open Web开发人员都可以使用，此引用页面链接到许多关于HTML5技术的资源，根据其功能分为几个组。\n\n- 语义：能够让你更恰当地描述你的内容是什么。\n- 连通性：能够让你和服务器之间通过创新的新技术方法进行通信。\n- 离线 & 存储：能够让网页在客户端本地存储数据以及更高效地离线运行。\n- 多媒体：使 video 和 audio 成为了在所有 Web 中的一等公民。\n- 2D/3D 绘图 & 效果：提供了一个更加分化范围的呈现选择。\n- 性能 & 集成：提供了非常显著的性能优化和更有效的计算机硬件使用。\n- 设备访问 Device Access：能够处理各种输入和输出设备。\n- 样式设计: 让作者们来创作更加复杂的主题吧！\n  \n## 2.新增语义标签 ##\n\n\tHTML5 中的区块和段落元素\n\t\n\tHTML5 中新的区块和段落元素一览: <section>, <article>, <nav>, <header>, <footer>, <aside> 和 <hgroup>\n\t使用 HTML5 的音频和视频\n\t<audio> 和 <video> 元素嵌入和允许操作新的多媒体内容。\n\t\n\t表单的改进\n\t看一下 HTML5 中对 web 表单的改进：强制校验API，一些新的属性，一些新的<input> 元素type 属性值 ，新的 <output> 元素。\n\t\n\t新的语义元素\n\t除了节段，媒体和表单元素之外，还有众多的新元素，例如 <mark>， <figure>， <figcaption>， <data>， <time>， <output>， <progress>， \n\t或者 <meter>和<main>，这增加了有效的 HTML5 元素的数量。\n\t\n\t<iframe> 的改进\n\t使用 sandbox， seamless， 和 srcdoc 属性，作者们现在可以精确控制 <iframe> 元素的安全级别以及期望的渲染。\n\t\n\tMathML\n\t允许直接嵌入数学公式。\n\n \n\n\n## 3.通信 ##\n\n\tWeb Sockets\n\t允许在页面和服务器之间建立持久连接并通过这种方法来交换非 HTML 数据。\n\t\n\tServer-sent events\n\t允许服务器向客户端推送事件，而不是仅在响应客户端请求时服务器才能发送数据的传统范式。\n\t\n\tWebRTC\n\t这项技术，其中的 RTC 代表的是即时通信，允许连接到其他人，直接在浏览器中控制视频会议，而不需要一个插件或是外部的应用程序。\n\n## 4.离线 & 存储 ##\n\n1. 离线资源：应用程序缓存\n 火狐全面支持 HTML5 离线资源规范。其他大多数针对离线资源仅提供了某种程度上的支持。\n2. 在线和离线事件\nFirefox 3 支持 WHATWG 在线和离线事件，这可以让应用程序和扩展检测是否存在可用的网络连接，以及在连接建立和断开时能感知到。\n3. WHATWG 客户端会话和持久化存储 (又名 DOM 存储)\n客户端会话和持久化存储让 web 应用程序能够在客户端存储结构化数据。\n4. IndexedDB\n是一个为了能够在浏览器中存储大量结构化数据，并且能够在这些数据上使用索引进行高性能检索的 Web 标准。\n自 web 应用程序中使用文件\n5. 对新的 HTML5 文件 API 的支持已经被添加到 Gecko 中，从而使 Web 应用程序可以访问由用户选择的本地文件。这包括使用 type file 的  `<input>`元素的新的 multiple 属性针对多文件选择的支持。 还有 FileReader。\n\n\n## 5.性能 & 集成##\n\n\n1. Web Workers\n能够把 JavaScript 计算委托给后台线程，通过允许这些活动以防止使交互型事件变得缓慢。\n2. XMLHttpRequest Level 2\n允许异步读取页面的某些部分，允许其显示动态内容，根据时间和用户行为而有所不同。这是在 Ajax背后的技术。\n3. 即时编译的 JavaScript 引擎\n新一代的 JavaScript 引擎功能更强大，性能更杰出。\n4. History API\n允许对浏览器历史记录进行操作。这对于那些交互地加载新信息的页面尤其有用。\n5. contentEditable 属性：把你的网站改变成 wiki !\nHTML5 已经把 contentEditable 属性标准化了。了解更多关于这个特性的内容。\n6. 拖放\nHTML5 的拖放 API 能够支持在网站内部和网站之间拖放项目。同时也提供了一个更简单的供扩展和基于 Mozilla 的应用程序使用的 API。\n7. HTML 中的焦点管理\n支持新的 HTML5 activeElement 和 hasFocus 属性。\n8. 基于 Web 的协议处理程序\n你现在可以使用 navigator.registerProtocolHandler() 方法把 web 应用程序注册成一个协议处理程序。\n9. requestAnimationFrame\n允许控制动画渲染以获得更优性能。\n10. 全屏 API\n为一个网页或者应用程序控制使用整个屏幕，而不显示浏览器界面。\n11. 指针锁定 API\n允许锁定到内容的指针，这样游戏或者类似的应用程序在指针到达窗口限制时也不会失去焦点。\n12. 在线和离线事件\n为了构建一个良好的具有离线功能的 web 应用程序，你需要知道什么时候你的应用程序确实离线了。顺便提一句，在你的应用程序又再回到在线状态时你也需要知道。\n\n## 6.设备访问 ##\n\n1. 使用 Camera API\n允许使用和操作计算机的摄像头，并从中存取照片。\n2. 触控事件\n对用户按下触控屏的事件做出反应的处理程序。\n3. 使用地理位置定位\n让浏览器使用地理位置服务定位用户的位置。\n4. 检测设备方向\n让用户在运行浏览器的设备变更方向时能够得到信息。这可以被用作一种输入设备（例如制作能够对设备位置做出反应的游戏）或者使页面的布局跟屏幕的方向相适应（横向或纵向）。\n5. 指针锁定 API\n允许锁定到内容的指针，这样游戏或者类似的应用程序在指针到达窗口限制时也不会失去焦点。\n\n## 7.样式(css3) ##\n\n\tCSS 已经扩展到能够以一个更加复杂的方法给元素设置样式。这通常被称为 CSS3, 尽管 CSS 已经不再是很\n\t难触动的规范，并且不同的模块并不全部位于 level 3：其中一些位于 level 1 而另一些位于 level 4，覆盖了所有中间的层次。\n\n**新的背景样式特性**\n现在可以使用 box-shadow 给逻辑框设置一个阴影，而且还可以设置 多背景。\n**更精美的边框**\n现在不仅可以使用图像来格式化边框，使用 border-image 和它关联的普通属性，而且可以通过 border-radius 属性来支持圆角边框。\n**为你的样式设置动画**\n使用 CSS Transitions 以在不同的状态间设置动画，或者使用 CSS Animations 在页面的某些部分设置动画而不需要一个触发事件，你现在可以在页面中控制移动元素了。\n**排版方面的改进**\n作者们如今有更强大的能力来使自己的网页文字达到更佳的排版。他们不但可以控制 text-overflow 和 hyphenation， 还可以给它设置一个 阴影 或者更精细地控制它的 decorations。感谢新的 @font-face 规则，现在我们可以下载并应用自定义的字体了。\n**新的展示性布局**\n为了提高设计的灵活性，已经有两种新的布局被添加了进来：CSS 多栏布局, 以及 CSS 灵活方框布局。\n\n## 8.3D, 图像 & 效果 ##\n\n\t1. Canvas 教程 了解有关新的 <canvas> 元素以及如何在火狐中绘制图像和其他对象。\n\t2. HTML5 针对 <canvas> 元素的文本 API\n\tHTML5 文本 API 现在由 <canvas> 元素支持。\n\t3. WebGL\n\tWebGL 通过引入了一套非常地符合 OpenGL ES 2.0 并且可以用在 HTML5 <canvas> 元素中的 API 给 Web 带来了 3D 图像功能。\n\t4. SVG\n\t一个基于 XML 的可以直接嵌入到 HTML 中的矢量图像格式。\n\n## End.借鉴网址 ##\n[火狐html5](https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5)","tags":["技术介绍"]},{"title":"Vue","url":"/2019/12/16/Vue/","content":"![vue.png](http://ww1.sinaimg.cn/large/007SCiiVgy1gbb9zebfg2j30b40b4dfn.jpg)\n\n### 1.待更新","tags":["技术介绍"]},{"title":"UML学习","url":"/2019/11/25/UML学习/","content":"![uml.png](http://ww1.sinaimg.cn/large/007SCiiVgy1gbb9xbqj2mj30jq0jraaj.jpg)\n\n<!--more-->\n\n### 1.简介 ###\n\n统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML使用面向对象设计的的建模工具，但独立于任何具体程序设计语言。\n### 2.项目实际操作 ###\n1. 整体设计\t\n2. 概要设计\t\n2.1. “首页商品的特定显示”模块概要设计\t\n2.1.1. 功能描述\t\n2.1.2. 用例图\t\n2.1.3. 界面原型\t\n3. 详细设计\t\n 3.  “首页商品的特定显示”模块设计\t\n 3.  流程图\n 3.  类图\t\n 3.  时序图\t\n 3.  模块方法\t\n 3.  数据库设计\t\n### 3.实际UML学习 ###\n## 1.时序图 ##\n   ![时序图.jpg](http://ww1.sinaimg.cn/large/007SCiiVgy1g9aiuhqe0bj30pd0z04cz.jpg)\n\n-- \n\n## 2. 用例图 ##\n![用例图.jpg](http://ww1.sinaimg.cn/large/007SCiiVgy1g9aix2zxbsj30u01i8tfb.jpg)\n-- \n\n## 3. 类图 ##\n![类图.png](http://ww1.sinaimg.cn/large/007SCiiVgy1g9aitr448wj30nz1xq4qp.jpg)\n--\n## 4. 流程图 ##\n[Edraw](http://www.edrawsoft.cn/what-is-flowchart/)","tags":["技术点讲解"]},{"title":"vue的学习报错","url":"/2019/11/10/vue的学习报错/"},{"title":"springMVC错误","url":"/2019/11/04/springMvc错误/","content":"### 1.程序环境 ###\nSpring \nSpringMVC\nMyBatise\njdk 1.8 \nTomcat 7.0\n\n### 2.错误现象 ###\n1. 后台并没有报任何错误！就是进入不了整个动态Web项目页面。\n2. 导致整个的Controller层，没有响应。\n### 3.错误导致原因 ###\n1. 因为业务所需，我在PC端的indexController 新增一个模块服务。\n2. @Autowired （xxxSerice）\n3. 但是这个xxxService的实现类并没有写注解@Service（我给忘了！！！） \n### 4.解决方法 ###\n1. 添加注解@Service\n2. 完美！！","tags":["错误笔记"]},{"title":"MultipartFile","url":"/2019/10/22/MultipartFile/","content":"![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572336684&di=508f5780d849981c25a837714431089e&imgtype=jpg&er=1&src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F166%2F3e7f81e416235133bd7619b155ec962e.png)\n### MultipartFile类（Spring框架） ###\n> 起源 ： 在学习一个商城的web应用时，发现UpdateFile的控制器内部使用的就是这个技术类。\n\n\n### 1. 配置文件 ###\n\nSpringMVC 用的是 的MultipartFile来进行文件上传 所以我们首先要配置MultipartResolver用于处理表单中的file\n\n\t\t<!-- 配置MultipartResolver 用于文件上传 使用spring的CommosMultipartResolver -->\n\t\t  <beans:bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\n\t\t    p:defaultEncoding=\"UTF-8\"\n\t\t    p:maxUploadSize=\"5400000\"\n\t\t    p:uploadTempDir=\"fileUpload/temp\"\n\t\t   > \n\t\t</beans:bean> \n其中属性详解：\ndefaultEncoding=\"UTF-8\" 是请求的编码格式，默认为iso-8859-1\nmaxUploadSize=\"5400000\" 是上传文件的大小，单位为字节\nuploadTempDir=\"fileUpload/temp\" 为上传文件的临时路径\n\n### 2. 案例 ###\n\t\t\n\t\t<body> \n\t\t<h2>文件上传实例</h2> \n\t\t  \n\t\t<form action=\"fileUpload.html\" method=\"post\" enctype=\"multipart/form-data\"> \n\t\t  选择文件:<input type=\"file\" name=\"file\"> \n\t\t  <input type=\"submit\" value=\"提交\">  \n\t\t</form> \n\t\t  \n\t\t</body> \n \n注意要在form标签中加上enctype=\"multipart/form-data\"表示该表单是要处理文件的,这是最基本的东西，很多人会忘记然而当上传出错后则去找程序的错误，却忘了这一点。\n\n### 3. 编写上传控制类 ###\n\n1. 创建一个控制类: FileUploadController和一个返回结果的页面list.jsp\n2. 编写提交表单的action\n\n\t\t//通过Spring的autowired注解获取spring默认配置的request \n\t\t  @Autowired\n\t\t  private HttpServletRequest request; \n\t\t  \n\t\t  /*** \n\t\t   * 上传文件 用@RequestParam注解来指定表单上的file为MultipartFile \n\t\t   * \n\t\t   * @param file \n\t\t   * @return \n\t\t   */\n\t\t  @RequestMapping(\"fileUpload\") \n\t\t  public String fileUpload(@RequestParam(\"file\") MultipartFile file) { \n\t\t    // 判断文件是否为空 \n\t\t    if (!file.isEmpty()) { \n\t\t      try { \n\t\t        // 文件保存路径 \n\t\t        String filePath = request.getSession().getServletContext().getRealPath(\"/\") + \"upload/\"\n\t\t            + file.getOriginalFilename(); \n\t\t        // 转存文件 \n\t\t        file.transferTo(new File(filePath)); \n\t\t      } catch (Exception e) { \n\t\t        e.printStackTrace(); \n\t\t      } \n\t\t    } \n\t\t    // 重定向 \n\t\t    return \"redirect:/list.html\"; \n\t\t  } \n\t\t  \n\t\t  /*** \n\t\t   * 读取上传文件中得所有文件并返回 \n\t\t   * \n\t\t   * @return \n\t\t   */\n\t\t  @RequestMapping(\"list\") \n\t\t  public ModelAndView list() { \n\t\t    String filePath = request.getSession().getServletContext().getRealPath(\"/\") + \"upload/\"; \n\t\t    ModelAndView mav = new ModelAndView(\"list\"); \n\t\t    File uploadDest = new File(filePath); \n\t\t    String[] fileNames = uploadDest.list(); \n\t\t    for (int i = 0; i < fileNames.length; i++) { \n\t\t      //打印出文件名 \n\t\t      System.out.println(fileNames[i]); \n\t\t    } \n\t\t    return mav; \n\t\t  } \n3. 使用SpringMVC注解RequestParam来指定表单中的file参数；\n4. 指定一个用于保存文件的web项目路径\n5. 通过MultipartFile的transferTo(File dest)这个方法来转存文件到指定的路径。\n\n到此基本的文件上传就结束了。\n\t\t\n\t\tMultipartFile类常用的一些方法：\n\t\t\n\t\tString getContentType()//获取文件MIME类型\n\t\tInputStream getInputStream()//后去文件流\n\t\tString getName() //获取表单中文件组件的名字\n\t\tString getOriginalFilename() //获取上传文件的原名\n\t\tlong getSize() //获取文件的字节大小，单位byte\n\t\tboolean isEmpty() //是否为空\n\t\tvoid transferTo(File dest) //保存到一个目标文件中。\n\n### 4. 多文件上传###\n\n多文件上传其实很简单，和上传其他相同的参数如checkbox一样，表单中使用相同的名称，然后action中将MultipartFile参数类定义为数组就可以。\n接下来实现：\n\n1. 创建一个上传多文件的表单：\n\t\t\n\t\t<body> \n\t\t  <h2>上传多个文件 实例</h2> \n\t\t  <form action=\"filesUpload.html\" method=\"post\"\n\t\t    enctype=\"multipart/form-data\"> \n\t\t    <p> \n\t\t      选择文件:<input type=\"file\" name=\"files\"> \n\t\t    <p> \n\t\t      选择文件:<input type=\"file\" name=\"files\"> \n\t\t    <p> \n\t\t      选择文件:<input type=\"file\" name=\"files\"> \n\t\t    <p> \n\t\t      <input type=\"submit\" value=\"提交\"> \n\t\t  </form> \n\t\t</body> \n2. 编写处理表单的action，将原来保存文件的方法单独写一个方法出来方便共用：\n\n\t\t/*** \n\t\t   * 保存文件 \n\t\t   * @param file \n\t\t   * @return \n\t\t   */\n\t\t  private boolean saveFile(MultipartFile file) { \n\t\t    // 判断文件是否为空 \n\t\t    if (!file.isEmpty()) { \n\t\t      try { \n\t\t        // 文件保存路径 \n\t\t        String filePath = request.getSession().getServletContext().getRealPath(\"/\") + \"upload/\"\n\t\t            + file.getOriginalFilename(); \n\t\t        // 转存文件 \n\t\t        file.transferTo(new File(filePath)); \n\t\t        return true; \n\t\t      } catch (Exception e) { \n\t\t        e.printStackTrace(); \n\t\t      } \n\t\t    } \n\t\t    return false; \n\t\t  } \n3. 编写action: \n\t\t  @RequestMapping(\"filesUpload\") \n\t\t  public String filesUpload(@RequestParam(\"files\") MultipartFile[] files) { \n\t\t    //判断file数组不能为空并且长度大于0 \n\t\t    if(files!=null&&files.length>0){ \n\t\t      //循环获取file数组中得文件 \n\t\t      for(int i = 0;i<files.length;i++){ \n\t\t        MultipartFile file = files[i]; \n\t\t        //保存文件 \n\t\t        saveFile(file); \n\t\t      } \n\t\t    } \n\t\t    // 重定向 \n\t\t    return \"redirect:/list.html\"; \n\t\t  }\n### 5. 原作者 ###\n\n[https://www.jianshu.com/p/9ee4cb347d91](https://www.jianshu.com/p/9ee4cb347d91)","tags":["技术学习"]},{"title":"Python学习","url":"/2019/10/05/Python学习/","content":"1. 开胃菜python简介\n\t\t\n        Python 是一种易于学习又功能强大的编程语言。它提供了高效的高级数据结构，还有简单有效的面向对\n        象编程。Python 优雅的语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。\n\t    \n\t    Python 解释器及丰富的标准库以源码或机器码的形式提供，可以到 Python 官网 https://\n        www.python.org/ 免费获取适用于各个主要系统平台的版本，并可自由地分发。这个网站还包含许多免费第三方 Python 模块、程序和工具以及附加文档的发布页面或链接。\n\t    \n\t    Python 解释器易于扩展，可以使用 C 或 C++（或者其他可以通过 C 调用的语言）扩展新的功能和数据\n        类型。Python 也可用于可定制化软件中的扩展程序语言。\n\t    \n\t    这个教程非正式地介绍 Python 语言和系统的基本概念和功能。最好在阅读的时候准备一个 Python 解\n\t    释器进行练习，不过所有的例子都是相互独立的，所以这个教程也可以离线阅读。\n\t    \n\t    有关标准的对象和模块，参阅 Python 标准库。Python 语言参考 提供了更正式的语言参考。想要编写 \n\t    C 或者 C++ 扩展可以参考 扩展和嵌入 Python 解释器 和 Python/C API 参考手册。也有不少书籍深入讲解Python 。\n\n1. Python环境大礼包安装（anacond 大蟒蛇）\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1570271320744&di=e361d62c365751315a3a7fdc72465311&imgtype=0&src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-2aa01d018e440c39c0c29e7e148fc5ae_1200x500.jpg)\n\t\t\n        这是比较简单的python环境安装的方式，当然可以自己去\n        python官网下载核心文件，然后再自己配置电脑的环境。\n\n2. 环境测试\n\n3. 编辑工具和平台","tags":["技术介绍"]},{"title":"云计算介绍","url":"/2019/09/27/云计算介绍/","content":"## 1.简单介绍 ##\n![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=dd611ad65cda81cb5aeb8b9f330fbb73/d6ca7bcb0a46f21fce06ac71fb246b600c33aee6.jpg)\n--\n   \n- 云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒种）完成对数以万计的数据的处理，从而达到强大的网络服务。  \n\n-  现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果\n\n## 2.具体学习方向 ##\n \n\n- AWS考证（或者阿里云、华为云）\n- 油管AWS视频\n ","tags":["技术学习方向"]},{"title":"石英调度","url":"/2019/09/06/石英调度/"},{"title":"mybatis报错java.lang.UnsupportedOperationException原因及处理方法","url":"/2019/09/02/mybatis报错/","content":"\n1. 起因\n\n今天在请求数据库数据时报错java.lang.UnsupportedOperationException，从字面上理解错误的含义就是不支持的操作异常，后面定位到错误发生在数据库sql语句中，具体原因就是resultType=\"java.util.List\"有问题。返回的结果是一个List类型的集合，所有我用了这个resultType，但是不对的。需要使用string。\n\n---\n\n2. 解释\n\n下面是我百度出来，别人总结的resultType可用类型 \n\n\t\tresultType: \n\t\t1. 基本类型 ：resultType=基本类型 \n\t\t2. List类型： resultType=List中元素的类型 \n\t\t3. Map类型 单条记录：resultType =map \n多条记录：resultType =Map中value的类型 \n\n\t1. 如果返回值为基本类型，则resultType=基本类型，比如resultType=java.lang.Integer,\n\t那sql语句中只返回一个int类型数据，通常用于统计数量 \n\t2. 如果返回值为list类型，则resultType=List中元素的类型，比如你需要返回一个List类型的数据，那么这里\n\tresultType=”java.lang.String”，如果需要返回一个实体类，那么resultType=”com.pjf.mybatis.car”以此类推。 \n\t3. 如果返回值为map单条类型，比如{username=”张三”}，那么resultType =”map”。 \n\t4. 如果返回值为map多条记录，比如{res=”实体类”}，实体类就是你要请求的数据实体类，\n\t那么resultType =Map中value的类型，比如resultType=”com.pjf.mybatis.car”\n\n返回多条记录的map时，key为任意一属性，值为对象类型，不过key需要通过@MapKey(“hotelName”)指定对象中一个属性名为key\n\n\t\tpublic interface HotelMapper {\n\t\t    @MapKey(\"hotelName\")\n\t\t    public Map<String, Hotel> getHotel(Integer i);\n\t\t}\n \n\n所以错误java.lang.UnsupportedOperationException主要是因为xml返回值类型有问题导致的，当然可能也有其他原因造成的。\n","tags":["mybatis报错"]},{"title":"Maven项目关键点","url":"/2019/08/16/Maven项目关键点/","content":"### 1.Maven打包 install ###\n\n1. 因为使用ssm架构，所有存在java类文件下放Mapping的xml文件，但是maven 打包时是不会解析xml文件的，因为只是解析java文件成为class文件，所有测试路径时报错。\n2. 解决方法，添加插件\n\n\t\t\t <plugin>\n\t\t\t    <artifactId>maven-resources-plugin</artifactId>\n\t\t\t    <version>3.0.2</version>\n\t\t\t    <executions>\n\t\t\t        <execution>\n\t\t\t            <id>copy-xmls</id>\n\t\t\t            <phase>process-sources</phase>\n\t\t\t            <goals>\n\t\t\t                <goal>copy-resources</goal>\n\t\t\t            </goals>\n\t\t\t            <configuration>\n\t\t\t                <outputDirectory>${basedir}/target/classes</outputDirectory>\n\t\t\t                <resources>\n\t\t\t                    <resource>\n\t\t\t                        <directory>${basedir}/src/main/java</directory>\n\t\t\t                        <includes>\n\t\t\t                            <include>**/*.xml</include>\n\t\t\t                        </includes>\n\t\t\t                    </resource>\n\t\t\t                </resources>\n\t\t\t            </configuration>\n\t\t\t        </execution>\n\t\t\t    </executions>\n\t\t\t</plugin>\n\t\t\t\n\n### 2.Maven项目myBatis的mapper.xml 项目找不到###\t\t\n\n1.\teclipse下一切配置多按照视频所操作，可是项目运行到tomcat上时就是找不到mapper的xml文件！\n2.\t解决方法 更改路径\n\t    \n      \n        之前：com/sdfadf/mapper/**.xml\n        更改：com/sdfadf/**/**.xml这个包没有在 source package下\n    \n\n  ","tags":["Maven项目"]},{"title":"ssm简易整合记录","url":"/2019/08/06/ssm简易整合记录/","content":"### 1.环境搭建 ###\n1. 因为Sprin框架3.2jar版本没有和jdk1.8完全搭配，会有bug，所以采用jdk1.8加spring4.0.\n2. eclipse——web版本为3.0\n3. tomcat版本为8.5\n### 2.如何在eclipse工程下建立资源文件夹 ###\n","tags":["整合技术"]},{"title":"SpringMVC学习","url":"/2019/08/06/SpringMVC学习/","content":"### 1.介绍 ###\n>\n\t\t\n \n\tSpring MVC是Spring提供的一个强大而灵活的web框架。`借助于注解`，Spring MVC提供了几乎是POJO的开发\n    模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中 \n    的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。\n    \n    Spring MVC是Spring家族中应用于Web应用的一个模块，是Spring提供的一个基于MVC设计模式的Web开发框\n\t架，可以将它理解为Servlet。在MVC模式中，Spring MVC作为控制器（Controller）来建立模型与视图的数\n\t据交互，是结构最清晰的JSP Model2实现，可以说是一个典型的MVC框架。\n\n\t除此之外，Spring MVC框架采用松耦合、可插拔的组件结构，具有高度可配置性，比起其他的MVC框架更具有\n    扩展性和灵活性。并且它本身就是Spring家族的一部分，与Spring框架整合更是天衣无缝。\n\n\t在Spring MVC框架中，Controller替换Servlet来担负控制器的职责。Controller接收请求，调用相应的\n\tModel进行处理，Model处理完之后将结果返回给Controller，Controller再指派相应的View对处理结果进\n\t行渲染，最终响应给客户端进行展示。\n \n---\n### 2.重要组成部分 ###\n\n    Spring MVC主要由DispatcherServlet、处理器映射HandlerMapping【找那个控制器】映射有具有多种方式、\n    适配器【使用和调用控制器的方法】、控制器【业务】、Views视图解析器、视图组成。\n\n--- \n### 3.快速入门配置 ###\n1. web.xml 配置 DispatcherServlet\n\n\t    <servlet>\n\t    <servlet-name>DispatcherServlet</servlet-name>\n\t    <servlet-class>\n\t          org.springframework.web.servlet.DispatcherServlet\n        </servlet-class>\n\t    <load-on-startup>1</load-on-startup>\n\t    </servlet>\n\t    \n\t    <servlet-mapping>\n\t    <servlet-name>DispatcherServlet</servlet-name>\n\t    <url-pattern>*.do</url-pattern>\n\t    </servlet-mapping>\n2. 在WEB-INF目录下创建DispatcherServlet-servlet.xml\n\t    \n\t\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n         <beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\t\txmlns:context=\"http://www.springframework.org/schema/context\"\n\t\txmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\t\t\thttp://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n\t\t\thttp://www.springframework.org/schema/mvc \n\t\t\thttp://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n\t\t\thttp://www.springframework.org/schema/context \n\t\t\thttp://www.springframework.org/schema/context/spring-context-3.2.xsd \n\t\t\thttp://www.springframework.org/schema/aop \n\t\t\thttp://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n\t\t\thttp://www.springframework.org/schema/tx \n\t\t\thttp://www.springframework.org/schema/tx/spring-tx-3.2.xsd\">\n\t\t\t\n\t</beans>\n       \n3. 配置DispatcherServlet-servlet.xml\n   \n\t\t<!-- 1. 配置处理器映射，springmvc默认的处理器映射器\n\t\t\t BeanNameUrlHandlerMapping:根据bean的name属性的url去找handlerController -->\n\t\t<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\n\t\t<!-- 2. 配置处理器适配置器执行Controller -->\n\t\t<bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n\t\t<!-- 3.配置一个控制器 -->\n\t\t<bean name=\"/user.do\" class=\"com.gyf.backoffice.web.controller.UserController\"/>\n\t\t<!-- 4.配置springmvc视图解析器\n\t\t\t视图解析器解析的视频路径为：前缀 + 后缀 -->\n\t\t<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t\t<property name=\"prefix\" value=\"/WEB-INF/views\"/>\n\t\t\t<property name=\"suffix\" value=\".jsp\"/>\n\t\t</bean>\n4. 应用流程\n    \n        springMVC的流程如下： \n\t\t1.前端控制器DispatchServlet接受客户端浏览器发送的请求 \n\t\t2.前端控制器DispatchServlet调用处理器映射器HandlerMapping查找相应的处理器 \n\t\t3.处理器映射器根据URL查找处理器Handler，并给前端控制器返回生成的处理器和相应的处理器拦截器HandlerIntercepter \n\t\t4.前端控制器调用处理器适配器HandlerAdapter \n\t\t5.处理器适配器调用相应的处理器 \n\t\t6.处理器给处理器适配器返回ModelAndView(包含逻辑视图名) \n\t\t7.处理器将ModelAndView返回给前端控制器 \n\t\t8.前端控制器将ModelAndView传给视图解析器ViewResolver \n\t\t9.视图解析器ViewResolver解析后将具体的视图View返回给前端控制器 \n\t\t10.前端控制器对视图进行渲染（视图渲染：将模型数据（在ModelAndView中）填充到request域中） \n\t\t11.前端控制器将视图返回给客户端浏览器\n \n![SpringMVC架构图](http://ww1.sinaimg.cn/large/007SCiiVly1g5wxvlml4zj30x70ib43w.jpg)\n\n---\n### 4.处理器映射 ###\n   \n1. **非注解的处理器**\n2. BeanNameUrlHandlerMapping，这个类的映射规则是将 bean 的 name 作为 url 进行查找，需要在配置 Handler 时指定 beanname，其示例代码如下：\n       \n         这时的 url 地址就会根据 bean 的 name 去查找，也就是示例中配置的 name 的值 test.do，且这个必须以 / 开头。\n        <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\">\n\t\t <bean name=\"/test.do\" class=\"com.fageweiketang.controller.TestController\"/>\n\n  \n\n3. SimpleUrlHandlerMapping，它可以通过内部参数去配置请求的 url 和 handler 之间的映射关系，其示例配置如下：\n\n\t\t<bean id=\"urlMapping\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n\t\t    <property name=\"interceptors\">\n\t\t        <list>\n\t\t            <ref bean=\"someCheckInterceptor1\"/>\n\t\t            <ref bean=\"someCheckInterceptor2\"/>\n\t\t        </list>\n\t\t    </property>\n\t\t    <property name=\"mapping\">\n\t\t        <props>\n\t\t            <prop key=\"user.action\">userController</prop>\n\t\t            <prop key=\"product.action\">productController</prop>\n\t\t            <prop key=\"other.action\">otherController</prop>\n\t\t        </props>            \n\t\t    </property>\n\t\t</bean>其中 property 属性可以配置 interceptors 拦截器，也可以配置 mapping（Handler 处理器和 url 的映射关系）。\n\n\n\n\n\n4. ControllerClassNameHandlerMapping，它是将 Controller 控制器的名字作为映射的 url 地址，例如 TestController 控制器则映射的地址就为 / test*，如果是 test 控制器下的 test 方法，则 url 为 test/test.action，示例代码如下：\n\n\t\t<bean class=\"org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping\"/>\n \n\n----------\n\n1. **注解适配的处理器**（开发常用这种）\n\n2. 注解处理方式不需要在 xml 中进行配置，只需要在指定的地方声明一些注解信息即可。SpringMVC3.1 版本之后默认的处理器映射器是 RequestMappingHandlerMapping，位于 SpringMVC 的核心 jar 包 org.springframework.web.servlet.mvc.method.annotation 中。\n\n3. 注解配置方式有两种.\n\n  1. 第一种是在 springmvc.xml 中配置，声明相关的 bean 和实现即可，示例代码如下：\n\n                 <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\n \n \n  2. 第二种是使用 <mvc:annotation-driven/> 标签来配置，这个标签是一种简写方式，它会自动去注册处理器映射器，配置示例如下：\n           \n             <mvc:annotation-driven></mvc:annotation-driven>\n\n\n \n\t\t\t\n4. 使用Controller来标识它是一个控制器\n           \n        @Controller\n\t\t\tpublic class TestControllerTest{\n\t\t\t    @RequestMapping(\"/testurl\")\n\t\t\t    public ModelAndView testurl() throws Exception{\n\t\t\t        //逻辑代码\n\t\t\t    }\n\t\t\t}\n\n\t\t\t在以上代码中 @Controller 是注解信息，表示该类是一个控制器类，可以被注解的处理器适配器找\n            到，而 TestControllerTest 类中的 testurl 方法上有一个 @RequestMapping 注解信息，作用是指定一个 url 与该方法绑定。\n\n        \n\n\n5. 这时为了让注解的处理器映射器能找到 Handler 控制器，需要在 springmvc.xml 做下配置，\n方式有两种：\n\n   - 在 springmcv.xml 中声明 bean 信息，示例代码如下：\n\n          \t<bean class=\"com.fageweiketang.controller.TestController\"></bean>\n\t\n\n   - 第二种是扫描配置，对某一个包下的所有类进行扫描，找出所有使用 @Controller 注解的 Handler 控制器类，示例代码如下：\n\n        \t<context:component-scan base-package=\"com.fageweiketang.controller\"></context:component-scan>\n\n\n\n---\n### 5.案例图示 注解下开发###\n\n\n- **配置xml。**\n        \n        <!-- 1.配置注解扫描位置 -->\n\t\t<context:component-scan base-package=\"com.gyf.backoffice.web.controller\"/>\n\t\t\t\t\n\t\t<!-- 2. 配置处理器映射，通过注解来查找 -->\n\t\t<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\n\t\t<!-- 3.配置注解处理适配器来执行控制器的方法 -->\t\n\t\t<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\n\t\t\t\t\n\t\t<!-- 配置springmvc视图解析器\n\t\t\t\t\t视图解析器解析的视频路径为：前缀 + 后缀 -->\n\t\t<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t\t<property name=\"prefix\" value=\"/WEB-INF/views\"/>\n\t\t\t<property name=\"suffix\" value=\".jsp\"/>\n\t\t</bean>\n-\n- **配置控制器 返回指定网页。**\n \n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5xav0fqjbj30ha059aa3.jpg)\n-\n\n- **优化mvc配置文件**\n\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5xaxkztw1j30w708ymxp.jpg)\n\n- **RequestMapping讲解**\n\n ![](http://ww1.sinaimg.cn/large/007SCiiVly1g5xb1az5o9j30jj0io0vj.jpg)\n\n- **有关于参数传递的问题 回看教案。**\n\n-  **转发和重定**\n\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5xbaoc1k9j30eo0hmq3k.jpg)\n\n- **RequestParam**\n\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5xbdymyuuj30j50c1abk.jpg)\n\n- **ResponseBody和RequestBody**\n\t \n    \t@ResponseBody把后台pojo转换json对象，返回到页面。\n\t\t@RequestBody接受前台json数据，把json数据自动封装javaBean\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5xbg6rxcwj30j40510tk.jpg)\n-\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5xbimndimj30iw042aa1.jpg)\n\n### 6.Springmvc多视图 ###\n1. 配置xml\n   \n\t     <bean\n\t\t\tclass=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\">\n\t\t\t<!-- 配置支持媒体类型 -->\n\t\t\t<property name=\"contentNegotiationManager\">\n\t\t\t\t<bean\n\t\t\t\t\tclass=\"org.springframework.web.accept.ContentNegotiationManagerFactoryBean\">\n\t\t\t\t\t<property name=\"mediaTypes\">\n\t\t\t\t\t\t<map>\n\t\t\t\t\t\t\t<entry key=\"json\" value=\"application/json\"></entry>\n\t\t\t\t\t\t\t<entry key=\"xml\" value=\"application/xml\"></entry>\n\t\t\t\t\t\t</map>\n\t\t\t\t\t</property>\n\t\t\t\t</bean>\n\t\t\t</property>\n\t\n\t\t\t<!-- 指定默认视图 -->\n\t\t\t<property name=\"defaultViews\">\n\t\t\t\t<!-- 支持多个视图 -->\n\t\t\t\t<list>\n\t\t\t\t\t<!-- 对josn格式视图支持 -->\n\t\t\t\t\t<bean class=\"org.springframework.web.servlet.view.json.MappingJacksonJsonView\"/>\n\t\n\t\t\t\t\t<!-- xml格式视图支持 -->\n\t\t\t\t\t<bean class=\"org.springframework.web.servlet.view.xml.MarshallingView\">\n\t\t\t\t\t\t<constructor-arg>\n\t\t\t\t\t\t\t<bean class=\"org.springframework.oxm.jaxb.Jaxb2Marshaller\">\n\t\t\t\t\t\t\t\t<property name=\"classesToBeBound\">\n\t\t\t\t\t\t\t\t\t<list>\n\t\t\t\t\t\t\t\t\t\t<value>com.gyf.backoffice.domain.Student</value>\n\t\t\t\t\t\t\t\t\t</list>\n\t\t\t\t\t\t\t\t</property>\n\t\t\t\t\t\t\t</bean>\n\t\t\t\t\t\t</constructor-arg>\n\t\t\t\t\t</bean>\n\t\t\t\t</list>\n\t\t\t</property>\n\t\t</bean>\n\n\n2. 控制器提供一个接口\n \n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5xbmbh0vzj30je05jt9a.jpg)\n\n---\n\n### 未完结！ ###","tags":["学习笔记"]},{"title":"Tomcat的坑或者eclipse的坑","url":"/2019/08/03/Tomcat的坑或者eclipse的坑/","content":"### 1.错误展示 ###\n\n>![](http://ww1.sinaimg.cn/large/007SCiiVly1g5mpne6ofnj30wx04udg8.jpg)\n\n-- \n\n### 2.错误的指向 ###\n>\n>1.![](http://ww1.sinaimg.cn/large/007SCiiVly1g5mppp5au7j30ps03u3yg.jpg)\n>2.![](http://ww1.sinaimg.cn/large/007SCiiVly1g5mpoqcpo6j30v6076t9l.jpg)\n>3.![](http://ww1.sinaimg.cn/large/007SCiiVly1g5mpq10nkkj30uy05ldgj.jpg)\n>4.![](http://ww1.sinaimg.cn/large/007SCiiVly1g5mpqpgwo8j30ty07iwf5.jpg)\n>5.![](http://ww1.sinaimg.cn/large/007SCiiVly1g5mpqxhecqj30td03xq2v.jpg)\n\n-- \n\n\n### 4.错误的解决  ###\n1. 首先检查下eclipse是否设置了Project自动编译了：eclipse—》Project —》Build Automatically，该选项必选打勾，如果没有打勾则打勾后就行。如图：\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5os1eee8xj30lh0a3dgl.jpg)\n2. 注意这里有工程也有全局的，必须两个都设置对了才可以编译。\n\n    如图：\n\n    具体工程的设置，右键工程-》Properties—》Java Compiler—》Building\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5os53s5clj30s60m8wnf.jpg)\n3. 全局的设置：eclipse—》Preferences—》Java Compiler—》Building\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5os6dwsdgj30r10mcn6p.jpg)\n\n4. 以上操作完后，如果还不行，可以清理下，让eclipse重新编译下：eclipse—》Project—》clean   就可以生成.class文件\n\n-- \n\n### 5.错误的起因 ###\n  \n\n    最近在项目开发过程中遇到eclipse不能自动编译生成class文件，当时很纳闷，每次修改代码后运行都是修改  \n    前的效果，没辙了，只好反编译原来的class文件，结果发现，class文件里并没有看到修改好的代码，所以应\n    该就是修改后的代码没有重新编译的结果吧。\n \n--    \n    目前来看，应该是eclipse或者Tomcat的bug，并没有良好的应对实际项目时操作的因素。导致我们开发过程\n    中找不到类文件,虽然我们的Tomcat的重新运行一次两次，还是没有解决真正的问题，我们项目新添加一个\n    java类时，而这两者好像并没有达成共识，将我写的类，同时也加载到tomcat的运行文件下！导致项目跑着tomcat上时找不到类!","tags":["web项目运行错误"]},{"title":"MyBatise学习笔记","url":"/2019/07/29/MyBatise学习笔记/","content":"# MyBatise #\n### 1.介绍 ###\n### 2.学习问题 ###","tags":["学习笔记"]},{"title":"荒唐","url":"/2019/07/26/荒唐/","content":"\n\n\n<div style=\"text-align: center;\">\n\n<img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564164004295&di=8f89cb163c3f9b325d7cb5c24442e96f&imgtype=0&src=http%3A%2F%2Fpic.qqtn.com%2Ffile%2F2013%2F2015-4%2F2015042808453014392.jpg\">\n\n<p>听过的流行歌一样\n<p>起初循环 再者沉底 \n<p>白狐老道  \n喜欢\n<p>翻页不停的故事书\n<p>像极了 \n<p>翻云覆雨的天气\n<p>不惊讶夏天里的蝉鸣\n<p>和一片蛙声\n<p>慌忙于\n<p>手脚两边\n<p>奋力于你爱的颜色\n</div>\n","tags":["诗歌"]},{"title":"webService wsdl2java运行错误！","url":"/2019/07/26/webService-wsdl2java运行错误！/","content":"### 1.错误展示 ###\n>\n1. ![cxf环境配置错误](http://ww1.sinaimg.cn/large/007SCiiVly1g5dmf9ebsij30en08474t.jpg)\n2. ![java环境配置影响或者其他情况](http://ww1.sinaimg.cn/large/007SCiiVly1g5dmfl5s08j30iw03o0tf.jpg)\n\n\n\n---\n### 2.问题分析过程 ###\n>\n-  当我cxf的环境配置没问题时，再输入wsdl2java -v cmd提示系统找不到路径！这时我是很蒙蔽的！而且一直多以为是cxf的配置问题，一度让我重新下了一个比较新版本的cxf，结果可想而知，还是不行！搞了几个小时，心态也崩了，就干脆算了！\n-  呃呃呃，晚上我出去跑步回来，洗完澡，准备接着往前学习，倔强的我又作死的想把这个问题解决了，又是一波网上查找！还是一无所获！\n-  我最后实在没有办法就，灵光一现，我感觉java_home有问题，我之前一直以为java和cxf的环境配置应该没半毛钱关系啊！可是故事就是异常的凄凉！\n\n\n\n---\n### 3.解决办法 ###\n---\n>  `删除电脑的用户变量！对应的JAVA_HOME!然后运行成功，苍天那！你何苦为难小生那！`\n1. ![](http://ww1.sinaimg.cn/large/007SCiiVly1g5dmecmtzdj30kk0qdk0d.jpg)\n2. ![](http://ww1.sinaimg.cn/large/007SCiiVly1g5dmgsi77bj30cy03xq33.jpg)\n","tags":["环境配置"]},{"title":"WebService 学习笔记","url":"/2019/07/25/WebService-学习笔记/","content":"![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564653557&di=72ecca34df371fc685b2e15933d16711&imgtype=jpg&er=1&src=http%3A%2F%2Fupload.nxing.cn%2Fuploads%2Fuploads%2F2017%2F02%2F26%2F0000027%2F201702260908002721bf4af-size853x486.png)\n### 1.介绍 ###\n- Web service 即web服务，它是一种跨编程语言和跨操作系统平台的远程调用技术即跨平台远程调用技术。 \n- Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。 \n- Web Service为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。\n\n---\n### 2.个人见解 ###\n-  对于我这几天的学习来看，这个技术就是企业之间的公共服务。偏向于技术人员，当然能解决了技术人员的数据整理问题，使得我们能够快速获取正确及时的数据服务。\n\n---\n### 3.技术特殊点 ###\n1. **WebService数据传输的方式**\n  1. SOAP:http+xml\n  2. Http rest :一套用来创建Web Service的方法,REST式的Web Service使用HTTP里的方法：GET，POST，DELETE， PUT\n\n2. **WebService 三要素**\n   1. soap\n    SOAP即简单对象访问协议(Simple Object Access Protocal) 是一种简单的基于 XML 的协议，它使应用程序通过 HTTP 来交换信息.\n    简单理解为soap=http+xml,就是通过HTTP发xml数据\n    Soap协议版本主要使用`soap1.1、soap1.2`。\n   2. Wsdl\n    WSDL 是基于 XML 的用于描述Web Service及其函数、参数和返回值。通俗理解Wsdl是webservice的使用说明书 \n\n   3. Uddi【了解】\n\tUDDI 是一种目录服务，通过它，企业可注册并搜索 Web services。企业将自己提供的Web Service注册在UDDI，也可以使用别的企业在UDDI注册的web service服务，从而达到资源共享。\t\n\tUDDI旨在将全球的webservcie资源进行共享，促进全球经济合作。\n\t目前大部分企业使用webservice并不是必须使用UDDI，因为用户通过WSDL知道了web service的地址，可以直接通过WSDL调用webservice \n\n### 4.实际服务快速入门 ###\n1. 进入webService服务网址，查找所需服务 \n2. ` http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl`\n3. 利用wsdl2java 或者 wsimport进行客户端代码生成和解析。\n4. 根据服务说明书理清具体代码功能。\n5. 利用所给方法进行数据传递。\n\n### 5.3 Webservice 开发规范 ###\nJAVA 中共有三种 实现WebService 开发规范 `JAX-WS（JAX-RPC）、JAXM & SAAJ、JAX-RS`\n\n>**使用JAX-WS**\n\n\tJAX-WS  的全称为 Java API for XML-Based Webservices ，早期的基于SOAP 的JAVA 的Web 服务规范\n    JAX-RPC（Java API For XML-Remote Procedure Call）目前已经被JAX-WS 规范取代。\n\t从jdk1.5开始支持JAX-WS2.0版本，\n\tJdk1.6.0_13以后的版本支持2.1版本，\n\tjdk1.7支持2.2版本。\n\t也就是说java提供了一个jar包来实现webservice\n\n>**使用JAX-RS**\n       \n     JAX-RS 概述\n\t JAX-RS 是JAVA 针对REST(Representation State Transfer)风格制定的一套Web 服务规范\n\t 由于推出的较晚，该规范（JSR 311，目前JAX-RS 的版本为1.0）并未随JDK1.6 一起发行。\n\n### 6.使用JAX-WS进行测试案例 ###\n1. 步骤\n\n### 7.wsdl ###\n1. wsdl说明书结构 \n\n\t\t<service>服务视图，webservice的服务结点，它包括了服务端点\n\t\t<binding>为每个服务端点定义消息格式和协议细节\n\t\t<portType>服务端点，描述 web service可被执行的操作方法，以及相关的消息，通过binding指向portType\n\t\t<message>定义一个操作（方法）的数据参数(可有多个参数)\n\t\t<types> 定义 web service 使用的全部数据类型\n\n\n2.  wsdl 说明书阅读方式\n\n         从下往上读,先找到服务视图，通过binging找到protType，找到了protType就找到了我们要调用的webservice方法。\n\n### 8.webService优缺点 ###\n- 优点\n\n\t\t1、采用xml支持跨平台远程调用。\n\t\t2、基于http的soap协议，可跨越防火墙。\n\t\t3、支持面向对象开发。\n\t\t4、有利于软件和数据重用，实现松耦合。\n \n- 缺点\n\t\t\n\t\t由于soap是基于xml传输，本身使用xml传输会传输一些无关的东西从而效率不高，\n        随着soap协议的完善，soap协议增加了许多内容，这样就导致了使用soap协议进行数据传输的效率不高。\n\n### 9.开发中WebService的选择 ###\n \n- 适用场景\n\n\t\t发布一个服务（对内/对外），不考虑客户端类型，不考虑性能，建议使用webservice\n\t\t服务端已经确定使用webservice，客户端不能选择，必须使用webservice\n\t\t不适用场景\n\t\t考虑性能时不建议使用webservice\n\t\t同构程序下不建议使用webservice，比如java 用RMI，不需要翻译成XML的数据\n\n- RMI概念\n\n\t\tRMI（即Remote Method Invoke 远程方法调用）。在Java中，只要一个类extends了\n        java.rmi.Remote接口，即可成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。\n\n### 10.WebService 服务框架 CXF ###\n1. CXF概述\n\n\t\tCXF是Apache旗下的，所以全称叫Apache CXF\n\t\tApache CXF = Celtix + Xfire，开始叫 Apache CeltiXfire，后来更名为 Apache CXF 了，以下简称为 CXF。\n\t\tApache CXF 是一个开源的web Services 框架\n\t\tCXF 帮助您构建和开发 web Services \n\t\t它支持多种协议，比如：SOAP1.1,1,2、XML/HTTP、RESTful HTTP 或者 CORBA。\n\t\tCORBA（Common Object Request Broker Architecture公共对象请求代理体系结构,早期语言使用的WS。C,c++,C#）\n\t\tCxf是基于SOA总线结构，依靠spring完成模块的集成，实现SOA方式。\n        CXF可以灵活的部署：可以运行有Tomcat,Jboss,Jetty(内置),weblogic上面。 \n2. 操作\n\n### 11.REST概述重要 ###\n\n\t\tREST 是一种软件架构模式，只是一种风格\n\t\trest服务采用HTTP 做传输协议\n\t\tREST 对于HTTP 的利用实现精确的资源定位 \n        rest要求对资源定位更加准确， \n\n- Rest方式表示互联网上的资源更加准确，但是也有缺点，可能目录的层级较多不容易理解 \n- REST 是一种软件架构理念，现在被移植到Web 服务上，那么在开发Web 服务上，偏于面向资源的服务适用于REST，REST 简单易用，效率高，SOAP 成熟度较高，安全性较好。\n- 注意：REST 不等于WebService-soap，JAX-RS 只是将REST 设计风格应用到Web 服务开发上。","tags":["WebService的学习"]},{"title":"BootStrap","url":"/2019/07/22/bootStrap学习笔记/","content":"#### Bootstrap ####\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1563776659689&di=9ba05a212e9694b94544cf3f14c79db4&imgtype=0&src=http%3A%2F%2Fcodegeekz.com%2Fwp-content%2Fuploads%2FBootstrap.jpg)\n### 1.介绍 ###\n>Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。Bootstrap 目前的`最新版本是 Bootstrap4`，利用我们提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为你的想法开发出原型或者构建整个 app 。\n### 2.特点 ###\n\n\n- 移动设备优先：自 Bootstrap 3 起，框架包含了贯穿于整个库的移动设备优先的样式。\n\n- 响应式设计：Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机。\n\n### 3.Bootstrap 包的内容 ###\n\n- 基本结构：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构。这将在 Bootstrap 基本结构 部分详细讲解。\n- CSS：Bootstrap 自带以下特性：全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统。这将在 Bootstrap CSS 部分详细讲解。\n- 组件：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等等。这将在 布局组件 部分详细讲解。\n- JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件。您可以直接包含所有的插件，也可以逐个包含这些插件。这将在 Bootstrap 插件 部分详细讲解。\n- 定制：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本。\n\n### 问题点学习 ###\n1.`meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\" 解释`\n\n > [详细解析网址](http://https://blog.csdn.net/u012402190/article/details/70172371) ","tags":["技术介绍"]},{"title":"spring_AOP","url":"/2019/07/17/spring-AOP/","content":"![](http://img3.imgtn.bdimg.com/it/u=49453341,2859298398&fm=26&gp=0.jpg)\n### 1.AOP介绍 ###\n>**aop的全称-Aspect Oriented Programming**\n>\n>1)意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\n>\n>2)AOP是OOP（面向对象编程）的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。\n>\n>3)利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n>\n>4)AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码\n>\n>5)经典应用：事务管理、性能监视、安全检查、缓存 、日志等【画图】\n>\n>6)Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码\n>\n>7)AspectJ是一个基于Java语言的AOP框架，Spring2.0开始，Spring AOP引入对Aspect的支持，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的织入\n### 2.spring 实现AOP的两种原理 ###\n>a.aop底层将采用代理机制进行实现。\n>\n>b.接口 + 实现类 ：spring采用 jdk 的动态代理Proxy。\n>\n>c.实现类：spring 采用 cglib字节码增强。\n\n### 3.AOP的术语 ###\n\n>1.target：目标类，需要被代理的类。例如：UserService\n\n>2.Joinpoint(连接点):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法\n\n>3.PointCut 切入点：已经被增强的连接点。例如：addUser()\n\n>4.advice 通知/增强，增强代码。例如：after、before\n\n>5.Weaving(织入):是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程.\n\n>6.proxy 代理类\n\n>7.Aspect(切面): 是切入点pointcut和通知advice的结合\n\t\n   一个线是一个特殊的面。\n   一个切入点和一个通知，组成成一个特殊的面。","tags":["AOP的学习笔记"]},{"title":"Spring错误解决？","url":"/2019/07/06/Spring错误解决/","content":"![](http://ww1.sinaimg.cn/large/007SCiiVly1g4q9dp09gbj314h0423yu.jpg)\n---\n#### 在运行spring的注解时出的错误，现在还没有找到答案，应该是Spring版本的问题，运行环境是jdk1.8、spring3.2、commen-loggin1.2。\n---\n#### 1.解决办法，更换spring框架版本 ####\n> 由原来的3.2版本更换为4，在除了核心jar包外，又加入了另一个依赖包\n> \n>![](http://ww1.sinaimg.cn/large/007SCiiVly1g51y6942gcj309m04imx3.jpg)\n\n#### 2.在寻找错误时，如果是@Test 下测试 ####\n>可以借助 JUnil 进行错误查找。","tags":["spring @Component注解时的错误"]},{"title":"git_cmd下搭建hexo博客","url":"/2019/07/04/git_cmd下搭建hexo博客/","content":"![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562314728184&di=e9a138d51674a19e81a47cda7272ca7b&imgtype=0&src=http%3A%2F%2Fnewsimg.5054399.com%2Fuploads%2Fuserup%2F1902%2F151524461154.jpg)\n---\n#### 哈哈，进入b站那么久了，也早就了解到有博客这个东西，因此就一直想着搭建一个属于自己的技术博客，但是还是因为自己的技术问题以及等等，还是停留了许久。竟然初心是记录自己的技术成长的过程。那便可不必纠结是否整个网站都是自己一点一滴的建立起来。因此我利用hexo这个博客框架来快速建立自己的小乐园。下面就一起来操作吧。 ####\n---\n一、下载git（安装就一直next)\n>再下载安装nodejs you know!\n\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562910995&di=edd17820e5627f8f6500b3809f8f4790&imgtype=jpg&er=1&src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201807%2F20180720154704366185.gif)\n---\n二、再下载安装nodejs you know!\n\n---\n三、利用git cmd npm 进行命令行操作。\n\n> \n1. 下载cnpm \n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5a5ee5dijj30wz03kwfq.jpg)\n2. 安装git部署插件\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5a4nrjknnj30pm0fl76d.jpg)\n3. cnpm下载hexo框架\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5a4pqxg1gj31gt0npjw8.jpg)\n \n\n---\n四、建立个人博客文件夹（blog）。\n   >在系统盘下创建一个空文件夹,以便于等下hexo初始化。\n\n---\n五、初始化Hexo博客。\n \n1. ![](http://ww1.sinaimg.cn/large/007SCiiVly1g5a4x2yqf6j30kd055wel.jpg)\n2. 利用命令行到进入自己刚刚创建的文件夹下，运行命令行 cd ...\n3. \n   > `cd 保存内容的文件夹`\n   > \n   > `hexo init 你的用户名.github.io  // 建议和创建仓库时使用同一个`\n\n---\n六、本地运行loactlhost：4000。\n\n> cmd进入文件下 `hexo server`\n ![](http://ww1.sinaimg.cn/large/007SCiiVly1g5a5c3ak4cj30iy06sq2z.jpg)\n--效果图\n> ![](http://ww1.sinaimg.cn/large/007SCiiVly1g5a5j3mq90j31hb0szdt1.jpg)\n\n\n\n---\n七、部署到GitHub或者Gitee（两者各有千秋）。\n>作者我是直接部署在GitHub上的。\n>不过希望更多人看见自己的博客就可以考虑一下gitee。\n![](http://ww1.sinaimg.cn/large/007SCiiVly1g5a55smtjmj30wi0o70u1.jpg)\n---\n八、编写markdown的语法。\n\n> [详细网址教学](http://https://www.jianshu.com/p/191d1e21f7ed)\n> \n  \n\n\n\n","tags":["快速搭建个人博客Hexo"]},{"title":"Hello World","url":"/2019/07/03/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]